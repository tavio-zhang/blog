<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis大Key与热Key | Tavio&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/logo.jpg">
    <meta name="description" content="后端技术博客,别让自己落后于技术的迭代">
    <meta name="keywords" content="鲜衣努码少年郎">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.3d594d45.css" as="style"><link rel="preload" href="/assets/js/app.c6ba13aa.js" as="script"><link rel="preload" href="/assets/js/2.8d9f533d.js" as="script"><link rel="preload" href="/assets/js/73.c3ee5d2f.js" as="script"><link rel="prefetch" href="/assets/js/10.3c6e6522.js"><link rel="prefetch" href="/assets/js/11.09bc43b4.js"><link rel="prefetch" href="/assets/js/12.a996a87c.js"><link rel="prefetch" href="/assets/js/13.b02d3acf.js"><link rel="prefetch" href="/assets/js/14.64fd6e84.js"><link rel="prefetch" href="/assets/js/15.089c02a9.js"><link rel="prefetch" href="/assets/js/16.8fa236f4.js"><link rel="prefetch" href="/assets/js/17.a1730b7a.js"><link rel="prefetch" href="/assets/js/18.1335a425.js"><link rel="prefetch" href="/assets/js/19.9293cbc0.js"><link rel="prefetch" href="/assets/js/20.5d0fd1df.js"><link rel="prefetch" href="/assets/js/21.4319dddd.js"><link rel="prefetch" href="/assets/js/22.2d6d1193.js"><link rel="prefetch" href="/assets/js/23.f154e330.js"><link rel="prefetch" href="/assets/js/24.66ba0133.js"><link rel="prefetch" href="/assets/js/25.5979047a.js"><link rel="prefetch" href="/assets/js/26.04889c33.js"><link rel="prefetch" href="/assets/js/27.337928e8.js"><link rel="prefetch" href="/assets/js/28.665066df.js"><link rel="prefetch" href="/assets/js/29.5aa838b8.js"><link rel="prefetch" href="/assets/js/3.1aac6e80.js"><link rel="prefetch" href="/assets/js/30.a8923cf6.js"><link rel="prefetch" href="/assets/js/31.a290d548.js"><link rel="prefetch" href="/assets/js/32.cb2b7fdd.js"><link rel="prefetch" href="/assets/js/33.3286dca2.js"><link rel="prefetch" href="/assets/js/34.9aebb473.js"><link rel="prefetch" href="/assets/js/35.5777ff14.js"><link rel="prefetch" href="/assets/js/36.5c29dd6e.js"><link rel="prefetch" href="/assets/js/37.cbf6fde7.js"><link rel="prefetch" href="/assets/js/38.2a1572ab.js"><link rel="prefetch" href="/assets/js/39.000aacf6.js"><link rel="prefetch" href="/assets/js/4.16da1e3f.js"><link rel="prefetch" href="/assets/js/40.8fbbcfa8.js"><link rel="prefetch" href="/assets/js/41.1b995757.js"><link rel="prefetch" href="/assets/js/42.575e5238.js"><link rel="prefetch" href="/assets/js/43.0a4cb54f.js"><link rel="prefetch" href="/assets/js/44.8d3b4283.js"><link rel="prefetch" href="/assets/js/45.ae001bba.js"><link rel="prefetch" href="/assets/js/46.fc29dcb1.js"><link rel="prefetch" href="/assets/js/47.628ee1ef.js"><link rel="prefetch" href="/assets/js/48.7d4f854a.js"><link rel="prefetch" href="/assets/js/49.e848253a.js"><link rel="prefetch" href="/assets/js/5.20e9c2cf.js"><link rel="prefetch" href="/assets/js/50.045225be.js"><link rel="prefetch" href="/assets/js/51.d05a2035.js"><link rel="prefetch" href="/assets/js/52.35a2519d.js"><link rel="prefetch" href="/assets/js/53.ca8d5bc8.js"><link rel="prefetch" href="/assets/js/54.eb93e6ae.js"><link rel="prefetch" href="/assets/js/55.27ff3cca.js"><link rel="prefetch" href="/assets/js/56.4a98635a.js"><link rel="prefetch" href="/assets/js/57.db243c6d.js"><link rel="prefetch" href="/assets/js/58.650ffef2.js"><link rel="prefetch" href="/assets/js/59.9af578d0.js"><link rel="prefetch" href="/assets/js/6.cf5ce51d.js"><link rel="prefetch" href="/assets/js/60.800afb74.js"><link rel="prefetch" href="/assets/js/61.59b23cca.js"><link rel="prefetch" href="/assets/js/62.35998712.js"><link rel="prefetch" href="/assets/js/63.824df362.js"><link rel="prefetch" href="/assets/js/64.2f51e9d0.js"><link rel="prefetch" href="/assets/js/65.926e2499.js"><link rel="prefetch" href="/assets/js/66.2af85da2.js"><link rel="prefetch" href="/assets/js/67.bbd8d4b3.js"><link rel="prefetch" href="/assets/js/68.163c774f.js"><link rel="prefetch" href="/assets/js/69.deed8d29.js"><link rel="prefetch" href="/assets/js/7.92776da2.js"><link rel="prefetch" href="/assets/js/70.d6a81068.js"><link rel="prefetch" href="/assets/js/71.9adb8c50.js"><link rel="prefetch" href="/assets/js/72.9ba26fc5.js"><link rel="prefetch" href="/assets/js/74.af7973c7.js"><link rel="prefetch" href="/assets/js/75.ed8e7990.js"><link rel="prefetch" href="/assets/js/76.668519a5.js"><link rel="prefetch" href="/assets/js/77.d6cb2694.js"><link rel="prefetch" href="/assets/js/78.494cff39.js"><link rel="prefetch" href="/assets/js/79.486534af.js"><link rel="prefetch" href="/assets/js/8.d7fc67a9.js"><link rel="prefetch" href="/assets/js/80.c60f84eb.js"><link rel="prefetch" href="/assets/js/81.80ab610c.js"><link rel="prefetch" href="/assets/js/82.38a483d0.js"><link rel="prefetch" href="/assets/js/83.72b7d6a4.js"><link rel="prefetch" href="/assets/js/84.f5a347be.js"><link rel="prefetch" href="/assets/js/85.f3b7b32b.js"><link rel="prefetch" href="/assets/js/86.1d47bd30.js"><link rel="prefetch" href="/assets/js/87.2361eddb.js"><link rel="prefetch" href="/assets/js/88.aef9e475.js"><link rel="prefetch" href="/assets/js/89.0a95e3be.js"><link rel="prefetch" href="/assets/js/9.f6c9df9a.js"><link rel="prefetch" href="/assets/js/90.ddf7b632.js"><link rel="prefetch" href="/assets/js/91.2a96bacf.js"><link rel="prefetch" href="/assets/js/92.f61fc5ec.js"><link rel="prefetch" href="/assets/js/93.40a17799.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3d594d45.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="Tavio's blog" class="logo"> <span class="site-name can-hide">Tavio's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/node/jvm/" class="nav-link">JVM底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/thread/" class="nav-link">邪恶多线程</a></li><li class="dropdown-item"><!----> <a href="/node/mybatis/" class="nav-link">MyBatis底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/spring/" class="nav-link">Spring底层原理</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/db/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/mysql/" class="nav-link">MySQL的优化之路</a></li><li class="dropdown-item"><!----> <a href="/note/clickhouse/" class="nav-link">ClickHouse的高性能</a></li><li class="dropdown-item"><!----> <a href="/note/redis/" class="nav-link">Redis的快速查询</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/middleware/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/rabbitmq/" class="nav-link">RabbitMQ的生产</a></li><li class="dropdown-item"><!----> <a href="/note/kafka/" class="nav-link">Kafka的高吞吐量</a></li><li class="dropdown-item"><!----> <a href="/note/es/" class="nav-link">ES的入门到入坑</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践" class="dropdown-title"><a href="/practice/" class="link-title">实践</a> <span class="title" style="display:none;">实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/284351/" class="nav-link">MySQL自增ID主键空洞</a></li><li class="dropdown-item"><!----> <a href="/pages/8f1df0/" class="nav-link">前端实现长整型排序</a></li><li class="dropdown-item"><!----> <a href="/pages/13fcc3/" class="nav-link">MySQL无感换表</a></li><li class="dropdown-item"><!----> <a href="/pages/69e163/" class="nav-link">Redis延时双删</a></li><li class="dropdown-item"><!----> <a href="/pages/f43494/" class="nav-link">高并发秒杀优惠卷</a></li><li class="dropdown-item"><!----> <a href="/pages/ab9a49/" class="nav-link">AOP无侵入式告警</a></li><li class="dropdown-item"><!----> <a href="/pages/a3f3fd/" class="nav-link">长短链接跳转</a></li><li class="dropdown-item"><!----> <a href="/pages/942d4b/" class="nav-link">订单超时取消</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/tavio-zhang/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.jpg"> <div class="blogger-info"><h3>Tavio Zhang</h3> <span>努力学习的小码喽</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/node/jvm/" class="nav-link">JVM底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/thread/" class="nav-link">邪恶多线程</a></li><li class="dropdown-item"><!----> <a href="/node/mybatis/" class="nav-link">MyBatis底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/spring/" class="nav-link">Spring底层原理</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/db/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/mysql/" class="nav-link">MySQL的优化之路</a></li><li class="dropdown-item"><!----> <a href="/note/clickhouse/" class="nav-link">ClickHouse的高性能</a></li><li class="dropdown-item"><!----> <a href="/note/redis/" class="nav-link">Redis的快速查询</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/middleware/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/rabbitmq/" class="nav-link">RabbitMQ的生产</a></li><li class="dropdown-item"><!----> <a href="/note/kafka/" class="nav-link">Kafka的高吞吐量</a></li><li class="dropdown-item"><!----> <a href="/note/es/" class="nav-link">ES的入门到入坑</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践" class="dropdown-title"><a href="/practice/" class="link-title">实践</a> <span class="title" style="display:none;">实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/284351/" class="nav-link">MySQL自增ID主键空洞</a></li><li class="dropdown-item"><!----> <a href="/pages/8f1df0/" class="nav-link">前端实现长整型排序</a></li><li class="dropdown-item"><!----> <a href="/pages/13fcc3/" class="nav-link">MySQL无感换表</a></li><li class="dropdown-item"><!----> <a href="/pages/69e163/" class="nav-link">Redis延时双删</a></li><li class="dropdown-item"><!----> <a href="/pages/f43494/" class="nav-link">高并发秒杀优惠卷</a></li><li class="dropdown-item"><!----> <a href="/pages/ab9a49/" class="nav-link">AOP无侵入式告警</a></li><li class="dropdown-item"><!----> <a href="/pages/a3f3fd/" class="nav-link">长短链接跳转</a></li><li class="dropdown-item"><!----> <a href="/pages/942d4b/" class="nav-link">订单超时取消</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/tavio-zhang/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/eada73/" class="sidebar-link">Redis核心数据结构</a></li><li><a href="/pages/d81738/" class="sidebar-link">Redis持久化机制</a></li><li><a href="/pages/797c36/" class="sidebar-link">Redis高可用架构</a></li><li><a href="/pages/88227a/" class="sidebar-link">Redis分布式锁</a></li><li><a href="/pages/ea330e/" class="sidebar-link">Redis缓存设计</a></li><li><a href="/pages/d2662c/" aria-current="page" class="active sidebar-link">Redis大Key与热Key</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/d2662c/#一、核心概念与本质区别" class="sidebar-link">一、核心概念与本质区别</a></li><li class="sidebar-sub-header level2"><a href="/pages/d2662c/#二、大-key-问题深度解析" class="sidebar-link">二、大 Key 问题深度解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_2-1-什么是大-key" class="sidebar-link">2.1 什么是大 Key？</a></li><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_2-2-大-key-的核心危害-底层原理-业务影响" class="sidebar-link">2.2 大 Key 的核心危害（底层原理+业务影响）</a></li><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_2-3-大-key-的识别方法-实战命令-工具" class="sidebar-link">2.3 大 Key 的识别方法（实战命令+工具）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方法1-redis-原生命令-基础排查" class="sidebar-link">方法1：Redis 原生命令（基础排查）</a></li><li class="sidebar-sub-header level5"><a href="/pages/d2662c/#_1-扫描大-key-redis-cli-bigkeys" class="sidebar-link">（1）扫描大 Key（redis-cli --bigkeys）</a></li><li class="sidebar-sub-header level5"><a href="/pages/d2662c/#_2-精准查询-key-内存-memory-usage" class="sidebar-link">（2）精准查询 Key 内存（MEMORY USAGE）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方法2-自定义-scan-脚本-精准筛选-生产推荐" class="sidebar-link">方法2：自定义 Scan 脚本（精准筛选，生产推荐）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方法3-第三方工具-可视化-高效" class="sidebar-link">方法3：第三方工具（可视化+高效）</a></li><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_2-4-大-key-的解决方案-按优先级排序" class="sidebar-link">2.4 大 Key 的解决方案（按优先级排序）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案1-拆分大-key-根治方案-首选" class="sidebar-link">方案1：拆分大 Key（根治方案，首选）</a></li><li class="sidebar-sub-header level5"><a href="/pages/d2662c/#_1-string-类型拆分-垂直拆分" class="sidebar-link">（1）String 类型拆分（垂直拆分）</a></li><li class="sidebar-sub-header level5"><a href="/pages/d2662c/#_2-集合类型拆分-水平分片" class="sidebar-link">（2）集合类型拆分（水平分片）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案2-数据压缩-临时优化-配合拆分" class="sidebar-link">方案2：数据压缩（临时优化，配合拆分）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案3-冷热分离-大-key-降级" class="sidebar-link">方案3：冷热分离（大 Key 降级）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案4-异步-分批操作-避免阻塞" class="sidebar-link">方案4：异步/分批操作（避免阻塞）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案5-调整-redis-配置-兜底优化" class="sidebar-link">方案5：调整 Redis 配置（兜底优化）</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/d2662c/#三、热-key-问题深度解析" class="sidebar-link">三、热 Key 问题深度解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_3-1-什么是热-key" class="sidebar-link">3.1 什么是热 Key？</a></li><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_3-2-热-key-的核心危害" class="sidebar-link">3.2 热 Key 的核心危害</a></li><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_3-3-热-key-的识别方法" class="sidebar-link">3.3 热 Key 的识别方法</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方法1-监控指标-生产首选" class="sidebar-link">方法1：监控指标（生产首选）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方法2-redis-原生命令-快速排查" class="sidebar-link">方法2：Redis 原生命令（快速排查）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方法3-客户端埋点-精准定位" class="sidebar-link">方法3：客户端埋点（精准定位）</a></li><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_3-4-热-key-的解决方案-按优先级排序" class="sidebar-link">3.4 热 Key 的解决方案（按优先级排序）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案1-本地缓存-caffeine-多级缓存-首选" class="sidebar-link">方案1：本地缓存（Caffeine）+ 多级缓存（首选）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案2-热-key-分散-哈希分片" class="sidebar-link">方案2：热 Key 分散（哈希分片）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案3-读写分离-主从复制" class="sidebar-link">方案3：读写分离 + 主从复制</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案4-熔断限流-兜底保护" class="sidebar-link">方案4：熔断限流（兜底保护）</a></li><li class="sidebar-sub-header level4"><a href="/pages/d2662c/#方案5-预加载-永不过期" class="sidebar-link">方案5：预加载 + 永不过期</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/d2662c/#四、大-key-热-key-叠加问题-最高风险" class="sidebar-link">四、大 Key + 热 Key 叠加问题（最高风险）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#解决方案-组合策略" class="sidebar-link">解决方案：组合策略</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/d2662c/#五、最佳实践总结" class="sidebar-link">五、最佳实践总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_5-1-预防策略-核心" class="sidebar-link">5.1 预防策略（核心）</a></li><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_5-2-治理策略" class="sidebar-link">5.2 治理策略</a></li><li class="sidebar-sub-header level3"><a href="/pages/d2662c/#_5-3-应急策略" class="sidebar-link">5.3 应急策略</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/d2662c/#六、核心区别与对比表" class="sidebar-link">六、核心区别与对比表</a></li></ul></li><li><a href="/pages/dd29df/" class="sidebar-link">Redis限流</a></li><li><a href="/pages/aeefc4/" class="sidebar-link">Redis IO多路复用</a></li><li><a href="/pages/347bce/" class="sidebar-link">Redis过期删除策略</a></li><li><a href="/pages/390684/" class="sidebar-link">Redis Bitmap</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/note/redis/#《Redis》笔记" data-v-06225672>《Redis》笔记</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/tavio-zhang" target="_blank" title="作者" class="beLink" data-v-06225672>Tavio</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-05-03</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Redis大Key与热Key<!----></h1>  <div class="theme-vdoing-content content__default"><p>Redis 中的<strong>大 Key</strong> 和 <strong>热 Key</strong> 是高并发/大规模场景下的两大核心性能瓶颈，前者因“数据体积过大”导致内存、网络、操作阻塞问题，后者因“访问频率过高”引发单节点过载、服务不可用风险。两者可能单独出现，也可能叠加（如一个大 Key 同时是热 Key，危害呈指数级放大）。</p> <h2 id="一、核心概念与本质区别"><a href="#一、核心概念与本质区别" class="header-anchor">#</a> 一、核心概念与本质区别</h2> <p>先明确两者的核心差异，避免混淆：</p> <table><thead><tr><th>维度</th> <th>大 Key（Big Key）</th> <th>热 Key（Hot Key）</th></tr></thead> <tbody><tr><td>核心特征</td> <td>数据体积/元素数量大（占用内存多）</td> <td>访问频率极高（QPS 远高于普通 Key）</td></tr> <tr><td>判定标准</td> <td>String：&gt;10KB；Hash/ZSet/List：元素数&gt;1000个</td> <td>单 Key QPS &gt; 1000（或占节点总 QPS 10% 以上）</td></tr> <tr><td>核心危害</td> <td>内存倾斜、操作阻塞、传输缓慢</td> <td>单节点过载、网卡打满、缓存击穿/雪崩</td></tr> <tr><td>影响范围</td> <td>主要影响 Redis 存储/操作性能</td> <td>主要影响 Redis 访问/网络性能</td></tr> <tr><td>典型场景</td> <td>存储全量商品列表、用户全量订单、大文本内容</td> <td>秒杀商品、首页热门数据、高频查询的配置 Key</td></tr></tbody></table> <h2 id="二、大-key-问题深度解析"><a href="#二、大-key-问题深度解析" class="header-anchor">#</a> 二、大 Key 问题深度解析</h2> <h3 id="_2-1-什么是大-key"><a href="#_2-1-什么是大-key" class="header-anchor">#</a> 2.1 什么是大 Key？</h3> <p>大 Key 不是指“Key 名称长”，而是指 <strong>Key 对应的 Value 数据体积过大，或集合类型（Hash/ZSet/List/Set）的元素数量过多</strong>。行业通用判定阈值（可根据业务调整）：</p> <ul><li>String 类型：Value 大小 ≥ 10KB（核心业务建议 ≤ 5KB）；</li> <li>集合类型：
<ul><li>Hash/ZSet/Set：元素数量 ≥ 1000 个（核心业务 ≤ 500 个）；</li> <li>List：元素数量 ≥ 5000 个（或列表长度 ≥ 1000）。</li></ul></li></ul> <p>⚠️ 注意：即使单 Key 内存不大（如 5KB），但如果是百万级数量的此类 Key，也会累计成“大内存占用”，但不属于本文讨论的“大 Key”（属于“内存膨胀”问题）。</p> <h3 id="_2-2-大-key-的核心危害-底层原理-业务影响"><a href="#_2-2-大-key-的核心危害-底层原理-业务影响" class="header-anchor">#</a> 2.2 大 Key 的核心危害（底层原理+业务影响）</h3> <p>Redis 是单线程事件循环模型，大 Key 操作会阻塞主线程，引发一系列连锁反应：</p> <table><thead><tr><th>危害类型</th> <th>底层原理</th> <th>业务影响示例</th></tr></thead> <tbody><tr><td>内存分布不均（集群倾斜）</td> <td>大 Key 集中在某一节点，导致集群节点内存使用率差异＞50%，触发内存淘汰/宕机</td> <td>节点 A 内存 90%，节点 B 内存 30%</td></tr> <tr><td>操作阻塞（DEL/EXPIRE）</td> <td>单线程执行 DEL 大 Key 时，需遍历释放所有内存，阻塞毫秒级→秒级，期间无法处理其他请求</td> <td>服务响应超时、接口 500 报错</td></tr> <tr><td>网络传输缓慢</td> <td>大 Key 序列化/反序列化、网络传输耗时久，占用带宽</td> <td>客户端读取超时、Redis 网卡瓶颈</td></tr> <tr><td>主从复制卡顿</td> <td>大 Key 同步时占用大量网络/CPU，导致主从延迟＞秒级，数据一致性风险</td> <td>从库数据滞后，故障切换时丢数据</td></tr> <tr><td>RDB/AOF 性能下降</td> <td>Fork 子进程时，大 Key 拷贝耗时久；AOF 写入时，大 Key 操作日志体积大</td> <td>备份耗时翻倍、AOF 文件膨胀</td></tr> <tr><td>扩容/迁移失败</td> <td>集群扩容时，大 Key 迁移耗时超阈值，触发迁移超时/失败</td> <td>集群扩容中断、服务不可用</td></tr></tbody></table> <h3 id="_2-3-大-key-的识别方法-实战命令-工具"><a href="#_2-3-大-key-的识别方法-实战命令-工具" class="header-anchor">#</a> 2.3 大 Key 的识别方法（实战命令+工具）</h3> <h4 id="方法1-redis-原生命令-基础排查"><a href="#方法1-redis-原生命令-基础排查" class="header-anchor">#</a> 方法1：Redis 原生命令（基础排查）</h4> <h5 id="_1-扫描大-key-redis-cli-bigkeys"><a href="#_1-扫描大-key-redis-cli-bigkeys" class="header-anchor">#</a> （1）扫描大 Key（redis-cli --bigkeys）</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code># 扫描所有 Key，统计各类型大 Key，输出汇总（耗时久，生产建议低峰期执行）
redis-cli -h {host} -p {port} -a {password} --bigkeys

# 输出示例（重点看“Biggest”部分）：
# Scanning the entire keyspace to find biggest keys as well as
# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec per 100 SCAN commands to reduce server load.
# [00.00%] Biggest string key: &quot;goods:detail:1001&quot; (size: 25600 bytes)
# [00.00%] Biggest hash key: &quot;user:order:10086&quot; (fields: 5000)
# [00.00%] Biggest zset key: &quot;rank:hot:goods&quot; (elements: 8000)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>⚠️ 注意：<code>--bigkeys</code> 仅统计“元素数最多”的集合 Key 和“体积最大”的 String Key，无法自定义阈值（比如只查＞10KB 的 String），且会遍历全量 Key，高并发时慎用（可加 <code>-i 0.1</code> 降低扫描压力）。</p> <h5 id="_2-精准查询-key-内存-memory-usage"><a href="#_2-精准查询-key-内存-memory-usage" class="header-anchor">#</a> （2）精准查询 Key 内存（MEMORY USAGE）</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code># 查询单个 Key 的内存占用（单位：字节，包含元数据）
redis-cli MEMORY USAGE &quot;goods:detail:1001&quot;

# 输出示例：25689（≈25KB，判定为大 Key）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="方法2-自定义-scan-脚本-精准筛选-生产推荐"><a href="#方法2-自定义-scan-脚本-精准筛选-生产推荐" class="header-anchor">#</a> 方法2：自定义 Scan 脚本（精准筛选，生产推荐）</h4> <p>通过 <code>SCAN</code> 遍历所有 Key，结合 <code>MEMORY USAGE</code>/<code>HLEN</code>/<code>ZCARD</code> 等命令筛选符合阈值的大 Key，避免全量遍历阻塞：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import redis

# 连接 Redis
r = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, password=&quot;xxx&quot;, decode_responses=True)

# 大 Key 阈值
STRING_THRESHOLD = 10 * 1024  # 10KB
HASH_THRESHOLD = 1000          # Hash 元素数阈值

# 扫描 Key（游标遍历，避免阻塞）
cursor = 0
big_keys = []
while True:
    cursor, keys = r.scan(cursor, count=1000)  # 每次扫描1000个Key
    for key in keys:
        # 获取 Key 类型
        key_type = r.type(key)
        if key_type == &quot;string&quot;:
            # String 类型：判断内存大小
            mem = r.memory_usage(key)
            if mem &gt;= STRING_THRESHOLD:
                big_keys.append({&quot;key&quot;: key, &quot;type&quot;: &quot;string&quot;, &quot;size&quot;: mem})
        elif key_type == &quot;hash&quot;:
            # Hash 类型：判断元素数
            hlen = r.hlen(key)
            if hlen &gt;= HASH_THRESHOLD:
                big_keys.append({&quot;key&quot;: key, &quot;type&quot;: &quot;hash&quot;, &quot;fields&quot;: hlen})
        # 可扩展 ZSet/List/Set 类型的判断
    if cursor == 0:
        break

# 输出大 Key 列表
print(&quot;发现大 Key 数量：&quot;, len(big_keys))
for k in big_keys:
    print(k)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h4 id="方法3-第三方工具-可视化-高效"><a href="#方法3-第三方工具-可视化-高效" class="header-anchor">#</a> 方法3：第三方工具（可视化+高效）</h4> <ul><li><strong>RedisInsight</strong>（Redis 官方工具）：可视化查看 Key 内存、元素数，支持按大小/类型筛选大 Key；</li> <li><strong>RedisShake</strong>（阿里开源）：离线解析 RDB 文件，快速定位大 Key（无需在线扫描，无性能影响）；</li> <li><strong>Prometheus + Grafana</strong>：通过 <code>redis_key_size</code> 指标（需部署 Redis Exporter），监控单 Key 内存变化，设置大 Key 告警阈值。</li></ul> <h3 id="_2-4-大-key-的解决方案-按优先级排序"><a href="#_2-4-大-key-的解决方案-按优先级排序" class="header-anchor">#</a> 2.4 大 Key 的解决方案（按优先级排序）</h3> <p>核心思路：<strong>拆分为主，压缩为辅，冷热分离兜底，操作异步化</strong>。</p> <h4 id="方案1-拆分大-key-根治方案-首选"><a href="#方案1-拆分大-key-根治方案-首选" class="header-anchor">#</a> 方案1：拆分大 Key（根治方案，首选）</h4> <p>根据数据类型不同，拆分策略不同：</p> <h5 id="_1-string-类型拆分-垂直拆分"><a href="#_1-string-类型拆分-垂直拆分" class="header-anchor">#</a> （1）String 类型拆分（垂直拆分）</h5> <p>将大文本/大对象拆分为多个小 String Key，比如：</p> <ul><li>原 Key：<code>goods:detail:1001</code>（存储商品所有详情，20KB）；</li> <li>拆分后：
<ul><li><code>goods:name:1001</code>（商品名称，1KB）；</li> <li><code>goods:price:1001</code>（商品价格，0.5KB）；</li> <li><code>goods:desc:1001</code>（商品描述，15KB → 再拆分为 <code>goods:desc:1001:1</code>/<code>goods:desc:1001:2</code>）。</li></ul></li></ul> <p>代码示例（Java）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 拆分存储
public void saveGoodsDetail(Goods goods) {
    // 基础信息拆分
    redisTemplate.opsForValue().set(&quot;goods:name:&quot; + goods.getId(), goods.getName());
    redisTemplate.opsForValue().set(&quot;goods:price:&quot; + goods.getId(), goods.getPrice().toString());
    // 长描述拆分（按10KB拆分）
    String desc = goods.getDesc();
    int chunkSize = 10 * 1024; // 10KB/段
    int chunks = (desc.length() + chunkSize - 1) / chunkSize;
    for (int i = 0; i &lt; chunks; i++) {
        int start = i * chunkSize;
        int end = Math.min((i + 1) * chunkSize, desc.length());
        String chunk = desc.substring(start, end);
        redisTemplate.opsForValue().set(&quot;goods:desc:&quot; + goods.getId() + &quot;:&quot; + i, chunk);
    }
}

// 合并读取
public Goods getGoodsDetail(Long id) {
    Goods goods = new Goods();
    goods.setId(id);
    goods.setName((String) redisTemplate.opsForValue().get(&quot;goods:name:&quot; + id));
    goods.setPrice(new BigDecimal((String) redisTemplate.opsForValue().get(&quot;goods:price:&quot; + id)));
    // 合并描述
    StringBuilder desc = new StringBuilder();
    int i = 0;
    while (true) {
        String chunk = (String) redisTemplate.opsForValue().get(&quot;goods:desc:&quot; + id + &quot;:&quot; + i);
        if (chunk == null) break;
        desc.append(chunk);
        i++;
    }
    goods.setDesc(desc.toString());
    return goods;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h5 id="_2-集合类型拆分-水平分片"><a href="#_2-集合类型拆分-水平分片" class="header-anchor">#</a> （2）集合类型拆分（水平分片）</h5> <p>以 Hash 为例（存储用户10000条订单）：</p> <ul><li>原 Key：<code>user:order:10086</code>（Hash，10000个字段）；</li> <li>拆分后：按订单 ID 哈希分片，拆为10个小 Hash：
<ul><li><code>user:order:10086:0</code>（订单 ID % 10 = 0）；</li> <li><code>user:order:10086:1</code>（订单 ID % 10 = 1）；</li> <li>...</li> <li><code>user:order:10086:9</code>（订单 ID % 10 = 9）。</li></ul></li></ul> <p>代码示例（Java）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 分片存储订单
public void saveUserOrder(Long userId, Order order) {
    // 按订单ID哈希分片（10个分片）
    int shard = (int) (order.getId() % 10);
    String shardKey = &quot;user:order:&quot; + userId + &quot;:&quot; + shard;
    // 存储到对应分片Hash
    redisTemplate.opsForHash().put(shardKey, order.getId().toString(), order);
}

// 分片查询订单
public Order getUserOrder(Long userId, Long orderId) {
    int shard = (int) (orderId % 10);
    String shardKey = &quot;user:order:&quot; + userId + &quot;:&quot; + shard;
    return (Order) redisTemplate.opsForHash().get(shardKey, orderId.toString());
}

// 批量查询用户订单（遍历所有分片）
public List&lt;Order&gt; listUserOrders(Long userId) {
    List&lt;Order&gt; orders = new ArrayList&lt;&gt;();
    for (int shard = 0; shard &lt; 10; shard++) {
        String shardKey = &quot;user:order:&quot; + userId + &quot;:&quot; + shard;
        // 用hscan分批遍历，避免hgetall阻塞
        Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; cursor = redisTemplate.opsForHash().scan(
            shardKey, ScanOptions.scanOptions().count(100).build()
        );
        while (cursor.hasNext()) {
            Map.Entry&lt;Object, Object&gt; entry = cursor.next();
            orders.add((Order) entry.getValue());
        }
    }
    return orders;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h4 id="方案2-数据压缩-临时优化-配合拆分"><a href="#方案2-数据压缩-临时优化-配合拆分" class="header-anchor">#</a> 方案2：数据压缩（临时优化，配合拆分）</h4> <p>对无法拆分的 String 大 Key（如序列化后的对象），通过压缩降低体积：</p> <ul><li>压缩算法：Snappy（高性能）、GZIP（高压缩比，CPU 消耗高）；</li> <li>适用场景：冷/温大 Key（访问频率低，可接受压缩/解压缩耗时）。</li></ul> <p>代码示例（Java + Snappy）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import org.xerial.snappy.Snappy;

// 压缩存储
public void saveBigString(String key, String value) throws IOException {
    byte[] rawBytes = value.getBytes(StandardCharsets.UTF_8);
    byte[] compressedBytes = Snappy.compress(rawBytes);
    redisTemplate.opsForValue().set(key, compressedBytes);
}

// 解压缩读取
public String getBigString(String key) throws IOException {
    byte[] compressedBytes = (byte[]) redisTemplate.opsForValue().get(key);
    if (compressedBytes == null) return null;
    byte[] rawBytes = Snappy.uncompress(compressedBytes);
    return new String(rawBytes, StandardCharsets.UTF_8);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="方案3-冷热分离-大-key-降级"><a href="#方案3-冷热分离-大-key-降级" class="header-anchor">#</a> 方案3：冷热分离（大 Key 降级）</h4> <p>将大 Key 中的冷数据迁移到低成本存储（如 HBase、Elasticsearch、MySQL），Redis 仅保留热数据：</p> <ul><li>示例：用户订单大 Key 中，仅缓存近3个月的热订单（Redis），3个月前的冷订单存储到 HBase；</li> <li>读取逻辑：先查 Redis 热数据，未命中则查 HBase 冷数据。</li></ul> <h4 id="方案4-异步-分批操作-避免阻塞"><a href="#方案4-异步-分批操作-避免阻塞" class="header-anchor">#</a> 方案4：异步/分批操作（避免阻塞）</h4> <ul><li><strong>删除大 Key</strong>：用 <code>UNLINK</code> 代替 <code>DEL</code>（Redis 4.0+ 支持），<code>UNLINK</code> 异步释放内存，不阻塞主线程：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  # 异步删除大 Key（推荐）
  UNLINK &quot;user:order:10086&quot;
  # 对比：DEL 会阻塞主线程
  DEL &quot;user:order:10086&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>遍历大集合</strong>：用 <code>HSCAN/ZSCAN/LSCAN</code> 代替 <code>HGETALL/ZRANGE/LRANGE 0 -1</code>，分批遍历（每次100条），避免一次性读取所有元素阻塞线程。</li></ul> <h4 id="方案5-调整-redis-配置-兜底优化"><a href="#方案5-调整-redis-配置-兜底优化" class="header-anchor">#</a> 方案5：调整 Redis 配置（兜底优化）</h4> <ul><li>关闭大 Key 的过期时间：若大 Key 必须存在，尽量不设置 <code>EXPIRE</code>（过期删除会阻塞），改为业务层异步清理；</li> <li>增大 <code>client-output-buffer-limit</code>：避免大 Key 传输时触发客户端输出缓冲区限制，断开连接（仅临时调整）。</li></ul> <h2 id="三、热-key-问题深度解析"><a href="#三、热-key-问题深度解析" class="header-anchor">#</a> 三、热 Key 问题深度解析</h2> <h3 id="_3-1-什么是热-key"><a href="#_3-1-什么是热-key" class="header-anchor">#</a> 3.1 什么是热 Key？</h3> <p>热 Key 是指<strong>单 Key 被高频次访问</strong>，导致该 Key 所在的 Redis 节点成为“热点节点”，占用节点绝大部分 CPU、内存、网络资源。行业通用判定标准：</p> <ul><li>单 Key QPS ≥ 1000（核心业务建议 ≤ 500）；</li> <li>单 Key 访问量占所在节点总访问量的 10% 以上；</li> <li>热点持续时间 ≥ 10 秒（瞬时热点可忽略）。</li></ul> <p>⚠️ 注意：热 Key 不一定是大 Key，但如果热 Key 同时是大 Key（如 10KB 的 String 热 Key），会同时引发“访问高频+传输缓慢”，危害翻倍。</p> <h3 id="_3-2-热-key-的核心危害"><a href="#_3-2-热-key-的核心危害" class="header-anchor">#</a> 3.2 热 Key 的核心危害</h3> <p>热 Key 会直接压垮单个 Redis 节点，进而引发整个集群的性能问题：</p> <table><thead><tr><th>危害类型</th> <th>底层原理</th> <th>业务影响示例</th></tr></thead> <tbody><tr><td>单节点 CPU 满载</td> <td>高频命令（GET/SET）占用节点 CPU 100%，无法处理其他请求</td> <td>节点响应超时，服务雪崩</td></tr> <tr><td>网卡带宽打满</td> <td>热 Key 高频传输，占用节点网卡 90% 以上带宽，其他 Key 传输被阻塞</td> <td>网络延迟飙升，客户端连接超时</td></tr> <tr><td>集群负载不均</td> <td>热 Key 固定在某一节点（Redis 集群按 Key 哈希分片），节点负载差异＞80%</td> <td>节点宕机，集群故障切换</td></tr> <tr><td>缓存击穿/雪崩</td> <td>热 Key 过期/失效时，大量请求穿透到数据库，压垮 DB</td> <td>数据库宕机，服务不可用</td></tr> <tr><td>客户端连接数耗尽</td> <td>高频访问导致客户端到热点节点的连接数达到上限，新连接被拒绝</td> <td>接口报错“Could not get resource”</td></tr></tbody></table> <h3 id="_3-3-热-key-的识别方法"><a href="#_3-3-热-key-的识别方法" class="header-anchor">#</a> 3.3 热 Key 的识别方法</h3> <h4 id="方法1-监控指标-生产首选"><a href="#方法1-监控指标-生产首选" class="header-anchor">#</a> 方法1：监控指标（生产首选）</h4> <p>通过 Prometheus + Grafana + Redis Exporter 监控以下指标：</p> <ul><li><code>redis_key_space_hits</code>：单 Key 命中次数（需开启 <code>redis-cli config set keyspace_events KEA</code>）；</li> <li><code>redis_command_stats</code>：统计 <code>GET/SET</code> 等命令的执行次数，定位高频命令对应的 Key；</li> <li><code>redis_server_net_input_bytes</code>/<code>redis_server_net_output_bytes</code>：单节点网络流量，定位热点节点。</li></ul> <h4 id="方法2-redis-原生命令-快速排查"><a href="#方法2-redis-原生命令-快速排查" class="header-anchor">#</a> 方法2：Redis 原生命令（快速排查）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code># 查看命令执行统计（按执行次数排序）
redis-cli INFO commandstats | grep -E &quot;cmdstat_|calls&quot; | sort -k2 -nr

# 输出示例（GET 命令执行100万次，远高于其他命令）：
# cmdstat_get:calls=1000000,usec=500000,usec_per_call=0.50
# cmdstat_set:calls=100000,usec=100000,usec_per_call=1.00
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="方法3-客户端埋点-精准定位"><a href="#方法3-客户端埋点-精准定位" class="header-anchor">#</a> 方法3：客户端埋点（精准定位）</h4> <p>在业务代码中统计每个 Key 的访问次数，超过阈值则标记为热 Key：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Service
public class HotKeyMonitorService {
    // 访问次数计数器（本地缓存，定时清理）
    private final Map&lt;String, AtomicInteger&gt; keyCounter = new ConcurrentHashMap&lt;&gt;();
    // 热 Key 阈值（QPS ≥ 1000）
    private static final int HOT_KEY_THRESHOLD = 1000;
    // 统计周期（10秒）
    private static final long STAT_PERIOD = 10 * 1000;

    // 初始化定时任务：每10秒检测热 Key
    @PostConstruct
    public void initMonitor() {
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
        executor.scheduleAtFixedRate(this::detectHotKey, 0, STAT_PERIOD, TimeUnit.MILLISECONDS);
    }

    // 记录 Key 访问
    public void recordKeyAccess(String key) {
        keyCounter.computeIfAbsent(key, k -&gt; new AtomicInteger(0)).incrementAndGet();
    }

    // 检测热 Key
    private void detectHotKey() {
        List&lt;String&gt; hotKeys = new ArrayList&lt;&gt;();
        long qpsThreshold = HOT_KEY_THRESHOLD;
        for (Map.Entry&lt;String, AtomicInteger&gt; entry : keyCounter.entrySet()) {
            int count = entry.getValue().get();
            long qps = count / (STAT_PERIOD / 1000);
            if (qps &gt;= qpsThreshold) {
                hotKeys.add(entry.getKey() + &quot; (QPS: &quot; + qps + &quot;)&quot;);
            }
            // 重置计数器
            entry.getValue().set(0);
        }
        if (!hotKeys.isEmpty()) {
            log.warn(&quot;检测到热 Key：{}&quot;, String.join(&quot;, &quot;, hotKeys));
        }
    }
}

// 业务层集成埋点
@Service
public class GoodsService {
    @Autowired
    private HotKeyMonitorService hotKeyMonitorService;

    public Goods getGoodsById(Long id) {
        String key = &quot;goods:id:&quot; + id;
        // 记录 Key 访问
        hotKeyMonitorService.recordKeyAccess(key);
        // 后续查询逻辑...
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><h3 id="_3-4-热-key-的解决方案-按优先级排序"><a href="#_3-4-热-key-的解决方案-按优先级排序" class="header-anchor">#</a> 3.4 热 Key 的解决方案（按优先级排序）</h3> <p>核心思路：<strong>分散访问压力，降低热点节点负载，避免单点依赖</strong>。</p> <h4 id="方案1-本地缓存-caffeine-多级缓存-首选"><a href="#方案1-本地缓存-caffeine-多级缓存-首选" class="header-anchor">#</a> 方案1：本地缓存（Caffeine）+ 多级缓存（首选）</h4> <p>在应用层（JVM）增加本地缓存（如 Caffeine），缓存热 Key 数据，减少对 Redis 的直接访问：</p> <ul><li>逻辑：请求先查本地缓存 → 未命中查 Redis → 未命中查 DB → 更新 Redis + 本地缓存；</li> <li>优势：本地缓存访问耗时＜1ms，可承接 90% 以上的热 Key 请求；</li> <li>注意：本地缓存需设置短过期时间（2~5分钟），并通过消息队列同步更新（避免数据不一致）。</li></ul> <p>代码示例（Java + Caffeine）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 配置本地缓存
@Configuration
public class CaffeineConfig {
    @Bean
    public Cache&lt;String, Object&gt; localHotKeyCache() {
        return Caffeine.newBuilder()
                .maximumSize(1000) // 缓存1000个热 Key
                .expireAfterWrite(3, TimeUnit.MINUTES) // 3分钟过期
                .recordStats() // 开启统计
                .build();
    }
}

// 业务层集成本地缓存
@Service
public class GoodsService {
    @Autowired
    private Cache&lt;String, Object&gt; localHotKeyCache;
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;
    @Autowired
    private GoodsMapper goodsMapper;

    public Goods getGoodsById(Long id) {
        String key = &quot;goods:id:&quot; + id;
        // 1. 查本地缓存
        Goods goods = (Goods) localHotKeyCache.getIfPresent(key);
        if (goods != null) {
            return goods;
        }
        // 2. 查 Redis
        goods = (Goods) redisTemplate.opsForValue().get(key);
        if (goods != null) {
            // 更新本地缓存
            localHotKeyCache.put(key, goods);
            return goods;
        }
        // 3. 查 DB
        goods = goodsMapper.selectById(id);
        if (goods != null) {
            // 更新 Redis + 本地缓存
            redisTemplate.opsForValue().set(key, goods, 30, TimeUnit.MINUTES);
            localHotKeyCache.put(key, goods);
        }
        return goods;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><h4 id="方案2-热-key-分散-哈希分片"><a href="#方案2-热-key-分散-哈希分片" class="header-anchor">#</a> 方案2：热 Key 分散（哈希分片）</h4> <p>将单个热 Key 拆分为多个“子热 Key”，分散到不同 Redis 节点，降低单节点压力：</p> <ul><li>示例：热 Key <code>goods:hot:1001</code> → 拆分为 <code>goods:hot:1001:0</code> ~ <code>goods:hot:1001:9</code>；</li> <li>写入：将数据同步写入所有子 Key；</li> <li>读取：客户端随机访问一个子 Key（如 <code>Random.nextInt(10)</code>）。</li></ul> <p>代码示例（Java）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 写入：同步到所有子 Key
public void saveHotGoods(Goods goods) {
    String baseKey = &quot;goods:hot:&quot; + goods.getId();
    // 写入10个子 Key
    for (int i = 0; i &lt; 10; i++) {
        String subKey = baseKey + &quot;:&quot; + i;
        redisTemplate.opsForValue().set(subKey, goods, 30, TimeUnit.MINUTES);
    }
}

// 读取：随机访问一个子 Key
public Goods getHotGoods(Long id) {
    String baseKey = &quot;goods:hot:&quot; + id;
    // 随机选一个子 Key
    int random = new Random().nextInt(10);
    String subKey = baseKey + &quot;:&quot; + random;
    return (Goods) redisTemplate.opsForValue().get(subKey);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h4 id="方案3-读写分离-主从复制"><a href="#方案3-读写分离-主从复制" class="header-anchor">#</a> 方案3：读写分离 + 主从复制</h4> <p>将热 Key 的读请求分流到从节点，主节点仅处理写请求：</p> <ul><li>配置：Redis 主从架构（1主N从），客户端读请求随机分发到从节点；</li> <li>优势：分散读压力，主节点专注写操作；</li> <li>注意：主从延迟需控制在 100ms 内，避免读旧数据。</li></ul> <h4 id="方案4-熔断限流-兜底保护"><a href="#方案4-熔断限流-兜底保护" class="header-anchor">#</a> 方案4：熔断限流（兜底保护）</h4> <p>通过 Sentinel/Hystrix 对热 Key 访问限流，避免压垮 Redis/DB：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// Sentinel 限流配置（热 Key 访问 QPS 上限 5000）
@SentinelResource(
    value = &quot;hotKey:goods&quot;,
    blockHandler = &quot;hotKeyBlockHandler&quot;
)
public Goods getHotGoods(Long id) {
    // 热 Key 查询逻辑...
}

// 限流兜底方法
public Goods hotKeyBlockHandler(Long id, BlockException e) {
    log.warn(&quot;热 Key 访问限流，id:{}&quot;, id);
    return new Goods().setName(&quot;系统繁忙，请稍后再试&quot;);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="方案5-预加载-永不过期"><a href="#方案5-预加载-永不过期" class="header-anchor">#</a> 方案5：预加载 + 永不过期</h4> <p>对热 Key 提前加载到 Redis，且不设置过期时间（逻辑永不过期）：</p> <ul><li>预加载：系统启动/低峰期主动加载热 Key 到 Redis；</li> <li>永不过期：后台异步线程定期更新热 Key 数据，避免过期；</li> <li>优势：避免热 Key 过期引发的缓存击穿。</li></ul> <h2 id="四、大-key-热-key-叠加问题-最高风险"><a href="#四、大-key-热-key-叠加问题-最高风险" class="header-anchor">#</a> 四、大 Key + 热 Key 叠加问题（最高风险）</h2> <p>如果一个 Key 既是大 Key 又是热 Key（如 20KB 的 String 热 Key，QPS 2000），会同时引发：</p> <ul><li>大 Key 问题：传输缓慢、内存倾斜；</li> <li>热 Key 问题：单节点 CPU/网卡满载。</li></ul> <h3 id="解决方案-组合策略"><a href="#解决方案-组合策略" class="header-anchor">#</a> 解决方案：组合策略</h3> <ol><li>先拆分大 Key（拆为多个小 Key）；</li> <li>对拆分后的小 Key 做本地缓存 + 哈希分散；</li> <li>限流兜底 + 主从读写分离；</li> <li>冷热分离：仅缓存热数据，冷数据迁移到其他存储。</li></ol> <h2 id="五、最佳实践总结"><a href="#五、最佳实践总结" class="header-anchor">#</a> 五、最佳实践总结</h2> <h3 id="_5-1-预防策略-核心"><a href="#_5-1-预防策略-核心" class="header-anchor">#</a> 5.1 预防策略（核心）</h3> <ul><li><strong>Key 设计规范</strong>：
<ul><li>单个 String Key ≤ 5KB，集合 Key 元素数 ≤ 500；</li> <li>避免用 Hash/List 存储全量数据，按业务维度拆分；</li></ul></li> <li><strong>监控告警</strong>：
<ul><li>大 Key：设置内存阈值告警（如 String ≥ 10KB 告警）；</li> <li>热 Key：设置 QPS 阈值告警（如单 Key QPS ≥ 1000 告警）；</li></ul></li> <li><strong>压测验证</strong>：上线前对大 Key/热 Key 做压测，验证拆分/分流效果。</li></ul> <h3 id="_5-2-治理策略"><a href="#_5-2-治理策略" class="header-anchor">#</a> 5.2 治理策略</h3> <ul><li>大 Key：优先拆分，其次压缩，最后冷热分离；</li> <li>热 Key：优先本地缓存，其次哈希分散，最后限流兜底；</li> <li>操作大 Key：用 <code>UNLINK</code>/<code>SCAN</code> 代替 <code>DEL</code>/<code>HGETALL</code>，避免阻塞；</li> <li>热 Key 数据：尽量简化（只缓存核心字段），降低传输成本。</li></ul> <h3 id="_5-3-应急策略"><a href="#_5-3-应急策略" class="header-anchor">#</a> 5.3 应急策略</h3> <ul><li>大 Key 阻塞：临时下线大 Key 所在节点，用 <code>UNLINK</code> 异步删除；</li> <li>热 Key 过载：临时开启本地缓存兜底，降低 Redis 访问频率；</li> <li>集群倾斜：手动迁移大 Key/热 Key 到负载较低的节点。</li></ul> <h2 id="六、核心区别与对比表"><a href="#六、核心区别与对比表" class="header-anchor">#</a> 六、核心区别与对比表</h2> <table><thead><tr><th>对比维度</th> <th>大 Key</th> <th>热 Key</th></tr></thead> <tbody><tr><td>核心问题</td> <td>数据体积大，操作/传输成本高</td> <td>访问频率高，单节点负载高</td></tr> <tr><td>识别难点</td> <td>需扫描全量 Key，耗时久</td> <td>需统计访问次数，需埋点/监控</td></tr> <tr><td>根治方案</td> <td>拆分 Key（垂直/水平）</td> <td>分散访问（本地缓存/哈希分片）</td></tr> <tr><td>临时方案</td> <td>压缩、异步删除</td> <td>限流、读写分离</td></tr> <tr><td>监控指标</td> <td>单 Key 内存、集合元素数</td> <td>单 Key QPS、节点 CPU/网卡使用率</td></tr> <tr><td>典型错误</td> <td>用 HGETALL 遍历大 Hash</td> <td>所有请求直接访问同一个热 Key</td></tr></tbody></table> <p>通过以上方案，可有效解决 Redis 大 Key 和热 Key 问题，核心是<strong>提前预防、精准识别、分层治理</strong>，避免单点问题扩散为集群级故障。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/tavio-zhang/blog/edit/master/docs/《Redis》笔记/6.Redis大Key与热Key.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/tags/?tag=Redis%E5%A4%A7Key%E4%B8%8E%E7%83%ADKey" title="标签">#Redis大Key与热Key</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2026/01/21, 19:29:14</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/ea330e/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Redis缓存设计</div></a> <a href="/pages/dd29df/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Redis限流</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/ea330e/" class="prev">Redis缓存设计</a></span> <span class="next"><a href="/pages/dd29df/">Redis限流</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/942d4b/"><div>
            订单超时取消
            <!----></div></a> <span class="date">01-21</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/87b303/"><div>
            双 Token 登录
            <!----></div></a> <span class="date">01-21</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/a3f3fd/"><div>
            长短链接跳转
            <!----></div></a> <span class="date">01-21</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:taviozhang@gmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/tavio-zhang" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.c6ba13aa.js" defer></script><script src="/assets/js/2.8d9f533d.js" defer></script><script src="/assets/js/73.c3ee5d2f.js" defer></script>
  </body>
</html>
