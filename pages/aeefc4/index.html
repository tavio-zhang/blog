<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis IO多路复用 | Tavio&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/logo.jpg">
    <meta name="description" content="后端技术博客,别让自己落后于技术的迭代">
    <meta name="keywords" content="鲜衣努码少年郎">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.3d594d45.css" as="style"><link rel="preload" href="/assets/js/app.c6ba13aa.js" as="script"><link rel="preload" href="/assets/js/2.8d9f533d.js" as="script"><link rel="preload" href="/assets/js/75.ed8e7990.js" as="script"><link rel="prefetch" href="/assets/js/10.3c6e6522.js"><link rel="prefetch" href="/assets/js/11.09bc43b4.js"><link rel="prefetch" href="/assets/js/12.a996a87c.js"><link rel="prefetch" href="/assets/js/13.b02d3acf.js"><link rel="prefetch" href="/assets/js/14.64fd6e84.js"><link rel="prefetch" href="/assets/js/15.089c02a9.js"><link rel="prefetch" href="/assets/js/16.8fa236f4.js"><link rel="prefetch" href="/assets/js/17.a1730b7a.js"><link rel="prefetch" href="/assets/js/18.1335a425.js"><link rel="prefetch" href="/assets/js/19.9293cbc0.js"><link rel="prefetch" href="/assets/js/20.5d0fd1df.js"><link rel="prefetch" href="/assets/js/21.4319dddd.js"><link rel="prefetch" href="/assets/js/22.2d6d1193.js"><link rel="prefetch" href="/assets/js/23.f154e330.js"><link rel="prefetch" href="/assets/js/24.66ba0133.js"><link rel="prefetch" href="/assets/js/25.5979047a.js"><link rel="prefetch" href="/assets/js/26.04889c33.js"><link rel="prefetch" href="/assets/js/27.337928e8.js"><link rel="prefetch" href="/assets/js/28.665066df.js"><link rel="prefetch" href="/assets/js/29.5aa838b8.js"><link rel="prefetch" href="/assets/js/3.1aac6e80.js"><link rel="prefetch" href="/assets/js/30.a8923cf6.js"><link rel="prefetch" href="/assets/js/31.a290d548.js"><link rel="prefetch" href="/assets/js/32.cb2b7fdd.js"><link rel="prefetch" href="/assets/js/33.3286dca2.js"><link rel="prefetch" href="/assets/js/34.9aebb473.js"><link rel="prefetch" href="/assets/js/35.5777ff14.js"><link rel="prefetch" href="/assets/js/36.5c29dd6e.js"><link rel="prefetch" href="/assets/js/37.cbf6fde7.js"><link rel="prefetch" href="/assets/js/38.2a1572ab.js"><link rel="prefetch" href="/assets/js/39.000aacf6.js"><link rel="prefetch" href="/assets/js/4.16da1e3f.js"><link rel="prefetch" href="/assets/js/40.8fbbcfa8.js"><link rel="prefetch" href="/assets/js/41.1b995757.js"><link rel="prefetch" href="/assets/js/42.575e5238.js"><link rel="prefetch" href="/assets/js/43.0a4cb54f.js"><link rel="prefetch" href="/assets/js/44.8d3b4283.js"><link rel="prefetch" href="/assets/js/45.ae001bba.js"><link rel="prefetch" href="/assets/js/46.fc29dcb1.js"><link rel="prefetch" href="/assets/js/47.628ee1ef.js"><link rel="prefetch" href="/assets/js/48.7d4f854a.js"><link rel="prefetch" href="/assets/js/49.e848253a.js"><link rel="prefetch" href="/assets/js/5.20e9c2cf.js"><link rel="prefetch" href="/assets/js/50.045225be.js"><link rel="prefetch" href="/assets/js/51.d05a2035.js"><link rel="prefetch" href="/assets/js/52.35a2519d.js"><link rel="prefetch" href="/assets/js/53.ca8d5bc8.js"><link rel="prefetch" href="/assets/js/54.eb93e6ae.js"><link rel="prefetch" href="/assets/js/55.27ff3cca.js"><link rel="prefetch" href="/assets/js/56.4a98635a.js"><link rel="prefetch" href="/assets/js/57.db243c6d.js"><link rel="prefetch" href="/assets/js/58.650ffef2.js"><link rel="prefetch" href="/assets/js/59.9af578d0.js"><link rel="prefetch" href="/assets/js/6.cf5ce51d.js"><link rel="prefetch" href="/assets/js/60.800afb74.js"><link rel="prefetch" href="/assets/js/61.59b23cca.js"><link rel="prefetch" href="/assets/js/62.35998712.js"><link rel="prefetch" href="/assets/js/63.824df362.js"><link rel="prefetch" href="/assets/js/64.2f51e9d0.js"><link rel="prefetch" href="/assets/js/65.926e2499.js"><link rel="prefetch" href="/assets/js/66.2af85da2.js"><link rel="prefetch" href="/assets/js/67.bbd8d4b3.js"><link rel="prefetch" href="/assets/js/68.163c774f.js"><link rel="prefetch" href="/assets/js/69.deed8d29.js"><link rel="prefetch" href="/assets/js/7.92776da2.js"><link rel="prefetch" href="/assets/js/70.d6a81068.js"><link rel="prefetch" href="/assets/js/71.9adb8c50.js"><link rel="prefetch" href="/assets/js/72.9ba26fc5.js"><link rel="prefetch" href="/assets/js/73.c3ee5d2f.js"><link rel="prefetch" href="/assets/js/74.af7973c7.js"><link rel="prefetch" href="/assets/js/76.668519a5.js"><link rel="prefetch" href="/assets/js/77.d6cb2694.js"><link rel="prefetch" href="/assets/js/78.494cff39.js"><link rel="prefetch" href="/assets/js/79.486534af.js"><link rel="prefetch" href="/assets/js/8.d7fc67a9.js"><link rel="prefetch" href="/assets/js/80.c60f84eb.js"><link rel="prefetch" href="/assets/js/81.80ab610c.js"><link rel="prefetch" href="/assets/js/82.38a483d0.js"><link rel="prefetch" href="/assets/js/83.72b7d6a4.js"><link rel="prefetch" href="/assets/js/84.f5a347be.js"><link rel="prefetch" href="/assets/js/85.f3b7b32b.js"><link rel="prefetch" href="/assets/js/86.1d47bd30.js"><link rel="prefetch" href="/assets/js/87.2361eddb.js"><link rel="prefetch" href="/assets/js/88.aef9e475.js"><link rel="prefetch" href="/assets/js/89.0a95e3be.js"><link rel="prefetch" href="/assets/js/9.f6c9df9a.js"><link rel="prefetch" href="/assets/js/90.ddf7b632.js"><link rel="prefetch" href="/assets/js/91.2a96bacf.js"><link rel="prefetch" href="/assets/js/92.f61fc5ec.js"><link rel="prefetch" href="/assets/js/93.40a17799.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3d594d45.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="Tavio's blog" class="logo"> <span class="site-name can-hide">Tavio's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/node/jvm/" class="nav-link">JVM底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/thread/" class="nav-link">邪恶多线程</a></li><li class="dropdown-item"><!----> <a href="/node/mybatis/" class="nav-link">MyBatis底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/spring/" class="nav-link">Spring底层原理</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/db/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/mysql/" class="nav-link">MySQL的优化之路</a></li><li class="dropdown-item"><!----> <a href="/note/clickhouse/" class="nav-link">ClickHouse的高性能</a></li><li class="dropdown-item"><!----> <a href="/note/redis/" class="nav-link">Redis的快速查询</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/middleware/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/rabbitmq/" class="nav-link">RabbitMQ的生产</a></li><li class="dropdown-item"><!----> <a href="/note/kafka/" class="nav-link">Kafka的高吞吐量</a></li><li class="dropdown-item"><!----> <a href="/note/es/" class="nav-link">ES的入门到入坑</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践" class="dropdown-title"><a href="/practice/" class="link-title">实践</a> <span class="title" style="display:none;">实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/284351/" class="nav-link">MySQL自增ID主键空洞</a></li><li class="dropdown-item"><!----> <a href="/pages/8f1df0/" class="nav-link">前端实现长整型排序</a></li><li class="dropdown-item"><!----> <a href="/pages/13fcc3/" class="nav-link">MySQL无感换表</a></li><li class="dropdown-item"><!----> <a href="/pages/69e163/" class="nav-link">Redis延时双删</a></li><li class="dropdown-item"><!----> <a href="/pages/f43494/" class="nav-link">高并发秒杀优惠卷</a></li><li class="dropdown-item"><!----> <a href="/pages/ab9a49/" class="nav-link">AOP无侵入式告警</a></li><li class="dropdown-item"><!----> <a href="/pages/a3f3fd/" class="nav-link">长短链接跳转</a></li><li class="dropdown-item"><!----> <a href="/pages/942d4b/" class="nav-link">订单超时取消</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/tavio-zhang/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.jpg"> <div class="blogger-info"><h3>Tavio Zhang</h3> <span>努力学习的小码喽</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/node/jvm/" class="nav-link">JVM底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/thread/" class="nav-link">邪恶多线程</a></li><li class="dropdown-item"><!----> <a href="/node/mybatis/" class="nav-link">MyBatis底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/spring/" class="nav-link">Spring底层原理</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/db/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/mysql/" class="nav-link">MySQL的优化之路</a></li><li class="dropdown-item"><!----> <a href="/note/clickhouse/" class="nav-link">ClickHouse的高性能</a></li><li class="dropdown-item"><!----> <a href="/note/redis/" class="nav-link">Redis的快速查询</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/middleware/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/rabbitmq/" class="nav-link">RabbitMQ的生产</a></li><li class="dropdown-item"><!----> <a href="/note/kafka/" class="nav-link">Kafka的高吞吐量</a></li><li class="dropdown-item"><!----> <a href="/note/es/" class="nav-link">ES的入门到入坑</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践" class="dropdown-title"><a href="/practice/" class="link-title">实践</a> <span class="title" style="display:none;">实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/284351/" class="nav-link">MySQL自增ID主键空洞</a></li><li class="dropdown-item"><!----> <a href="/pages/8f1df0/" class="nav-link">前端实现长整型排序</a></li><li class="dropdown-item"><!----> <a href="/pages/13fcc3/" class="nav-link">MySQL无感换表</a></li><li class="dropdown-item"><!----> <a href="/pages/69e163/" class="nav-link">Redis延时双删</a></li><li class="dropdown-item"><!----> <a href="/pages/f43494/" class="nav-link">高并发秒杀优惠卷</a></li><li class="dropdown-item"><!----> <a href="/pages/ab9a49/" class="nav-link">AOP无侵入式告警</a></li><li class="dropdown-item"><!----> <a href="/pages/a3f3fd/" class="nav-link">长短链接跳转</a></li><li class="dropdown-item"><!----> <a href="/pages/942d4b/" class="nav-link">订单超时取消</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/tavio-zhang/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/eada73/" class="sidebar-link">Redis核心数据结构</a></li><li><a href="/pages/d81738/" class="sidebar-link">Redis持久化机制</a></li><li><a href="/pages/797c36/" class="sidebar-link">Redis高可用架构</a></li><li><a href="/pages/88227a/" class="sidebar-link">Redis分布式锁</a></li><li><a href="/pages/ea330e/" class="sidebar-link">Redis缓存设计</a></li><li><a href="/pages/d2662c/" class="sidebar-link">Redis大Key与热Key</a></li><li><a href="/pages/dd29df/" class="sidebar-link">Redis限流</a></li><li><a href="/pages/aeefc4/" aria-current="page" class="active sidebar-link">Redis IO多路复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/aeefc4/#一、数据传输的基石-缓冲区机制" class="sidebar-link">一、数据传输的基石：缓冲区机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_1-1-内核缓冲区-操作系统的-io-中转站" class="sidebar-link">1.1 内核缓冲区：操作系统的 IO 中转站</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#核心特性" class="sidebar-link">核心特性</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#核心作用" class="sidebar-link">核心作用</a></li><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_1-2-应用缓冲区-redis-自主管理的用户态内存" class="sidebar-link">1.2 应用缓冲区：Redis 自主管理的用户态内存</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#分类与设计" class="sidebar-link">分类与设计</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#核心作用-2" class="sidebar-link">核心作用</a></li><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_1-3-缓冲区交互-数据从客户端到-redis-的完整流转" class="sidebar-link">1.3 缓冲区交互：数据从客户端到 Redis 的完整流转</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#阶段-1-命令接收-读数据" class="sidebar-link">阶段 1：命令接收（读数据）</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#阶段-2-响应发送-写数据" class="sidebar-link">阶段 2：响应发送（写数据）</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/aeefc4/#二、事件驱动模型-redis-高并发的底层架构" class="sidebar-link">二、事件驱动模型：Redis 高并发的底层架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_2-1-事件的两种核心类型" class="sidebar-link">2.1 事件的两种核心类型</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#_1-文件事件-file-event" class="sidebar-link">（1）文件事件（File Event）</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#_2-时间事件-time-event" class="sidebar-link">（2）时间事件（Time Event）</a></li><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_2-2-reactor-模式的核心组件" class="sidebar-link">2.2 Reactor 模式的核心组件</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#_1-事件循环-aeeventloop" class="sidebar-link">（1）事件循环（aeEventLoop）</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#_2-事件源-aefileevent-aetimeevent" class="sidebar-link">（2）事件源（aeFileEvent / aeTimeEvent）</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#_3-事件处理器-回调函数" class="sidebar-link">（3）事件处理器（回调函数）</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/aeefc4/#三、文件事件-网络-io-的高效处理机制" class="sidebar-link">三、文件事件：网络 IO 的高效处理机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_3-1-io-多路复用-单线程处理多连接的关键" class="sidebar-link">3.1 IO 多路复用：单线程处理多连接的关键</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#_3-1-1-三种-io-模型的对比" class="sidebar-link">3.1.1 三种 IO 模型的对比</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#_3-1-2-redis-支持的-io-多路复用技术" class="sidebar-link">3.1.2 Redis 支持的 IO 多路复用技术</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#_3-1-3-epoll-为何是-linux-下的首选" class="sidebar-link">3.1.3 epoll 为何是 Linux 下的首选？</a></li><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_3-2-文件事件的完整处理流程-以客户端请求为例" class="sidebar-link">3.2 文件事件的完整处理流程（以客户端请求为例）</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#步骤-1-监听连接事件-服务器启动阶段" class="sidebar-link">步骤 1：监听连接事件（服务器启动阶段）</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#步骤-2-建立客户端连接" class="sidebar-link">步骤 2：建立客户端连接</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#步骤-3-读取并解析命令" class="sidebar-link">步骤 3：读取并解析命令</a></li><li class="sidebar-sub-header level4"><a href="/pages/aeefc4/#步骤-4-发送响应结果" class="sidebar-link">步骤 4：发送响应结果</a></li><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_3-3-事件优先级与优化策略" class="sidebar-link">3.3 事件优先级与优化策略</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/aeefc4/#四、时间事件-后台任务的调度机制" class="sidebar-link">四、时间事件：后台任务的调度机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_4-1-时间事件的两种类型" class="sidebar-link">4.1 时间事件的两种类型</a></li><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_4-2-核心周期性任务-servercron-函数" class="sidebar-link">4.2 核心周期性任务：serverCron 函数</a></li><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#_4-3-时间事件的实现逻辑" class="sidebar-link">4.3 时间事件的实现逻辑</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/aeefc4/#五、事件循环-redis-主线程的运行逻辑" class="sidebar-link">五、事件循环：Redis 主线程的运行逻辑</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/aeefc4/#详细步骤解析" class="sidebar-link">详细步骤解析</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/aeefc4/#总结-redis-高性能的设计哲学" class="sidebar-link">总结：Redis 高性能的设计哲学</a></li></ul></li><li><a href="/pages/347bce/" class="sidebar-link">Redis过期删除策略</a></li><li><a href="/pages/390684/" class="sidebar-link">Redis Bitmap</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/note/redis/#《Redis》笔记" data-v-06225672>《Redis》笔记</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/tavio-zhang" target="_blank" title="作者" class="beLink" data-v-06225672>Tavio</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-06-01</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Redis IO多路复用<!----></h1>  <div class="theme-vdoing-content content__default"><p>Redis 作为高性能键值数据库，以单线程架构支撑数万级 QPS 的高并发场景，其核心奥秘在于<strong>事件驱动模型</strong>与<strong>IO 多路复用技术</strong>的深度协同。</p> <h2 id="一、数据传输的基石-缓冲区机制"><a href="#一、数据传输的基石-缓冲区机制" class="header-anchor">#</a> 一、数据传输的基石：缓冲区机制</h2> <p>在 Redis 与客户端的网络交互中，数据并非直接在应用程序与网卡间传输，而是通过<strong>内核缓冲区</strong>（内核态）与<strong>应用缓冲区</strong>（用户态）的协作完成。</p> <h3 id="_1-1-内核缓冲区-操作系统的-io-中转站"><a href="#_1-1-内核缓冲区-操作系统的-io-中转站" class="header-anchor">#</a> 1.1 内核缓冲区：操作系统的 IO 中转站</h3> <p>内核缓冲区是操作系统为每个网络套接字（Socket）分配的内核态内存区域，是数据在“网卡与应用程序”之间的必经之路。</p> <h4 id="核心特性"><a href="#核心特性" class="header-anchor">#</a> 核心特性</h4> <ul><li><strong>归属与访问</strong>：属于操作系统内核管理，用户进程（如 Redis）无法直接读写，必须通过 <code>read()</code>、<code>write()</code> 等系统调用间接访问（需切换至内核态）。</li> <li><strong>大小控制</strong>：由系统内核参数配置（如 Linux 的 <code>net.core.rmem_default</code> 控制读缓冲区默认大小，<code>net.core.wmem_default</code> 控制写缓冲区），通常为几 KB 到几十 KB。</li> <li><strong>双缓冲区设计</strong>：每个 Socket 包含读缓冲区（recv buffer）和写缓冲区（send buffer），分别负责接收和发送数据。</li></ul> <h4 id="核心作用"><a href="#核心作用" class="header-anchor">#</a> 核心作用</h4> <ol><li><p><strong>解耦异步传输</strong>：<br>
客户端发送的数据先由网卡接收并拷贝至内核读缓冲区，即使 Redis 未及时处理，数据也不会丢失；Redis 发送响应时，只需将数据写入内核写缓冲区，内核会异步将数据发送至网卡，无需 Redis 等待。</p></li> <li><p><strong>优化系统调用</strong>：<br>
内核缓冲区会暂存小批量数据（如 TCP 的 Nagle 算法合并小数据包），减少应用程序频繁调用 <code>read()</code>/<code>write()</code> 的开销（每次系统调用需切换内核态，成本较高）。</p></li> <li><p><strong>平衡硬件速度差异</strong>：<br>
网卡数据传输速度（GB 级/秒）远高于用户进程处理速度（MB 级/秒），缓冲区可暂存突发数据，避免“高速设备等待低速设备”的性能浪费。</p></li></ol> <h3 id="_1-2-应用缓冲区-redis-自主管理的用户态内存"><a href="#_1-2-应用缓冲区-redis-自主管理的用户态内存" class="header-anchor">#</a> 1.2 应用缓冲区：Redis 自主管理的用户态内存</h3> <p>应用缓冲区是 Redis 在用户态内存中为每个客户端连接分配的内存区域，由 Redis 直接管理，无需内核介入即可读写。</p> <h4 id="分类与设计"><a href="#分类与设计" class="header-anchor">#</a> 分类与设计</h4> <p>Redis 为每个 <code>redisClient</code> 结构体维护两类应用缓冲区：</p> <table><thead><tr><th>缓冲区类型</th> <th>存储内容</th> <th>数据结构</th> <th>大小特性</th></tr></thead> <tbody><tr><td>输入缓冲区（Input Buffer）</td> <td>客户端发送的命令数据（如 <code>SET key value</code>）</td> <td><code>querybuf</code> 字段（动态字符串）</td> <td>初始 16KB，动态扩容，最大不超过 1GB（可通过 <code>client-query-buffer-limit</code> 配置）</td></tr> <tr><td>输出缓冲区（Output Buffer）</td> <td>待发送给客户端的响应数据（如 <code>OK</code>、value 值）</td> <td>由 <code>buf</code>（固定 16KB 小缓冲区）和 <code>reply</code>（动态链表/字符串）组成</td> <td>小响应存 <code>buf</code>，大响应（如批量查询结果）存 <code>reply</code>，可配置上限避免内存溢出</td></tr></tbody></table> <h4 id="核心作用-2"><a href="#核心作用-2" class="header-anchor">#</a> 核心作用</h4> <ol><li><p><strong>支撑命令解析</strong>：<br>
输入缓冲区暂存完整的命令数据，Redis 可基于缓冲区逐字节解析 Redis 协议，避免“边读边解析”的复杂逻辑。</p></li> <li><p><strong>缓存响应结果</strong>：<br>
输出缓冲区暂存命令执行结果，等待内核写缓冲区空闲时批量发送，减少系统调用次数（例如，一次发送多个小响应，替代多次单独发送）。</p></li> <li><p><strong>避免阻塞单线程</strong>：<br>
Redis 单线程处理命令时，输出缓冲区可暂存响应数据，无需等待客户端接收完成即可处理下一个命令，提升并发效率。</p></li></ol> <h3 id="_1-3-缓冲区交互-数据从客户端到-redis-的完整流转"><a href="#_1-3-缓冲区交互-数据从客户端到-redis-的完整流转" class="header-anchor">#</a> 1.3 缓冲区交互：数据从客户端到 Redis 的完整流转</h3> <p>以“客户端发送 <code>SET key value</code> 命令并接收 <code>OK</code> 响应”为例，数据在缓冲区之间的流转流程如下：</p> <h4 id="阶段-1-命令接收-读数据"><a href="#阶段-1-命令接收-读数据" class="header-anchor">#</a> 阶段 1：命令接收（读数据）</h4> <ol><li>客户端调用 <code>send()</code> 发送命令，数据从“客户端应用缓冲区”→“客户端内核写缓冲区”→ 网卡。</li> <li>Redis 服务器网卡接收数据，内核将数据从网卡拷贝至“Redis 内核读缓冲区”。</li> <li>IO 多路复用器（如 epoll）检测到该 Socket 读事件就绪，通知 Redis 主线程。</li> <li>Redis 调用 <code>read()</code> 系统调用，将数据从“内核读缓冲区”拷贝至“Redis 输入缓冲区”。</li> <li>Redis 解析输入缓冲区中的命令，执行 <code>SET</code> 操作，将响应 <code>OK</code> 写入“输出缓冲区”。</li></ol> <h4 id="阶段-2-响应发送-写数据"><a href="#阶段-2-响应发送-写数据" class="header-anchor">#</a> 阶段 2：响应发送（写数据）</h4> <ol><li>Redis 向 IO 多路复用器注册该客户端 Socket 的写事件。</li> <li>内核写缓冲区空闲时（有空间存储新数据），IO 多路复用器通知写事件就绪。</li> <li>Redis 调用 <code>write()</code> 系统调用，将数据从“输出缓冲区”拷贝至“内核写缓冲区”。</li> <li>内核异步将数据从“内核写缓冲区”拷贝至网卡，发送给客户端。</li> <li>若响应数据未完全发送（如数据过大），保留未发送部分至下次写事件触发；若发送完成，取消写事件注册并清空输出缓冲区。</li></ol> <p><strong>核心要点</strong>：数据传输需经过两次关键拷贝（内核缓冲区 ↔ 应用缓冲区），IO 多路复用技术仅监听内核缓冲区的就绪状态，避免 Redis 对未就绪 Socket 进行无效系统调用。</p> <h2 id="二、事件驱动模型-redis-高并发的底层架构"><a href="#二、事件驱动模型-redis-高并发的底层架构" class="header-anchor">#</a> 二、事件驱动模型：Redis 高并发的底层架构</h2> <p>Redis 是典型的<strong>事件驱动型程序</strong>，其核心遵循 <strong>Reactor 模式</strong>（反应器模式）：由一个主线程通过 IO 多路复用机制监听多个事件源，当事件就绪时触发对应回调函数处理。这种设计既避免了多线程上下文切换的开销，又保证了单线程下的有序执行。</p> <h3 id="_2-1-事件的两种核心类型"><a href="#_2-1-事件的两种核心类型" class="header-anchor">#</a> 2.1 事件的两种核心类型</h3> <p>Redis 将所有待处理事件分为两类，统一由事件循环调度：</p> <h4 id="_1-文件事件-file-event"><a href="#_1-文件事件-file-event" class="header-anchor">#</a> （1）文件事件（File Event）</h4> <p>与网络 IO 相关的事件，是处理客户端请求的核心，包括：</p> <ul><li>连接事件：客户端发起连接（<code>accept</code>）、断开连接。</li> <li>读写事件：客户端发送命令（读）、Redis 发送响应（写）。</li></ul> <h4 id="_2-时间事件-time-event"><a href="#_2-时间事件-time-event" class="header-anchor">#</a> （2）时间事件（Time Event）</h4> <p>与定时/周期性任务相关的事件，用于维护服务器状态，包括：</p> <ul><li>定时事件：仅执行一次（如 <code>UNLINK</code> 命令异步删除大键）。</li> <li>周期性事件：重复执行（如后台过期键清理、持久化检查）。</li></ul> <h3 id="_2-2-reactor-模式的核心组件"><a href="#_2-2-reactor-模式的核心组件" class="header-anchor">#</a> 2.2 Reactor 模式的核心组件</h3> <p>Redis 通过 <code>ae.c</code> 模块实现 Reactor 模式，核心组件如下：</p> <h4 id="_1-事件循环-aeeventloop"><a href="#_1-事件循环-aeeventloop" class="header-anchor">#</a> （1）事件循环（aeEventLoop）</h4> <p>Reactor 模式的“大脑”，负责管理所有注册的事件、监听事件就绪状态、触发回调函数。其核心结构定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>typedef struct aeEventLoop {
    int maxfd;                     // 已注册事件的最大文件描述符（FD）
    int setsize;                   // 事件集合大小（支持的最大 FD 数量）
    long long timeEventNextId;     // 下一个时间事件的唯一 ID
    aeFileEvent *events;           // 注册的文件事件（FD 到事件的映射表）
    aeFiredEvent *fired;           // 已触发的事件列表（IO 多路复用返回的就绪事件）
    aeTimeEvent *timeEventHead;    // 时间事件链表（无序存储）
    int stop;                      // 事件循环停止标志（0：运行，1：停止）
    void *apidata;                 // 多路复用技术的私有数据（如 epoll 的句柄）
    aeBeforeSleepProc *beforesleep;// 事件循环阻塞前的回调函数（如 serverCron 预热）
} aeEventLoop;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="_2-事件源-aefileevent-aetimeevent"><a href="#_2-事件源-aefileevent-aetimeevent" class="header-anchor">#</a> （2）事件源（aeFileEvent / aeTimeEvent）</h4> <ul><li><strong>文件事件（aeFileEvent）</strong>：绑定特定 FD 和事件类型（读/写），包含事件就绪时的回调函数。<div class="language- line-numbers-mode"><pre class="language-text"><code>typedef struct aeFileEvent {
    int mask;                     // 事件类型掩码（AE_READABLE / AE_WRITABLE）
    aeFileProc *rfileProc;        // 读事件回调函数（如 readQueryFromClient）
    aeFileProc *wfileProc;        // 写事件回调函数（如 sendReplyToClient）
    void *clientData;             // 私有数据（如 redisClient 指针）
} aeFileEvent;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><strong>时间事件（aeTimeEvent）</strong>：包含事件执行时间、回调函数、是否周期性执行等信息。</li></ul> <h4 id="_3-事件处理器-回调函数"><a href="#_3-事件处理器-回调函数" class="header-anchor">#</a> （3）事件处理器（回调函数）</h4> <p>针对不同事件的处理逻辑，例如：</p> <ul><li><code>acceptTcpHandler</code>：处理新客户端连接。</li> <li><code>readQueryFromClient</code>：从客户端读取并解析命令。</li> <li><code>sendReplyToClient</code>：向客户端发送响应。</li> <li><code>serverCron</code>：执行周期性后台任务。</li></ul> <h2 id="三、文件事件-网络-io-的高效处理机制"><a href="#三、文件事件-网络-io-的高效处理机制" class="header-anchor">#</a> 三、文件事件：网络 IO 的高效处理机制</h2> <p>文件事件是 Redis 处理网络请求的核心，本质是对 Socket 操作的抽象。通过 IO 多路复用技术，Redis 单线程可同时监听数千个客户端连接的读写事件，实现高并发处理。</p> <h3 id="_3-1-io-多路复用-单线程处理多连接的关键"><a href="#_3-1-io-多路复用-单线程处理多连接的关键" class="header-anchor">#</a> 3.1 IO 多路复用：单线程处理多连接的关键</h3> <p>IO 多路复用的核心思想是：<strong>一个线程通过一次系统调用（如 <code>epoll_wait</code>）监听多个 FD，当某个 FD 就绪（可读/可写）时，系统调用返回并通知该 FD 就绪，再触发对应处理逻辑</strong>。</p> <h4 id="_3-1-1-三种-io-模型的对比"><a href="#_3-1-1-三种-io-模型的对比" class="header-anchor">#</a> 3.1.1 三种 IO 模型的对比</h4> <table><thead><tr><th>IO 模型</th> <th>核心逻辑</th> <th>阻塞点</th> <th>并发能力</th> <th>典型场景</th></tr></thead> <tbody><tr><td>阻塞 IO（BIO）</td> <td>调用 <code>read()</code> 后阻塞至数据拷贝完成</td> <td>等待数据 + 数据拷贝</td> <td>极低</td> <td>简单本地文件读写</td></tr> <tr><td>非阻塞 IO（NIO）</td> <td>调用 <code>read()</code> 后立即返回，无数据则轮询重试</td> <td>仅数据拷贝</td> <td>一般</td> <td>低延迟、小数据场景</td></tr> <tr><td>IO 多路复用</td> <td>内核监听多 FD，仅通知就绪事件</td> <td>无事件时阻塞在监听阶段</td> <td>极高</td> <td>高并发网络服务（Redis）</td></tr></tbody></table> <p><strong>为什么 Redis 不选非阻塞 IO？</strong><br>
非阻塞 IO 需要应用程序主动轮询所有 FD 是否就绪（空轮询），即使无事件也会消耗 CPU；而 IO 多路复用由内核监听，无事件时线程阻塞，几乎不消耗 CPU。</p> <h4 id="_3-1-2-redis-支持的-io-多路复用技术"><a href="#_3-1-2-redis-支持的-io-多路复用技术" class="header-anchor">#</a> 3.1.2 Redis 支持的 IO 多路复用技术</h4> <p>Redis 为跨平台适配，实现了多种 IO 多路复用方案，通过统一接口封装（优先选择高效方案）：</p> <table><thead><tr><th>技术</th> <th>适用系统</th> <th>核心优势</th> <th>Redis 优先级</th></tr></thead> <tbody><tr><td>epoll</td> <td>Linux</td> <td>事件驱动，支持水平触发（LT）/边缘触发（ET），FD 无上限，事件查询效率 O(1)</td> <td>最高</td></tr> <tr><td>kqueue</td> <td>Mac OS/FreeBSD</td> <td>类似 epoll，支持 ET 模式，FD 无上限，适合高并发</td> <td>次之</td></tr> <tr><td>select</td> <td>所有系统</td> <td>兼容性好，但 FD 上限 1024，事件查询 O(n)（遍历所有 FD），效率低</td> <td>最低</td></tr> <tr><td>poll</td> <td>大多数系统</td> <td>突破 FD 上限，但仍需遍历所有 FD，效率低于 epoll/kqueue</td> <td>较低</td></tr></tbody></table> <h4 id="_3-1-3-epoll-为何是-linux-下的首选"><a href="#_3-1-3-epoll-为何是-linux-下的首选" class="header-anchor">#</a> 3.1.3 epoll 为何是 Linux 下的首选？</h4> <ol><li><p><strong>无 FD 上限</strong>：<br> <code>select</code> 受限于 <code>FD_SETSIZE</code>（默认 1024），而 epoll 支持的 FD 数量由系统内存决定（通常可达百万级），适合 Redis 高并发场景。</p></li> <li><p><strong>事件通知机制更高效</strong>：</p> <ul><li><code>select</code> 每次调用需将 FD 集合从用户态拷贝到内核态，并遍历所有 FD 检查就绪状态（O(n) 复杂度）。</li> <li>epoll 用红黑树存储 FD，注册时拷贝一次，后续无需重复拷贝；事件就绪时通过回调直接通知（O(1) 复杂度）。</li></ul></li> <li><p><strong>灵活的触发模式</strong>：</p> <ul><li>水平触发（LT，Redis 默认）：FD 有未读数据时持续通知，实现简单，避免漏处理。</li> <li>边缘触发（ET）：仅在 FD 状态变化时通知一次，需一次性读完所有数据，效率更高但实现复杂（Redis 为稳定性选择 LT）。</li></ul></li></ol> <h3 id="_3-2-文件事件的完整处理流程-以客户端请求为例"><a href="#_3-2-文件事件的完整处理流程-以客户端请求为例" class="header-anchor">#</a> 3.2 文件事件的完整处理流程（以客户端请求为例）</h3> <p>以“客户端发送 <code>SET key value</code> 命令”为例，解析文件事件从连接建立到响应发送的全生命周期：</p> <h4 id="步骤-1-监听连接事件-服务器启动阶段"><a href="#步骤-1-监听连接事件-服务器启动阶段" class="header-anchor">#</a> 步骤 1：监听连接事件（服务器启动阶段）</h4> <ul><li>Redis 启动时创建监听套接字（绑定 6379 端口），向 epoll 注册<strong>读事件</strong>（<code>AE_READABLE</code>），回调函数为 <code>acceptTcpHandler</code>（负责处理新连接）。</li></ul> <h4 id="步骤-2-建立客户端连接"><a href="#步骤-2-建立客户端连接" class="header-anchor">#</a> 步骤 2：建立客户端连接</h4> <ul><li>客户端发起 TCP 三次握手，连接建立后，内核将监听 FD 标记为“读就绪”，epoll 将其加入“已触发事件列表”。</li> <li>Redis 主线程调用 <code>acceptTcpHandler</code>，通过 <code>accept()</code> 系统调用获取客户端 Socket，并创建 <code>redisClient</code> 对象（初始化输入/输出缓冲区）。</li> <li>向 epoll 注册该客户端 FD 的<strong>读事件</strong>，回调函数为 <code>readQueryFromClient</code>（负责读取命令）。</li></ul> <h4 id="步骤-3-读取并解析命令"><a href="#步骤-3-读取并解析命令" class="header-anchor">#</a> 步骤 3：读取并解析命令</h4> <ul><li>客户端发送 <code>SET key value</code> 命令，内核将数据写入客户端 FD 的读缓冲区，epoll 检测到“读就绪”并通知 Redis。</li> <li>Redis 调用 <code>readQueryFromClient</code>，通过 <code>read()</code> 将数据从内核读缓冲区拷贝至 Redis 输入缓冲区。</li> <li>解析输入缓冲区中的 Redis 协议，提取命令参数（<code>SET</code>、<code>key</code>、<code>value</code>），执行命令并将结果（<code>OK</code>）写入输出缓冲区。</li></ul> <h4 id="步骤-4-发送响应结果"><a href="#步骤-4-发送响应结果" class="header-anchor">#</a> 步骤 4：发送响应结果</h4> <ul><li>Redis 向 epoll 注册该客户端 FD 的<strong>写事件</strong>（<code>AE_WRITABLE</code>），回调函数为 <code>sendReplyToClient</code>（负责发送响应）。</li> <li>内核写缓冲区空闲时（有空间存储数据），epoll 通知“写就绪”。</li> <li>Redis 调用 <code>sendReplyToClient</code>，通过 <code>write()</code> 将输出缓冲区中的 <code>OK</code> 拷贝至内核写缓冲区，内核异步发送至客户端。</li> <li>若响应未完全发送（如数据过大），保留未发送部分；若发送完成，取消写事件注册（避免无数据时的空触发）。</li></ul> <h3 id="_3-3-事件优先级与优化策略"><a href="#_3-3-事件优先级与优化策略" class="header-anchor">#</a> 3.3 事件优先级与优化策略</h3> <ul><li><p><strong>读事件优先于写事件</strong>：<br>
客户端请求（读）需及时处理，否则可能导致客户端超时；而响应（写）可短暂延迟，因此事件循环中先处理读事件，再处理写事件。</p></li> <li><p><strong>按需注册写事件</strong>：<br>
仅当输出缓冲区有数据需发送时，才向 epoll 注册写事件；发送完成后立即取消注册，避免套接字可写但无数据的“空轮询”（减少系统调用开销）。</p></li></ul> <h2 id="四、时间事件-后台任务的调度机制"><a href="#四、时间事件-后台任务的调度机制" class="header-anchor">#</a> 四、时间事件：后台任务的调度机制</h2> <p>时间事件用于处理定时任务和周期性任务，是 Redis 维护服务器状态的核心机制，与文件事件共同构成事件循环的两大支柱。</p> <h3 id="_4-1-时间事件的两种类型"><a href="#_4-1-时间事件的两种类型" class="header-anchor">#</a> 4.1 时间事件的两种类型</h3> <ul><li><strong>定时事件</strong>：仅执行一次，如 <code>UNLINK</code> 命令触发的大键异步删除（避免阻塞主线程）、临时任务调度。</li> <li><strong>周期性事件</strong>：按固定间隔重复执行，核心是 <code>serverCron</code> 函数（Redis 最关键的后台任务入口）。</li></ul> <h3 id="_4-2-核心周期性任务-servercron-函数"><a href="#_4-2-核心周期性任务-servercron-函数" class="header-anchor">#</a> 4.2 核心周期性任务：serverCron 函数</h3> <p><code>serverCron</code> 由配置项 <code>hz</code> 控制执行频率（默认每秒 10 次，可通过 <code>hz</code> 配置调整，范围 1-500），主要负责以下工作：</p> <ol><li><p><strong>服务器状态维护</strong>：<br>
更新当前时间、计算内存使用量、统计 CPU 利用率、更新 LRU 时钟（用于键淘汰）。</p></li> <li><p><strong>过期键清理</strong>：<br>
遍历过期字典，随机抽取部分键检查是否过期并删除（结合惰性删除：访问键时才检查过期），平衡内存占用与性能。</p></li> <li><p><strong>持久化管理</strong>：<br>
检查是否满足 RDB 快照触发条件（如 <code>save 60 10000</code>：60 秒内有 10000 次写操作）或 AOF 重写条件（如当前 AOF 文件大小超过上次重写后 100%）。</p></li> <li><p><strong>客户端管理</strong>：<br>
关闭长时间空闲（超过 <code>timeout</code> 配置）的客户端连接，释放资源；清理输出缓冲区溢出的客户端（避免内存泄漏）。</p></li> <li><p><strong>集群与哨兵同步</strong>：<br>
维护集群节点心跳、更新节点状态；哨兵模式下同步主从信息、检测主节点是否下线。</p></li> <li><p><strong>性能优化</strong>：<br>
执行内存碎片整理（<code>activedefrag</code> 配置开启时）、更新命令执行次数统计、重置峰值内存记录等。</p></li></ol> <h3 id="_4-3-时间事件的实现逻辑"><a href="#_4-3-时间事件的实现逻辑" class="header-anchor">#</a> 4.3 时间事件的实现逻辑</h3> <p>Redis 用<strong>无序链表</strong>存储时间事件（而非堆等有序结构），事件循环中处理流程如下：</p> <ol><li><p><strong>遍历链表查找最早到期事件</strong>：<br>
循环遍历时间事件链表，计算每个事件的到期时间（<code>when</code>）与当前时间的差值，找到最早到期的事件。</p></li> <li><p><strong>计算 IO 多路复用的阻塞时间</strong>：<br>
将最早到期事件的剩余时间作为 IO 多路复用（如 <code>epoll_wait</code>）的超时时间——若没有时间事件，超时时间为 -1（无限阻塞）；若有，则阻塞至事件到期或文件事件就绪。</p></li> <li><p><strong>处理已到期的时间事件</strong>：<br>
处理完文件事件后，再次遍历链表，执行所有 <code>when</code> 小于当前时间的时间事件；若为周期性事件，更新其 <code>when</code> 为下次到期时间。</p></li></ol> <p><strong>为什么用无序链表？</strong><br>
Redis 中时间事件数量极少（通常仅 <code>serverCron</code> 一个周期性事件），遍历开销可忽略（O(1) 复杂度），无需复杂的有序数据结构。</p> <h2 id="五、事件循环-redis-主线程的运行逻辑"><a href="#五、事件循环-redis-主线程的运行逻辑" class="header-anchor">#</a> 五、事件循环：Redis 主线程的运行逻辑</h2> <p>Redis 启动后，主线程进入 <code>aeMain</code> 事件循环，不断循环处理文件事件和时间事件，核心流程如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>void aeMain(aeEventLoop *eventLoop) {
    eventLoop-&gt;stop = 0;
    while (!eventLoop-&gt;stop) {
        // 1. 执行 beforeSleep 回调（如 serverCron 预热）
        if (eventLoop-&gt;beforesleep != NULL)
            eventLoop-&gt;beforesleep(eventLoop);
        // 2. 监听文件事件，阻塞时间为最早到期时间事件的剩余时间
        aeProcessEvents(eventLoop, AE_ALL_EVENTS);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="详细步骤解析"><a href="#详细步骤解析" class="header-anchor">#</a> 详细步骤解析</h3> <ol><li><p><strong>执行 beforeSleep 回调</strong>：<br>
事件循环阻塞前，调用 <code>beforesleep</code> 函数（默认绑定 <code>beforeSleep</code> 方法），执行如更新服务器统计信息、处理后台任务队列等操作。</p></li> <li><p><strong>监听并处理文件事件</strong>：<br>
调用 <code>aeProcessEvents</code> 函数，通过 IO 多路复用接口（如 <code>epoll_wait</code>）监听文件事件，阻塞时间由“最早到期时间事件的剩余时间”决定。当文件事件就绪时，按“读事件优先于写事件”的顺序触发回调函数处理。</p></li> <li><p><strong>处理时间事件</strong>：<br>
文件事件处理完成后，遍历时间事件链表，执行所有已到期的事件（定时事件执行后删除，周期性事件更新下次到期时间）。</p></li> <li><p><strong>循环或退出</strong>：<br>
若未触发停止标志（<code>stop=0</code>），重复步骤 1-3；若触发（如 <code>SHUTDOWN</code> 命令），退出事件循环，关闭服务器。</p></li></ol> <h2 id="总结-redis-高性能的设计哲学"><a href="#总结-redis-高性能的设计哲学" class="header-anchor">#</a> 总结：Redis 高性能的设计哲学</h2> <p>Redis 以“单线程 + 事件驱动”为核心，通过三大机制实现高性能：</p> <ol><li><strong>IO 多路复用</strong>：借助 epoll 等技术，单线程高效监听数千个客户端连接，避免无效系统调用和空轮询。</li> <li><strong>双缓冲区协作</strong>：内核缓冲区与应用缓冲区分工明确，减少系统调用次数，平衡硬件速度差异。</li> <li><strong>事件驱动调度</strong>：Reactor 模式统一调度文件事件（网络请求）和时间事件（后台任务），保证单线程下的有序并发。</li></ol> <p>这种设计既规避了多线程的并发竞争问题，又突破了单线程的 IO 瓶颈，使 Redis 在高并发场景下仍能保持毫秒级响应，成为缓存、会话存储等场景的首选数据库。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/tavio-zhang/blog/edit/master/docs/《Redis》笔记/8.RedisIO多路复用.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/tags/?tag=Redis%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8" title="标签">#Redis IO多路复用</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2026/01/21, 19:29:14</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/dd29df/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Redis限流</div></a> <a href="/pages/347bce/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Redis过期删除策略</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/dd29df/" class="prev">Redis限流</a></span> <span class="next"><a href="/pages/347bce/">Redis过期删除策略</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/942d4b/"><div>
            订单超时取消
            <!----></div></a> <span class="date">01-21</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/87b303/"><div>
            双 Token 登录
            <!----></div></a> <span class="date">01-21</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/a3f3fd/"><div>
            长短链接跳转
            <!----></div></a> <span class="date">01-21</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:taviozhang@gmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/tavio-zhang" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.c6ba13aa.js" defer></script><script src="/assets/js/2.8d9f533d.js" defer></script><script src="/assets/js/75.ed8e7990.js" defer></script>
  </body>
</html>
