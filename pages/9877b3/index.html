<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM GC | Tavio&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/logo.jpg">
    <meta name="description" content="后端技术博客,别让自己落后于技术的迭代">
    <meta name="keywords" content="鲜衣努码少年郎">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.3d594d45.css" as="style"><link rel="preload" href="/assets/js/app.c6ba13aa.js" as="script"><link rel="preload" href="/assets/js/2.8d9f533d.js" as="script"><link rel="preload" href="/assets/js/45.ae001bba.js" as="script"><link rel="prefetch" href="/assets/js/10.3c6e6522.js"><link rel="prefetch" href="/assets/js/11.09bc43b4.js"><link rel="prefetch" href="/assets/js/12.a996a87c.js"><link rel="prefetch" href="/assets/js/13.b02d3acf.js"><link rel="prefetch" href="/assets/js/14.64fd6e84.js"><link rel="prefetch" href="/assets/js/15.089c02a9.js"><link rel="prefetch" href="/assets/js/16.8fa236f4.js"><link rel="prefetch" href="/assets/js/17.a1730b7a.js"><link rel="prefetch" href="/assets/js/18.1335a425.js"><link rel="prefetch" href="/assets/js/19.9293cbc0.js"><link rel="prefetch" href="/assets/js/20.5d0fd1df.js"><link rel="prefetch" href="/assets/js/21.4319dddd.js"><link rel="prefetch" href="/assets/js/22.2d6d1193.js"><link rel="prefetch" href="/assets/js/23.f154e330.js"><link rel="prefetch" href="/assets/js/24.66ba0133.js"><link rel="prefetch" href="/assets/js/25.5979047a.js"><link rel="prefetch" href="/assets/js/26.04889c33.js"><link rel="prefetch" href="/assets/js/27.337928e8.js"><link rel="prefetch" href="/assets/js/28.665066df.js"><link rel="prefetch" href="/assets/js/29.5aa838b8.js"><link rel="prefetch" href="/assets/js/3.1aac6e80.js"><link rel="prefetch" href="/assets/js/30.a8923cf6.js"><link rel="prefetch" href="/assets/js/31.a290d548.js"><link rel="prefetch" href="/assets/js/32.cb2b7fdd.js"><link rel="prefetch" href="/assets/js/33.3286dca2.js"><link rel="prefetch" href="/assets/js/34.9aebb473.js"><link rel="prefetch" href="/assets/js/35.5777ff14.js"><link rel="prefetch" href="/assets/js/36.5c29dd6e.js"><link rel="prefetch" href="/assets/js/37.cbf6fde7.js"><link rel="prefetch" href="/assets/js/38.2a1572ab.js"><link rel="prefetch" href="/assets/js/39.000aacf6.js"><link rel="prefetch" href="/assets/js/4.16da1e3f.js"><link rel="prefetch" href="/assets/js/40.8fbbcfa8.js"><link rel="prefetch" href="/assets/js/41.1b995757.js"><link rel="prefetch" href="/assets/js/42.575e5238.js"><link rel="prefetch" href="/assets/js/43.0a4cb54f.js"><link rel="prefetch" href="/assets/js/44.8d3b4283.js"><link rel="prefetch" href="/assets/js/46.fc29dcb1.js"><link rel="prefetch" href="/assets/js/47.628ee1ef.js"><link rel="prefetch" href="/assets/js/48.7d4f854a.js"><link rel="prefetch" href="/assets/js/49.e848253a.js"><link rel="prefetch" href="/assets/js/5.20e9c2cf.js"><link rel="prefetch" href="/assets/js/50.045225be.js"><link rel="prefetch" href="/assets/js/51.d05a2035.js"><link rel="prefetch" href="/assets/js/52.35a2519d.js"><link rel="prefetch" href="/assets/js/53.ca8d5bc8.js"><link rel="prefetch" href="/assets/js/54.eb93e6ae.js"><link rel="prefetch" href="/assets/js/55.27ff3cca.js"><link rel="prefetch" href="/assets/js/56.4a98635a.js"><link rel="prefetch" href="/assets/js/57.db243c6d.js"><link rel="prefetch" href="/assets/js/58.650ffef2.js"><link rel="prefetch" href="/assets/js/59.9af578d0.js"><link rel="prefetch" href="/assets/js/6.cf5ce51d.js"><link rel="prefetch" href="/assets/js/60.800afb74.js"><link rel="prefetch" href="/assets/js/61.59b23cca.js"><link rel="prefetch" href="/assets/js/62.35998712.js"><link rel="prefetch" href="/assets/js/63.824df362.js"><link rel="prefetch" href="/assets/js/64.2f51e9d0.js"><link rel="prefetch" href="/assets/js/65.926e2499.js"><link rel="prefetch" href="/assets/js/66.2af85da2.js"><link rel="prefetch" href="/assets/js/67.bbd8d4b3.js"><link rel="prefetch" href="/assets/js/68.163c774f.js"><link rel="prefetch" href="/assets/js/69.deed8d29.js"><link rel="prefetch" href="/assets/js/7.92776da2.js"><link rel="prefetch" href="/assets/js/70.d6a81068.js"><link rel="prefetch" href="/assets/js/71.9adb8c50.js"><link rel="prefetch" href="/assets/js/72.9ba26fc5.js"><link rel="prefetch" href="/assets/js/73.c3ee5d2f.js"><link rel="prefetch" href="/assets/js/74.af7973c7.js"><link rel="prefetch" href="/assets/js/75.ed8e7990.js"><link rel="prefetch" href="/assets/js/76.668519a5.js"><link rel="prefetch" href="/assets/js/77.d6cb2694.js"><link rel="prefetch" href="/assets/js/78.494cff39.js"><link rel="prefetch" href="/assets/js/79.486534af.js"><link rel="prefetch" href="/assets/js/8.d7fc67a9.js"><link rel="prefetch" href="/assets/js/80.c60f84eb.js"><link rel="prefetch" href="/assets/js/81.80ab610c.js"><link rel="prefetch" href="/assets/js/82.38a483d0.js"><link rel="prefetch" href="/assets/js/83.72b7d6a4.js"><link rel="prefetch" href="/assets/js/84.f5a347be.js"><link rel="prefetch" href="/assets/js/85.f3b7b32b.js"><link rel="prefetch" href="/assets/js/86.1d47bd30.js"><link rel="prefetch" href="/assets/js/87.2361eddb.js"><link rel="prefetch" href="/assets/js/88.aef9e475.js"><link rel="prefetch" href="/assets/js/89.0a95e3be.js"><link rel="prefetch" href="/assets/js/9.f6c9df9a.js"><link rel="prefetch" href="/assets/js/90.ddf7b632.js"><link rel="prefetch" href="/assets/js/91.2a96bacf.js"><link rel="prefetch" href="/assets/js/92.f61fc5ec.js"><link rel="prefetch" href="/assets/js/93.40a17799.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3d594d45.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="Tavio's blog" class="logo"> <span class="site-name can-hide">Tavio's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/node/jvm/" class="nav-link">JVM底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/thread/" class="nav-link">邪恶多线程</a></li><li class="dropdown-item"><!----> <a href="/node/mybatis/" class="nav-link">MyBatis底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/spring/" class="nav-link">Spring底层原理</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/db/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/mysql/" class="nav-link">MySQL的优化之路</a></li><li class="dropdown-item"><!----> <a href="/note/clickhouse/" class="nav-link">ClickHouse的高性能</a></li><li class="dropdown-item"><!----> <a href="/note/redis/" class="nav-link">Redis的快速查询</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/middleware/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/rabbitmq/" class="nav-link">RabbitMQ的生产</a></li><li class="dropdown-item"><!----> <a href="/note/kafka/" class="nav-link">Kafka的高吞吐量</a></li><li class="dropdown-item"><!----> <a href="/note/es/" class="nav-link">ES的入门到入坑</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践" class="dropdown-title"><a href="/practice/" class="link-title">实践</a> <span class="title" style="display:none;">实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/284351/" class="nav-link">MySQL自增ID主键空洞</a></li><li class="dropdown-item"><!----> <a href="/pages/8f1df0/" class="nav-link">前端实现长整型排序</a></li><li class="dropdown-item"><!----> <a href="/pages/13fcc3/" class="nav-link">MySQL无感换表</a></li><li class="dropdown-item"><!----> <a href="/pages/69e163/" class="nav-link">Redis延时双删</a></li><li class="dropdown-item"><!----> <a href="/pages/f43494/" class="nav-link">高并发秒杀优惠卷</a></li><li class="dropdown-item"><!----> <a href="/pages/ab9a49/" class="nav-link">AOP无侵入式告警</a></li><li class="dropdown-item"><!----> <a href="/pages/a3f3fd/" class="nav-link">长短链接跳转</a></li><li class="dropdown-item"><!----> <a href="/pages/942d4b/" class="nav-link">订单超时取消</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/tavio-zhang/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.jpg"> <div class="blogger-info"><h3>Tavio Zhang</h3> <span>努力学习的小码喽</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/node/jvm/" class="nav-link">JVM底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/thread/" class="nav-link">邪恶多线程</a></li><li class="dropdown-item"><!----> <a href="/node/mybatis/" class="nav-link">MyBatis底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/spring/" class="nav-link">Spring底层原理</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/db/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/mysql/" class="nav-link">MySQL的优化之路</a></li><li class="dropdown-item"><!----> <a href="/note/clickhouse/" class="nav-link">ClickHouse的高性能</a></li><li class="dropdown-item"><!----> <a href="/note/redis/" class="nav-link">Redis的快速查询</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/middleware/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/rabbitmq/" class="nav-link">RabbitMQ的生产</a></li><li class="dropdown-item"><!----> <a href="/note/kafka/" class="nav-link">Kafka的高吞吐量</a></li><li class="dropdown-item"><!----> <a href="/note/es/" class="nav-link">ES的入门到入坑</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践" class="dropdown-title"><a href="/practice/" class="link-title">实践</a> <span class="title" style="display:none;">实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/284351/" class="nav-link">MySQL自增ID主键空洞</a></li><li class="dropdown-item"><!----> <a href="/pages/8f1df0/" class="nav-link">前端实现长整型排序</a></li><li class="dropdown-item"><!----> <a href="/pages/13fcc3/" class="nav-link">MySQL无感换表</a></li><li class="dropdown-item"><!----> <a href="/pages/69e163/" class="nav-link">Redis延时双删</a></li><li class="dropdown-item"><!----> <a href="/pages/f43494/" class="nav-link">高并发秒杀优惠卷</a></li><li class="dropdown-item"><!----> <a href="/pages/ab9a49/" class="nav-link">AOP无侵入式告警</a></li><li class="dropdown-item"><!----> <a href="/pages/a3f3fd/" class="nav-link">长短链接跳转</a></li><li class="dropdown-item"><!----> <a href="/pages/942d4b/" class="nav-link">订单超时取消</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/tavio-zhang/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/fc34a5/" class="sidebar-link">JVM整体架构</a></li><li><a href="/pages/2bc2e4/" class="sidebar-link">JVM String Table</a></li><li><a href="/pages/9877b3/" aria-current="page" class="active sidebar-link">JVM GC</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/9877b3/#一、gc-的核心目标与挑战" class="sidebar-link">一、GC 的核心目标与挑战</a></li><li class="sidebar-sub-header level2"><a href="/pages/9877b3/#二、对象存活判定-如何识别-垃圾" class="sidebar-link">二、对象存活判定：如何识别&quot;垃圾&quot;</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_2-1-引用计数法-已淘汰" class="sidebar-link">2.1 引用计数法（已淘汰）</a></li><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_2-2-可达性分析-jvm-主流算法" class="sidebar-link">2.2 可达性分析（JVM 主流算法）</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/9877b3/#三、引用类型-影响对象的回收时机" class="sidebar-link">三、引用类型：影响对象的回收时机</a></li><li class="sidebar-sub-header level2"><a href="/pages/9877b3/#四、垃圾收集算法-如何回收垃圾" class="sidebar-link">四、垃圾收集算法：如何回收垃圾</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_4-1-复制算法-高效无碎片-空间换时间" class="sidebar-link">4.1 复制算法：高效无碎片（空间换时间）</a></li><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_4-2-标记-清除算法-无空间浪费-有碎片" class="sidebar-link">4.2 标记-清除算法：无空间浪费（有碎片）</a></li><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_4-3-标记-整理算法-无碎片-时间换空间" class="sidebar-link">4.3 标记-整理算法：无碎片（时间换空间）</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/9877b3/#五、分代收集-结合算法优势的实战模型" class="sidebar-link">五、分代收集：结合算法优势的实战模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_5-1-内存区域划分" class="sidebar-link">5.1 内存区域划分</a></li><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_5-2-新生代细节" class="sidebar-link">5.2 新生代细节</a></li><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_5-3-老年代细节" class="sidebar-link">5.3 老年代细节</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/9877b3/#六、垃圾回收器-算法的工程实现" class="sidebar-link">六、垃圾回收器：算法的工程实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_6-1-serial-回收器-串行回收" class="sidebar-link">6.1 Serial 回收器（串行回收）</a></li><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_6-2-parallel-回收器-并行回收" class="sidebar-link">6.2 Parallel 回收器（并行回收）</a></li><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_6-3-cms-回收器-并发标记清除-已废弃" class="sidebar-link">6.3 CMS 回收器（并发标记清除，已废弃）</a></li><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_6-4-g1-回收器-区域化分代式-jdk9-默认" class="sidebar-link">6.4 G1 回收器（区域化分代式，JDK9+ 默认）</a></li><li class="sidebar-sub-header level3"><a href="/pages/9877b3/#_6-5-zgc-回收器-低延迟-jdk17-主流" class="sidebar-link">6.5 ZGC 回收器（低延迟，JDK17+ 主流）</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/9877b3/#七、总结-如何选择合适的-gc-策略" class="sidebar-link">七、总结：如何选择合适的 GC 策略</a></li></ul></li><li><a href="/pages/7be3b9/" class="sidebar-link">JVM 对象的创建与调用</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/node/jvm/#《JVM》笔记" data-v-06225672>《JVM》笔记</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/tavio-zhang" target="_blank" title="作者" class="beLink" data-v-06225672>Tavio</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-02-23</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">JVM GC<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="jvm-垃圾回收-gc-深度解析-从原理到实践"><a href="#jvm-垃圾回收-gc-深度解析-从原理到实践" class="header-anchor">#</a> JVM 垃圾回收（GC）深度解析：从原理到实践</h1> <p>在 Java 虚拟机（JVM）的内存管理中，垃圾回收（Garbage Collection，简称 GC）是自动内存管理的核心机制。它负责识别并回收不再被使用的对象，释放内存空间，避免内存泄漏和溢出（OOM）。</p> <h2 id="一、gc-的核心目标与挑战"><a href="#一、gc-的核心目标与挑战" class="header-anchor">#</a> 一、GC 的核心目标与挑战</h2> <p>垃圾回收的核心目标是<strong>高效释放不再被使用的内存</strong>，但需平衡三个关键指标：</p> <ul><li><strong>准确性</strong>：不误删仍在使用的对象（避免空指针异常），不遗漏垃圾对象（避免内存浪费）。</li> <li><strong>效率</strong>：回收过程对应用线程的影响（STW 时间）尽可能小。</li> <li><strong>适应性</strong>：能适配不同场景（如高吞吐量、低延迟、大堆内存等）。</li></ul> <p>实现这一目标的核心流程可概括为：<strong>如何判定对象已死 → 如何高效回收垃圾 → 如何根据场景选择回收工具</strong>。</p> <h2 id="二、对象存活判定-如何识别-垃圾"><a href="#二、对象存活判定-如何识别-垃圾" class="header-anchor">#</a> 二、对象存活判定：如何识别&quot;垃圾&quot;</h2> <p>要回收垃圾，首先需明确&quot;什么是垃圾&quot;——即不再被任何途径访问的对象。JVM 主要通过两种算法判定对象存活状态：</p> <h3 id="_2-1-引用计数法-已淘汰"><a href="#_2-1-引用计数法-已淘汰" class="header-anchor">#</a> 2.1 引用计数法（已淘汰）</h3> <ul><li><strong>原理</strong>：为每个对象维护一个引用计数器，当对象被引用时计数器+1，引用失效时-1；当计数器为 0 时，判定为垃圾。</li> <li><strong>优势</strong>：实现简单，判定效率高。</li> <li><strong>缺陷</strong>：无法解决<strong>循环引用</strong>问题（如 A 引用 B，B 引用 A，两者计数器始终为 1，永远无法被回收）。</li> <li><strong>现状</strong>：因循环引用缺陷，JVM 未采用该算法。</li></ul> <h3 id="_2-2-可达性分析-jvm-主流算法"><a href="#_2-2-可达性分析-jvm-主流算法" class="header-anchor">#</a> 2.2 可达性分析（JVM 主流算法）</h3> <ul><li><strong>原理</strong>：以&quot;GC Root&quot;为起点，通过遍历对象引用链（引用关系），若对象无法从任何 GC Root 可达，则标记为垃圾。</li> <li><strong>GC Root 范围</strong>（核心起点）：
<ul><li>虚拟机栈（栈帧局部变量表）中引用的对象（如方法参数、局部变量）；</li> <li>方法区中类的静态变量引用的对象；</li> <li>本地方法栈中 Native 方法引用的对象；</li> <li>活跃线程对象（如正在运行的线程实例）；</li> <li>被同步锁（synchronized）持有的对象。</li></ul></li> <li><strong>优势</strong>：解决了循环引用问题，是 JVM 判定垃圾的标准算法。</li></ul> <h2 id="三、引用类型-影响对象的回收时机"><a href="#三、引用类型-影响对象的回收时机" class="header-anchor">#</a> 三、引用类型：影响对象的回收时机</h2> <p>对象的&quot;存活&quot;不仅取决于是否可达，还与引用类型相关。JVM 定义了 4 种引用类型，从强到弱影响对象的回收优先级：</p> <table><thead><tr><th>引用类型</th> <th>定义与特性</th> <th>回收时机</th> <th>典型场景</th></tr></thead> <tbody><tr><td><strong>强引用</strong></td> <td>最常见的引用（如 <code>User user = new User()</code>），默认引用类型。</td> <td>仅当引用链完全断开（如 <code>user = null</code>）才会被回收。</td> <td>普通对象存储（如业务对象）。</td></tr> <tr><td><strong>软引用</strong></td> <td>用 <code>SoftReference</code> 包装（如 <code>SoftReference&lt;User&gt; softRef = new SoftReference&lt;&gt;(user)</code>）。</td> <td>内存不足时（OOM 前）主动回收。</td> <td>缓存（如图片缓存，内存充足时保留）。</td></tr> <tr><td><strong>弱引用</strong></td> <td>用 <code>WeakReference</code> 包装（如 <code>WeakReference&lt;User&gt; weakRef = new WeakReference&lt;&gt;(user)</code>）。</td> <td>下次 GC 时必然回收（无论内存是否充足）。</td> <td>临时缓存（如与对象关联的辅助信息）。</td></tr> <tr><td><strong>虚引用</strong></td> <td>用 <code>PhantomReference</code> 包装，必须结合引用队列（ReferenceQueue）使用。</td> <td>回收时触发队列通知，对象本身直接被回收。</td> <td>跟踪对象回收时机（如释放堆外内存）。</td></tr></tbody></table> <h2 id="四、垃圾收集算法-如何回收垃圾"><a href="#四、垃圾收集算法-如何回收垃圾" class="header-anchor">#</a> 四、垃圾收集算法：如何回收垃圾</h2> <p>确定垃圾后，需通过具体算法回收内存。JVM 设计了三种基础算法，各有优劣，适用于不同场景：</p> <h3 id="_4-1-复制算法-高效无碎片-空间换时间"><a href="#_4-1-复制算法-高效无碎片-空间换时间" class="header-anchor">#</a> 4.1 复制算法：高效无碎片（空间换时间）</h3> <ul><li><strong>原理</strong>：将内存划分为大小相等的两块（From 区和 To 区），仅使用 From 区分配对象。GC 时：
<ol><li>标记 From 区中所有存活对象；</li> <li>将存活对象<strong>完整复制</strong>到 To 区（按顺序排列，消除碎片）；</li> <li>清空 From 区，交换 From/To 角色（下次使用原 To 区）。</li></ol></li> <li><strong>优势</strong>：
<ul><li>回收效率高（仅处理存活对象，无需扫描垃圾）；</li> <li>无内存碎片（复制后对象连续排列）。</li></ul></li> <li><strong>缺陷</strong>：
<ul><li>空间利用率低（仅 50% 内存可用）；</li> <li>存活对象越多，复制成本越高。</li></ul></li> <li><strong>适用场景</strong>：新生代（对象存活率低，复制成本低）。</li></ul> <h3 id="_4-2-标记-清除算法-无空间浪费-有碎片"><a href="#_4-2-标记-清除算法-无空间浪费-有碎片" class="header-anchor">#</a> 4.2 标记-清除算法：无空间浪费（有碎片）</h3> <ul><li><strong>原理</strong>：分两个阶段：
<ol><li><strong>标记</strong>：从 GC Root 出发，标记所有存活对象；</li> <li><strong>清除</strong>：扫描整个内存区域，回收所有未标记的垃圾对象。</li></ol></li> <li><strong>优势</strong>：
<ul><li>空间利用率高（无需额外空闲区）；</li> <li>适合大对象（无需复制，处理成本低）。</li></ul></li> <li><strong>缺陷</strong>：
<ul><li>产生内存碎片（回收后空闲内存分散，可能无法分配大对象）；</li> <li>效率低（需遍历两次内存：标记一次，清除一次）。</li></ul></li> <li><strong>适用场景</strong>：存活对象少、垃圾多的场景（较少单独使用，多作为基础算法优化）。</li></ul> <h3 id="_4-3-标记-整理算法-无碎片-时间换空间"><a href="#_4-3-标记-整理算法-无碎片-时间换空间" class="header-anchor">#</a> 4.3 标记-整理算法：无碎片（时间换空间）</h3> <ul><li><strong>原理</strong>：标记-清除算法的优化版，分三个阶段：
<ol><li><strong>标记</strong>：同标记-清除（标记存活对象）；</li> <li><strong>整理</strong>：将所有存活对象向内存一端<strong>移动并按顺序排列</strong>；</li> <li><strong>清除</strong>：回收内存另一端的所有垃圾对象。</li></ol></li> <li><strong>优势</strong>：
<ul><li>无内存碎片（解决标记-清除的核心缺陷）；</li> <li>空间利用率高。</li></ul></li> <li><strong>缺陷</strong>：
<ul><li>效率更低（增加了对象移动成本）。</li></ul></li> <li><strong>适用场景</strong>：老年代（对象存活率高，需避免碎片以分配大对象）。</li></ul> <h2 id="五、分代收集-结合算法优势的实战模型"><a href="#五、分代收集-结合算法优势的实战模型" class="header-anchor">#</a> 五、分代收集：结合算法优势的实战模型</h2> <p>由于对象生命周期差异显著（大部分对象&quot;朝生夕死&quot;，少数对象长期存活），JVM 采用<strong>分代收集模型</strong>，结合上述算法优势：</p> <h3 id="_5-1-内存区域划分"><a href="#_5-1-内存区域划分" class="header-anchor">#</a> 5.1 内存区域划分</h3> <p>JVM 堆内存分为<strong>新生代</strong>（Young Generation）和<strong>老年代</strong>（Old Generation），比例通常为 1:2（可通过参数调整）。</p> <table><thead><tr><th>区域</th> <th>存储对象类型</th> <th>特点</th> <th>收集算法</th> <th>收集触发时机</th></tr></thead> <tbody><tr><td>新生代</td> <td>新创建的对象（朝生夕死）</td> <td>对象存活率低（约 5%）</td> <td>复制算法</td> <td>Minor GC（轻量 GC）</td></tr> <tr><td>老年代</td> <td>长期存活的对象（存活久）</td> <td>对象存活率高（约 95%）</td> <td>标记-整理算法</td> <td>Major GC/Full GC</td></tr></tbody></table> <h3 id="_5-2-新生代细节"><a href="#_5-2-新生代细节" class="header-anchor">#</a> 5.2 新生代细节</h3> <p>新生代进一步分为：</p> <ul><li><strong>Eden 区</strong>（伊甸园）：新对象优先分配的区域（占新生代 80%）；</li> <li><strong>两个 Survivor 区</strong>（From 区和 To 区，各占 10%）：用于存放 Minor GC 后存活的对象。</li></ul> <p><strong>Minor GC 流程</strong>：</p> <ol><li>当 Eden 区满时，触发 Minor GC；</li> <li>标记 Eden 区 + From 区的存活对象；</li> <li>将存活对象复制到 To 区，同时对象年龄+1（年龄记录在对象头中）；</li> <li>清空 Eden 区和 From 区，交换 From/To 角色；</li> <li>当对象年龄达到阈值（默认 15，可通过 <code>-XX:MaxTenuringThreshold</code> 调整），晋升至老年代。</li></ol> <h3 id="_5-3-老年代细节"><a href="#_5-3-老年代细节" class="header-anchor">#</a> 5.3 老年代细节</h3> <p>老年代存储长期存活的对象，触发回收的情况包括：</p> <ul><li>老年代内存不足；</li> <li>新生代对象晋升失败（如大对象直接进入老年代，或 Survivor 区对象放不下）；</li> <li>显式调用 <code>System.gc()</code>（不推荐，可能触发 Full GC）。</li></ul> <p><strong>Major GC/Full GC</strong>：</p> <ul><li>Major GC：仅回收老年代（较少单独触发）；</li> <li>Full GC：同时回收新生代和老年代（STW 时间长，应尽量避免）。</li></ul> <h2 id="六、垃圾回收器-算法的工程实现"><a href="#六、垃圾回收器-算法的工程实现" class="header-anchor">#</a> 六、垃圾回收器：算法的工程实现</h2> <p>回收器是垃圾收集算法的具体实现，不同回收器针对不同场景（吞吐量、延迟等）优化。主流回收器如下：</p> <h3 id="_6-1-serial-回收器-串行回收"><a href="#_6-1-serial-回收器-串行回收" class="header-anchor">#</a> 6.1 Serial 回收器（串行回收）</h3> <ul><li><strong>特点</strong>：单线程执行 GC，全程触发 STW（Stop The World，暂停所有用户线程）。</li> <li><strong>算法实现</strong>：
<ul><li>新生代：复制算法；</li> <li>老年代：标记-整理算法。</li></ul></li> <li><strong>适用场景</strong>：单 CPU、小内存（如嵌入式设备）、低并发场景（STW 时间长，不适合高并发）。</li> <li><strong>参数配置</strong>：<code>-XX:+UseSerialGC</code>（启用 Serial + Serial Old 组合）。</li></ul> <h3 id="_6-2-parallel-回收器-并行回收"><a href="#_6-2-parallel-回收器-并行回收" class="header-anchor">#</a> 6.2 Parallel 回收器（并行回收）</h3> <ul><li><strong>特点</strong>：多线程并行执行 GC，以<strong>高吞吐量</strong>为目标（吞吐量 = 业务时间 / (业务时间 + GC 时间)）。</li> <li><strong>算法实现</strong>：
<ul><li>新生代：并行复制算法；</li> <li>老年代：并行标记-整理算法。</li></ul></li> <li><strong>优势</strong>：STW 时间比 Serial 短（多线程加速）。</li> <li><strong>适用场景</strong>：多 CPU、高吞吐量需求（如后台计算）、对延迟不敏感的场景。</li> <li><strong>参数配置</strong>：<code>-XX:+UseParallelGC</code>（JDK8 默认，新生代 Parallel Scavenge + 老年代 Parallel Old）。</li></ul> <h3 id="_6-3-cms-回收器-并发标记清除-已废弃"><a href="#_6-3-cms-回收器-并发标记清除-已废弃" class="header-anchor">#</a> 6.3 CMS 回收器（并发标记清除，已废弃）</h3> <ul><li><strong>特点</strong>：以<strong>低延迟</strong>为目标，老年代回收的大部分阶段与用户线程并发执行（减少 STW 时间）。</li> <li><strong>算法实现</strong>：老年代采用标记-清除算法（新生代默认搭配 Parallel 回收器）。</li> <li><strong>回收流程</strong>：
<ol><li><strong>初始标记</strong>：标记 GC Root 直接引用的对象（STW，时间短）；</li> <li><strong>并发标记</strong>：从初始标记对象出发，遍历所有可达对象（与用户线程并行，无 STW）；</li> <li><strong>重新标记</strong>：修正并发标记中因用户线程修改引用导致的偏差（STW，时间短）；</li> <li><strong>并发清除</strong>：回收未标记的垃圾对象（与用户线程并行，无 STW）。</li></ol></li> <li><strong>缺陷</strong>：
<ul><li>产生内存碎片（标记-清除算法导致）；</li> <li>对 CPU 资源敏感（并发阶段占用 CPU）；</li> <li>JDK9 标记废弃，JDK14 移除。</li></ul></li> <li><strong>参数配置</strong>：<code>-XX:+UseConcMarkSweepGC</code>（需搭配 <code>-XX:+UseParNewGC</code> 启用新生代并行回收）。</li></ul> <h3 id="_6-4-g1-回收器-区域化分代式-jdk9-默认"><a href="#_6-4-g1-回收器-区域化分代式-jdk9-默认" class="header-anchor">#</a> 6.4 G1 回收器（区域化分代式，JDK9+ 默认）</h3> <ul><li><p><strong>特点</strong>：融合分代回收与分区回收，兼顾吞吐量与低延迟，支持大堆内存（数十 GB）。</p></li> <li><p><strong>内存模型</strong>：G1 摒弃了 CMS/Parallel Old 的 “连续新生代、连续老年代” 布局，将堆划分为多个大小相等的独立 Region，核心细节如下：</p> <ol><li><strong>Region 大小计算</strong>：
<ul><li>Region 大小由 JVM 在启动时自动计算，范围 1MB~32MB（2 的幂次），公式：Region大小 = 堆总大小 / Region数量（默认 Region 数量约 2048 个）；</li> <li>可通过参数-XX:G1HeapRegionSize手动指定（需为 2 的幂次，如 1M/2M/4M，不建议随意修改）。</li></ul></li> <li><strong>Region 类型（动态切换）</strong>：</li></ol> <table><thead><tr><th>类型</th> <th>作用</th> <th>特殊说明</th></tr></thead> <tbody><tr><td>Eden Region</td> <td>新生代，存放新创建的对象</td> <td>多个 Eden Region 可并行回收，占堆比动态调整（无需固定比例，如 ParNew 的 8:1:1）</td></tr> <tr><td>Survivor Region</td> <td>新生代，存放 Eden 回收后存活的对象</td> <td>同样动态分配数量，默认分为 S0/S1，但 Region 数量不固定</td></tr> <tr><td>Old Region</td> <td>老年代，存放存活时间长的对象</td> <td>由 Survivor 晋升而来，或大对象拆分后存入</td></tr> <tr><td>Humongous Region</td> <td>存放大对象（大小≥Region 一半），占用连续多个 Region</td> <td>直接划入老年代范畴，回收时需整体处理，避免跨 Region 碎片</td></tr></tbody></table> <ol start="3"><li><strong>Remembered Set（记忆集，G1 核心优化）</strong>:
<ul><li>问题：Region 是独立的，跨 Region 引用（如 Old Region 引用 Eden Region 对象）会导致 GC 时需要全堆扫描；</li> <li>解决方案：每个 Region 维护一个 Remembered Set，记录 “外部 Region 对本 Region 对象的引用”；</li> <li>实现：通过写屏障（Write Barrier）拦截对象引用更新，异步更新 Remembered Set，避免全堆扫描，大幅降低 GC 耗时。</li></ul></li></ol></li> <li><p><strong>核心优势</strong>：</p> <ul><li><strong>动态调整</strong>：无需固定新老年代比例，根据负载灵活分配 Region 角色；</li> <li><strong>优先回收</strong>：每次 GC 优先选择垃圾占比最高的 Region（最大化回收效率）；</li> <li><strong>无碎片</strong>：采用复制算法（存活对象复制到新 Region）。</li></ul></li> <li><p><strong>回收流程</strong>：</p> <ul><li><strong>新生代 GC</strong>：
<ol><li>暂停所有用户线程（STW）；</li> <li>采用复制算法：将 Eden + Survivor 中存活的对象复制到新的 Survivor Region（或晋升到 Old Region）；</li> <li>清空原 Eden 和 Survivor Region，标记为空闲；</li> <li>恢复用户线程。</li></ol></li> <li><strong>混合 GC</strong>（同时回收新老年代）：
<ol><li><strong>初始标记（STW，毫秒级）</strong>：</li></ol> <ul><li>标记 GC Root 直接引用的对象；</li> <li>借助 Young GC 的 STW 阶段完成，无需额外暂停（优化点）。</li></ul> <ol start="2"><li><strong>并发标记（无 STW）</strong>：</li></ol> <ul><li>从 GC Root 出发，遍历全堆对象图，标记所有存活对象；</li> <li>同时用户线程正常运行，通过写屏障处理 “并发标记期间的对象引用变化”（增量更新）。</li></ul> <ol start="3"><li><strong>最终标记（STW，毫秒级）</strong>：</li></ol> <ul><li>修正并发标记期间因用户线程操作导致的标记偏差；</li> <li>处理 Remembered Set 中的跨 Region 引用，标记遗漏的存活对象。</li></ul> <ol start="4"><li><strong>筛选回收（STW，核心优化）</strong>：</li></ol> <ul><li>统计所有 Region 的垃圾占比（存活对象比例）；</li> <li>按 “垃圾占比从高到低” 排序，优先回收垃圾最多的 Region（贪心算法，最大化回收效率）；</li> <li>控制本次回收的 Region 数量，确保 STW 时间不超过-XX:MaxGCPauseMillis（默认 200ms）；</li> <li>采用复制算法：将存活对象复制到空闲 Region，清空原 Region。</li></ul></li></ul></li> <li><p><strong>参数配置</strong>：<code>-XX:+UseG1GC</code>（JDK9+ 默认）。</p></li></ul> <h3 id="_6-5-zgc-回收器-低延迟-jdk17-主流"><a href="#_6-5-zgc-回收器-低延迟-jdk17-主流" class="header-anchor">#</a> 6.5 ZGC 回收器（低延迟，JDK17+ 主流）</h3> <ul><li><p><strong>特点</strong>：专为低延迟、大堆内存（TB 级）设计，STW 时间控制在毫秒级以内。</p></li> <li><p><strong>内存模型</strong>：ZGC 继承了 G1 的 “Region 分区” 思想，但做了颠覆性优化 —— 抛弃 G1 固定大小 Region + 静态分配的设计，改为<strong>分级 Region + 动态管理</strong>，完美适配不同大小对象与弹性内存需求。</p> <ol><li><strong>Region 分级设计</strong>: ZGC 将 Region 分为三类固定大小的分区，避免 G1 中 “大对象占用连续 Region” 的问题，每个 Region 仅存储对应尺寸的对象：</li></ol> <table><thead><tr><th>Region 类型</th> <th>固定大小</th> <th>适用对象</th> <th>核心特点</th></tr></thead> <tbody><tr><td>Small</td> <td>2MB</td> <td>小对象（&lt;2MB）</td> <td>占堆内存 90% 以上，回收效率最高</td></tr> <tr><td>Medium</td> <td>32MB</td> <td>中等对象（2MB~32MB）</td> <td>避免小 Region 拆分中等对象，减少内存浪费</td></tr> <tr><td>Large</td> <td>N×2MB</td> <td>大对象（&gt;32MB）</td> <td>每个 Large Region 仅存一个大对象，大小为 2MB 整数倍，回收时整体处理</td></tr></tbody></table> <ol start="2"><li><strong>动态 Region 管理</strong>: 与 G1 启动时一次性创建所有 Region 不同，ZGC 的 Region 具备 “动态弹性”：
<ul><li><strong>按需创建</strong>：堆内存不足时自动新建 Region，无需启动时预留大量内存；</li> <li><strong>空闲销毁</strong>：：回收后的空闲 Region 可销毁，释放物理内存（适配容器 / 云环境的内存弹性伸缩）；</li> <li><strong>无固定比例</strong>：无需像 G1 那样限制新生代 / 老年代占比，完全根据对象分配需求动态调整。</li></ul></li> <li><strong>抛弃 Remembered Set（RS）</strong>:G1 为解决跨 Region 引用问题，引入 RS（记忆集）导致额外内存开销（堆的 10%~20%）；而 ZGC 通过 “颜色指针” 技术直接解决跨 Region 引用问题，彻底抛弃 RS，额外内存开销仅为堆的 1%~5%，大幅降低资源消耗。</li></ol></li> <li><p><strong>核心优化</strong>：ZGC 的灵魂：<strong>颜色指针技术</strong></p> <p>颜色指针是 ZGC 实现 “极致低延迟” 的核心，也是区别于所有传统 GC 的关键 —— 它颠覆了<strong>在对象头标记 GC 状态</strong>的传统思路，转而通过指针本身标记对象状态。</p> <ol><li><strong>颜色指针的底层原理</strong>:</li></ol> <p>颜色指针的实现依赖硬件架构特性：AMD64（x86_64）架构下，64 位指针仅使用低 48 位（可寻址 256TB 内存），剩余 16 位为 “空闲位”。ZGC 复用这些空闲位作为 “标记位”，直接通过指针标记对象的 GC 状态，无需修改对象头。</p> <p>简化的指针结构如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>63~48位：保留位（未使用）
47~0位： 内存地址（实际寻址）
└─ 47~44位：颜色标记位（存储对象GC状态）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="2"><li><strong>颜色指针的核心状态</strong>:</li></ol> <p>ZGC 定义了三类核心 “颜色”（状态），通过标记位实现对象状态管理，无需遍历对象：</p> <table><thead><tr><th>颜色</th> <th>状态含义</th> <th>核心作用</th></tr></thead> <tbody><tr><td>白色</td> <td>对象未被标记，属于垃圾</td> <td>回收阶段直接清理</td></tr> <tr><td>灰色</td> <td>对象已标记，但子对象未遍历</td> <td>并发标记阶段的临时状态，需继续遍历子对象</td></tr> <tr><td>黑色</td> <td>对象及所有子对象均已标记</td> <td>存活对象，回收阶段保留</td></tr> <tr><td>转发色（扩展）</td> <td>对象已复制到新 Region</td> <td>重分配阶段临时状态，指引用户线程访问新对象地址</td></tr></tbody></table> <ol start="3"><li><strong>颜色指针的核心优势</strong>:
<ul><li><strong>无全局扫描</strong>：通过指针直接判断对象状态，无需遍历全堆 / Region，大幅减少 GC 耗时；</li> <li><strong>轻量级并发</strong>：用户线程访问对象时，CPU 的内存保护机制（MMU）自动重定向到最新对象地址，无需复杂写屏障；</li> <li><strong>STW 极短</strong>：所有状态标记在指针层面完成，仅初始 / 最终标记需极短 STW，无修改对象头的额外开销。</li></ul></li></ol></li> <li><p><strong>回收流程</strong>：</p> <ol><li><strong>初始标记（STW，微秒级）</strong>：
<ul><li><strong>核心操作</strong>：标记 GC Root 直接引用的对象（如虚拟机栈、本地方法栈引用）；</li> <li><strong>耗时特点</strong>：仅与 GC Root 数量相关，与堆大小无关，通常 &lt; 1ms。</li></ul></li> <li><strong>并发标记（无 STW）</strong>：
<ul><li><strong>核心操作</strong>：从 GC Root 出发，遍历对象图，通过颜色指针标记所有存活对象；</li> <li><strong>关键优化</strong>：用户线程正常运行，ZGC 通过 “读屏障” 处理并发标记期间的对象引用变化，无性能瓶颈。</li></ul></li> <li><strong>并发预备重分配</strong>：
<ul><li><strong>核心操作</strong>：统计所有 Region 的垃圾占比，按 “垃圾占比从高到低” 筛选待回收 Region（贪心策略）；</li> <li><strong>前置准备</strong>：为待回收 Region 分配新的空闲 Region，准备复制存活对象。</li></ul></li> <li><strong>重分配标记（STW，微秒级）</strong>：
<ul><li><strong>核心操作</strong>：修正并发标记期间因用户线程操作导致的指针引用偏差；</li> <li><strong>关键目标</strong>：标记所有指向 “待回收 Region” 的 GC Root 引用，耗时同样 &lt; 1ms。</li></ul></li> <li><strong>并发重分配（核心阶段，无 STW）</strong>：
<ul><li><strong>核心操作</strong>：将待回收 Region 中的存活对象复制到新 Region；</li> <li><strong>透明转发</strong>：用户线程访问旧 Region 对象时，通过 “转发色指针” 自动重定向到新对象地址，无感知。</li></ul></li> <li><strong>并发重映射（无 STW）</strong>：
<ul><li><strong>核心操作</strong>：异步更新所有指向旧 Region 的指针，使其直接指向新对象地址；</li> <li><strong>容错设计</strong>：即使该阶段未完成，读屏障也会兜底转发，不影响业务运行。</li></ul></li></ol> <p><strong>核心结论</strong>：ZGC 的 STW 时间仅来自 “初始标记 + 重分配标记”，且总耗时不随堆大小增长 ——1GB 堆和 1TB 堆的 STW 时间几乎一致。</p></li> <li><p><strong>适用场景</strong>：对延迟敏感的大型应用（如分布式服务、大数据处理）。</p></li> <li><p><strong>参数配置</strong>：<code>-XX:+UseZGC</code>（JDK11 引入，JDK17 成为长期支持版本）。</p></li></ul> <h2 id="七、总结-如何选择合适的-gc-策略"><a href="#七、总结-如何选择合适的-gc-策略" class="header-anchor">#</a> 七、总结：如何选择合适的 GC 策略</h2> <p>GC 调优的核心是匹配业务场景：</p> <ul><li><strong>高吞吐量优先</strong>：选择 Parallel 回收器（如后台批处理任务）；</li> <li><strong>低延迟优先</strong>：选择 G1 或 ZGC（如 Web 服务、实时交易系统）；</li> <li><strong>小内存/嵌入式</strong>：选择 Serial 回收器。</li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/tavio-zhang/blog/edit/master/docs/《JVM》笔记/3.JVM GC.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/tags/?tag=JVM%20GC" title="标签">#JVM GC</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2026/01/21, 19:29:14</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/2bc2e4/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">JVM String Table</div></a> <a href="/pages/7be3b9/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">JVM 对象的创建与调用</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/2bc2e4/" class="prev">JVM String Table</a></span> <span class="next"><a href="/pages/7be3b9/">JVM 对象的创建与调用</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/942d4b/"><div>
            订单超时取消
            <!----></div></a> <span class="date">01-21</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/87b303/"><div>
            双 Token 登录
            <!----></div></a> <span class="date">01-21</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/a3f3fd/"><div>
            长短链接跳转
            <!----></div></a> <span class="date">01-21</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:taviozhang@gmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/tavio-zhang" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.c6ba13aa.js" defer></script><script src="/assets/js/2.8d9f533d.js" defer></script><script src="/assets/js/45.ae001bba.js" defer></script>
  </body>
</html>
