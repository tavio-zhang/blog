<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis限流 | Tavio&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/logo.jpg">
    <meta name="description" content="后端技术博客,别让自己落后于技术的迭代">
    <meta name="keywords" content="鲜衣努码少年郎">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.3d594d45.css" as="style"><link rel="preload" href="/assets/js/app.c6ba13aa.js" as="script"><link rel="preload" href="/assets/js/2.8d9f533d.js" as="script"><link rel="preload" href="/assets/js/74.af7973c7.js" as="script"><link rel="prefetch" href="/assets/js/10.3c6e6522.js"><link rel="prefetch" href="/assets/js/11.09bc43b4.js"><link rel="prefetch" href="/assets/js/12.a996a87c.js"><link rel="prefetch" href="/assets/js/13.b02d3acf.js"><link rel="prefetch" href="/assets/js/14.64fd6e84.js"><link rel="prefetch" href="/assets/js/15.089c02a9.js"><link rel="prefetch" href="/assets/js/16.8fa236f4.js"><link rel="prefetch" href="/assets/js/17.a1730b7a.js"><link rel="prefetch" href="/assets/js/18.1335a425.js"><link rel="prefetch" href="/assets/js/19.9293cbc0.js"><link rel="prefetch" href="/assets/js/20.5d0fd1df.js"><link rel="prefetch" href="/assets/js/21.4319dddd.js"><link rel="prefetch" href="/assets/js/22.2d6d1193.js"><link rel="prefetch" href="/assets/js/23.f154e330.js"><link rel="prefetch" href="/assets/js/24.66ba0133.js"><link rel="prefetch" href="/assets/js/25.5979047a.js"><link rel="prefetch" href="/assets/js/26.04889c33.js"><link rel="prefetch" href="/assets/js/27.337928e8.js"><link rel="prefetch" href="/assets/js/28.665066df.js"><link rel="prefetch" href="/assets/js/29.5aa838b8.js"><link rel="prefetch" href="/assets/js/3.1aac6e80.js"><link rel="prefetch" href="/assets/js/30.a8923cf6.js"><link rel="prefetch" href="/assets/js/31.a290d548.js"><link rel="prefetch" href="/assets/js/32.cb2b7fdd.js"><link rel="prefetch" href="/assets/js/33.3286dca2.js"><link rel="prefetch" href="/assets/js/34.9aebb473.js"><link rel="prefetch" href="/assets/js/35.5777ff14.js"><link rel="prefetch" href="/assets/js/36.5c29dd6e.js"><link rel="prefetch" href="/assets/js/37.cbf6fde7.js"><link rel="prefetch" href="/assets/js/38.2a1572ab.js"><link rel="prefetch" href="/assets/js/39.000aacf6.js"><link rel="prefetch" href="/assets/js/4.16da1e3f.js"><link rel="prefetch" href="/assets/js/40.8fbbcfa8.js"><link rel="prefetch" href="/assets/js/41.1b995757.js"><link rel="prefetch" href="/assets/js/42.575e5238.js"><link rel="prefetch" href="/assets/js/43.0a4cb54f.js"><link rel="prefetch" href="/assets/js/44.8d3b4283.js"><link rel="prefetch" href="/assets/js/45.ae001bba.js"><link rel="prefetch" href="/assets/js/46.fc29dcb1.js"><link rel="prefetch" href="/assets/js/47.628ee1ef.js"><link rel="prefetch" href="/assets/js/48.7d4f854a.js"><link rel="prefetch" href="/assets/js/49.e848253a.js"><link rel="prefetch" href="/assets/js/5.20e9c2cf.js"><link rel="prefetch" href="/assets/js/50.045225be.js"><link rel="prefetch" href="/assets/js/51.d05a2035.js"><link rel="prefetch" href="/assets/js/52.35a2519d.js"><link rel="prefetch" href="/assets/js/53.ca8d5bc8.js"><link rel="prefetch" href="/assets/js/54.eb93e6ae.js"><link rel="prefetch" href="/assets/js/55.27ff3cca.js"><link rel="prefetch" href="/assets/js/56.4a98635a.js"><link rel="prefetch" href="/assets/js/57.db243c6d.js"><link rel="prefetch" href="/assets/js/58.650ffef2.js"><link rel="prefetch" href="/assets/js/59.9af578d0.js"><link rel="prefetch" href="/assets/js/6.cf5ce51d.js"><link rel="prefetch" href="/assets/js/60.800afb74.js"><link rel="prefetch" href="/assets/js/61.59b23cca.js"><link rel="prefetch" href="/assets/js/62.35998712.js"><link rel="prefetch" href="/assets/js/63.824df362.js"><link rel="prefetch" href="/assets/js/64.2f51e9d0.js"><link rel="prefetch" href="/assets/js/65.926e2499.js"><link rel="prefetch" href="/assets/js/66.2af85da2.js"><link rel="prefetch" href="/assets/js/67.bbd8d4b3.js"><link rel="prefetch" href="/assets/js/68.163c774f.js"><link rel="prefetch" href="/assets/js/69.deed8d29.js"><link rel="prefetch" href="/assets/js/7.92776da2.js"><link rel="prefetch" href="/assets/js/70.d6a81068.js"><link rel="prefetch" href="/assets/js/71.9adb8c50.js"><link rel="prefetch" href="/assets/js/72.9ba26fc5.js"><link rel="prefetch" href="/assets/js/73.c3ee5d2f.js"><link rel="prefetch" href="/assets/js/75.ed8e7990.js"><link rel="prefetch" href="/assets/js/76.668519a5.js"><link rel="prefetch" href="/assets/js/77.d6cb2694.js"><link rel="prefetch" href="/assets/js/78.494cff39.js"><link rel="prefetch" href="/assets/js/79.486534af.js"><link rel="prefetch" href="/assets/js/8.d7fc67a9.js"><link rel="prefetch" href="/assets/js/80.c60f84eb.js"><link rel="prefetch" href="/assets/js/81.80ab610c.js"><link rel="prefetch" href="/assets/js/82.38a483d0.js"><link rel="prefetch" href="/assets/js/83.72b7d6a4.js"><link rel="prefetch" href="/assets/js/84.f5a347be.js"><link rel="prefetch" href="/assets/js/85.f3b7b32b.js"><link rel="prefetch" href="/assets/js/86.1d47bd30.js"><link rel="prefetch" href="/assets/js/87.2361eddb.js"><link rel="prefetch" href="/assets/js/88.aef9e475.js"><link rel="prefetch" href="/assets/js/89.0a95e3be.js"><link rel="prefetch" href="/assets/js/9.f6c9df9a.js"><link rel="prefetch" href="/assets/js/90.ddf7b632.js"><link rel="prefetch" href="/assets/js/91.2a96bacf.js"><link rel="prefetch" href="/assets/js/92.f61fc5ec.js"><link rel="prefetch" href="/assets/js/93.40a17799.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3d594d45.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="Tavio's blog" class="logo"> <span class="site-name can-hide">Tavio's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/node/jvm/" class="nav-link">JVM底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/thread/" class="nav-link">邪恶多线程</a></li><li class="dropdown-item"><!----> <a href="/node/mybatis/" class="nav-link">MyBatis底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/spring/" class="nav-link">Spring底层原理</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/db/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/mysql/" class="nav-link">MySQL的优化之路</a></li><li class="dropdown-item"><!----> <a href="/note/clickhouse/" class="nav-link">ClickHouse的高性能</a></li><li class="dropdown-item"><!----> <a href="/note/redis/" class="nav-link">Redis的快速查询</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/middleware/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/rabbitmq/" class="nav-link">RabbitMQ的生产</a></li><li class="dropdown-item"><!----> <a href="/note/kafka/" class="nav-link">Kafka的高吞吐量</a></li><li class="dropdown-item"><!----> <a href="/note/es/" class="nav-link">ES的入门到入坑</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践" class="dropdown-title"><a href="/practice/" class="link-title">实践</a> <span class="title" style="display:none;">实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/284351/" class="nav-link">MySQL自增ID主键空洞</a></li><li class="dropdown-item"><!----> <a href="/pages/8f1df0/" class="nav-link">前端实现长整型排序</a></li><li class="dropdown-item"><!----> <a href="/pages/13fcc3/" class="nav-link">MySQL无感换表</a></li><li class="dropdown-item"><!----> <a href="/pages/69e163/" class="nav-link">Redis延时双删</a></li><li class="dropdown-item"><!----> <a href="/pages/f43494/" class="nav-link">高并发秒杀优惠卷</a></li><li class="dropdown-item"><!----> <a href="/pages/ab9a49/" class="nav-link">AOP无侵入式告警</a></li><li class="dropdown-item"><!----> <a href="/pages/a3f3fd/" class="nav-link">长短链接跳转</a></li><li class="dropdown-item"><!----> <a href="/pages/942d4b/" class="nav-link">订单超时取消</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/tavio-zhang/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.jpg"> <div class="blogger-info"><h3>Tavio Zhang</h3> <span>努力学习的小码喽</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/node/jvm/" class="nav-link">JVM底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/thread/" class="nav-link">邪恶多线程</a></li><li class="dropdown-item"><!----> <a href="/node/mybatis/" class="nav-link">MyBatis底层原理</a></li><li class="dropdown-item"><!----> <a href="/node/spring/" class="nav-link">Spring底层原理</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/db/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/mysql/" class="nav-link">MySQL的优化之路</a></li><li class="dropdown-item"><!----> <a href="/note/clickhouse/" class="nav-link">ClickHouse的高性能</a></li><li class="dropdown-item"><!----> <a href="/note/redis/" class="nav-link">Redis的快速查询</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/middleware/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/rabbitmq/" class="nav-link">RabbitMQ的生产</a></li><li class="dropdown-item"><!----> <a href="/note/kafka/" class="nav-link">Kafka的高吞吐量</a></li><li class="dropdown-item"><!----> <a href="/note/es/" class="nav-link">ES的入门到入坑</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践" class="dropdown-title"><a href="/practice/" class="link-title">实践</a> <span class="title" style="display:none;">实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/284351/" class="nav-link">MySQL自增ID主键空洞</a></li><li class="dropdown-item"><!----> <a href="/pages/8f1df0/" class="nav-link">前端实现长整型排序</a></li><li class="dropdown-item"><!----> <a href="/pages/13fcc3/" class="nav-link">MySQL无感换表</a></li><li class="dropdown-item"><!----> <a href="/pages/69e163/" class="nav-link">Redis延时双删</a></li><li class="dropdown-item"><!----> <a href="/pages/f43494/" class="nav-link">高并发秒杀优惠卷</a></li><li class="dropdown-item"><!----> <a href="/pages/ab9a49/" class="nav-link">AOP无侵入式告警</a></li><li class="dropdown-item"><!----> <a href="/pages/a3f3fd/" class="nav-link">长短链接跳转</a></li><li class="dropdown-item"><!----> <a href="/pages/942d4b/" class="nav-link">订单超时取消</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/tavio-zhang/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/eada73/" class="sidebar-link">Redis核心数据结构</a></li><li><a href="/pages/d81738/" class="sidebar-link">Redis持久化机制</a></li><li><a href="/pages/797c36/" class="sidebar-link">Redis高可用架构</a></li><li><a href="/pages/88227a/" class="sidebar-link">Redis分布式锁</a></li><li><a href="/pages/ea330e/" class="sidebar-link">Redis缓存设计</a></li><li><a href="/pages/d2662c/" class="sidebar-link">Redis大Key与热Key</a></li><li><a href="/pages/dd29df/" aria-current="page" class="active sidebar-link">Redis限流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/dd29df/#一、限流核心认知-不止是-计数-更是流量治理的艺术" class="sidebar-link">一、限流核心认知：不止是“计数”，更是流量治理的艺术</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_1-1-限流的本质目标" class="sidebar-link">1.1 限流的本质目标</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_1-2-限流的核心衡量指标" class="sidebar-link">1.2 限流的核心衡量指标</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_1-3-redis-限流的核心优势" class="sidebar-link">1.3 Redis 限流的核心优势</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/dd29df/#二、经典限流算法深度解析-原理-数学模型-适用场景" class="sidebar-link">二、经典限流算法深度解析：原理+数学模型+适用场景</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_2-1-固定窗口计数器-最简单的-计数限流" class="sidebar-link">2.1 固定窗口计数器：最简单的“计数限流”</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#核心原理" class="sidebar-link">核心原理</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#数据结构选择" class="sidebar-link">数据结构选择</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#底层执行流程" class="sidebar-link">底层执行流程</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#优缺点与适用场景" class="sidebar-link">优缺点与适用场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_2-2-滑动窗口计数器-解决临界问题的-精准限流" class="sidebar-link">2.2 滑动窗口计数器：解决临界问题的“精准限流”</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#核心原理-2" class="sidebar-link">核心原理</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#数据结构选择-2" class="sidebar-link">数据结构选择</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#底层执行流程-2" class="sidebar-link">底层执行流程</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#优缺点与适用场景-2" class="sidebar-link">优缺点与适用场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_2-3-漏桶算法-严格控制输出速率的-平稳限流" class="sidebar-link">2.3 漏桶算法：严格控制输出速率的“平稳限流”</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#核心原理-3" class="sidebar-link">核心原理</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#数据结构选择-3" class="sidebar-link">数据结构选择</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#底层执行流程-3" class="sidebar-link">底层执行流程</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#优缺点与适用场景-3" class="sidebar-link">优缺点与适用场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_2-4-令牌桶算法-平衡灵活性与抗突发的-最优解" class="sidebar-link">2.4 令牌桶算法：平衡灵活性与抗突发的“最优解”</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#核心原理-4" class="sidebar-link">核心原理</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#数据结构选择-4" class="sidebar-link">数据结构选择</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#底层执行流程-4" class="sidebar-link">底层执行流程</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#优缺点与适用场景-4" class="sidebar-link">优缺点与适用场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#四种算法核心对比-生产选型参考" class="sidebar-link">四种算法核心对比（生产选型参考）</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/dd29df/#三、redis-限流生产级实现-架构设计-代码落地" class="sidebar-link">三、Redis 限流生产级实现：架构设计+代码落地</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_3-1-整体架构设计-可扩展、易集成" class="sidebar-link">3.1 整体架构设计（可扩展、易集成）</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_3-2-前置准备-环境配置与依赖引入" class="sidebar-link">3.2 前置准备：环境配置与依赖引入</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_1-maven-依赖" class="sidebar-link">1. Maven 依赖</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_2-redis-配置-application-yml" class="sidebar-link">2. Redis 配置（application.yml）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_3-redistemplate-优化配置" class="sidebar-link">3. RedisTemplate 优化配置</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_3-3-核心组件实现" class="sidebar-link">3.3 核心组件实现</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_1-限流算法枚举-统一标识" class="sidebar-link">1. 限流算法枚举（统一标识）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_2-自定义注解-redislimit" class="sidebar-link">2. 自定义注解（@RedisLimit）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_3-限流算法工厂与实现-lua-脚本原子化" class="sidebar-link">3. 限流算法工厂与实现（Lua 脚本原子化）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_4-aop-切面-注解驱动执行" class="sidebar-link">4. AOP 切面（注解驱动执行）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_5-全局异常处理器-统一返回限流结果" class="sidebar-link">5. 全局异常处理器（统一返回限流结果）</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_3-4-接口集成示例-注解驱动-零侵入" class="sidebar-link">3.4 接口集成示例（注解驱动，零侵入）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_1-普通接口限流-按接口粒度" class="sidebar-link">1. 普通接口限流（按接口粒度）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_2-用户粒度限流-按用户-id-接口" class="sidebar-link">2. 用户粒度限流（按用户 ID + 接口）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_3-秒杀场景限流-商品粒度-用户粒度双重防护" class="sidebar-link">3. 秒杀场景限流（商品粒度+用户粒度双重防护）</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/dd29df/#四、生产级优化-高并发、高可用、可观测" class="sidebar-link">四、生产级优化：高并发、高可用、可观测</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_4-1-高并发优化-突破单机-redis-瓶颈" class="sidebar-link">4.1 高并发优化：突破单机 Redis 瓶颈</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_1-redis-cluster-分片策略" class="sidebar-link">1. Redis Cluster 分片策略</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_2-本地缓存预热-减少-redis-访问" class="sidebar-link">2. 本地缓存预热（减少 Redis 访问）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_3-lua-脚本优化-减少网络往返" class="sidebar-link">3. Lua 脚本优化（减少网络往返）</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_4-2-高可用优化-避免-redis-成为单点故障" class="sidebar-link">4.2 高可用优化：避免 Redis 成为单点故障</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_1-降级策略完善" class="sidebar-link">1. 降级策略完善</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_2-redis-集群高可用部署" class="sidebar-link">2. Redis 集群高可用部署</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_3-限流键过期时间优化" class="sidebar-link">3. 限流键过期时间优化</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_4-3-可观测性优化-监控告警体系" class="sidebar-link">4.3 可观测性优化：监控告警体系</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_1-限流指标监控-接入-prometheus-grafana" class="sidebar-link">1. 限流指标监控（接入 Prometheus+Grafana）</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_2-告警配置" class="sidebar-link">2. 告警配置</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_3-日志打印" class="sidebar-link">3. 日志打印</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_4-4-可扩展性优化-动态调整与多场景适配" class="sidebar-link">4.4 可扩展性优化：动态调整与多场景适配</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_1-动态阈值调整" class="sidebar-link">1. 动态阈值调整</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_2-多租户限流" class="sidebar-link">2. 多租户限流</a></li><li class="sidebar-sub-header level4"><a href="/pages/dd29df/#_3-流量染色与灰度限流" class="sidebar-link">3. 流量染色与灰度限流</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/dd29df/#五、生产环境踩坑指南-10-个致命坑点" class="sidebar-link">五、生产环境踩坑指南（10 个致命坑点）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-1-坑-1-限流键冲突" class="sidebar-link">5.1 坑 1：限流键冲突</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-2-坑-2-临界问题导致限流失效" class="sidebar-link">5.2 坑 2：临界问题导致限流失效</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-3-坑-3-lua-脚本超时" class="sidebar-link">5.3 坑 3：Lua 脚本超时</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-4-坑-4-redis-大-key-问题" class="sidebar-link">5.4 坑 4：Redis 大 Key 问题</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-5-坑-5-分布式场景下全局一致性问题" class="sidebar-link">5.5 坑 5：分布式场景下全局一致性问题</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-6-坑-6-本地缓存与-redis-数据不一致" class="sidebar-link">5.6 坑 6：本地缓存与 Redis 数据不一致</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-7-坑-7-漏桶算法的-漏水-任务阻塞" class="sidebar-link">5.7 坑 7：漏桶算法的“漏水”任务阻塞</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-8-坑-8-令牌桶算法的时间差计算误差" class="sidebar-link">5.8 坑 8：令牌桶算法的时间差计算误差</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-9-坑-9-redis-连接池参数不合理" class="sidebar-link">5.9 坑 9：Redis 连接池参数不合理</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_5-10-坑-10-未处理-redis-主从切换导致的限流数据丢失" class="sidebar-link">5.10 坑 10：未处理 Redis 主从切换导致的限流数据丢失</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/dd29df/#六、行业最佳实践总结" class="sidebar-link">六、行业最佳实践总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_6-1-算法选型最佳实践" class="sidebar-link">6.1 算法选型最佳实践</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_6-2-限流策略组合最佳实践" class="sidebar-link">6.2 限流策略组合最佳实践</a></li><li class="sidebar-sub-header level3"><a href="/pages/dd29df/#_6-3-阈值调优最佳实践" class="sidebar-link">6.3 阈值调优最佳实践</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/dd29df/#七、总结与展望" class="sidebar-link">七、总结与展望</a></li></ul></li><li><a href="/pages/aeefc4/" class="sidebar-link">Redis IO多路复用</a></li><li><a href="/pages/347bce/" class="sidebar-link">Redis过期删除策略</a></li><li><a href="/pages/390684/" class="sidebar-link">Redis Bitmap</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/note/redis/#《Redis》笔记" data-v-06225672>《Redis》笔记</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/tavio-zhang" target="_blank" title="作者" class="beLink" data-v-06225672>Tavio</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-05-14</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Redis限流<!----></h1>  <div class="theme-vdoing-content content__default"><p>在高并发系统的稳定性保障体系中，限流是与熔断、降级并列的核心防护手段。当流量突破服务承载上限时，限流能精准“削峰填谷”，避免数据库雪崩、应用服务器过载，成为保障业务连续性的“最后一道防线”。</p> <p>Redis 凭借<strong>原子操作特性、分布式一致性支持、毫秒级响应速度</strong>，成为限流方案的首选技术栈——其性能可达单机 10 万+ QPS，远超数据库和应用本地限流的承载能力，广泛应用于秒杀抢购、API 网关、第三方接口调用等核心场景。</p> <h2 id="一、限流核心认知-不止是-计数-更是流量治理的艺术"><a href="#一、限流核心认知-不止是-计数-更是流量治理的艺术" class="header-anchor">#</a> 一、限流核心认知：不止是“计数”，更是流量治理的艺术</h2> <h3 id="_1-1-限流的本质目标"><a href="#_1-1-限流的本质目标" class="header-anchor">#</a> 1.1 限流的本质目标</h3> <p>限流并非简单“拒绝请求”，而是通过科学的流量控制，实现三大核心目标：</p> <ul><li><strong>保护系统稳定性</strong>：防止突发流量（如秒杀、爬虫攻击）压垮服务，确保核心业务可用；</li> <li><strong>保障用户体验</strong>：避免因系统过载导致的全量响应超时，仅牺牲部分非核心请求；</li> <li><strong>合理利用资源</strong>：使服务器 CPU、内存、网络等资源处于最优负载区间，避免浪费。</li></ul> <h3 id="_1-2-限流的核心衡量指标"><a href="#_1-2-限流的核心衡量指标" class="header-anchor">#</a> 1.2 限流的核心衡量指标</h3> <p>设计限流方案前，需明确三个关键指标，避免无的放矢：</p> <ul><li><strong>限流粒度</strong>：接口级（如 <code>/api/pay</code>）、用户级（如 <code>user:1001:/api/order</code>）、IP 级（如 <code>ip:192.168.1.1</code>）、商品级（如 <code>seckill:goods:10086</code>）；</li> <li><strong>时间窗口</strong>：1 秒、10 秒、1 分钟、1 天（需匹配业务场景，如秒杀用 1 秒窗口，第三方 API 调用用 1 天窗口）；</li> <li><strong>限流阈值</strong>：单位时间内允许的最大请求数（需通过压测确定，通常设为服务峰值承载能力的 80%，预留缓冲）。</li></ul> <h3 id="_1-3-redis-限流的核心优势"><a href="#_1-3-redis-限流的核心优势" class="header-anchor">#</a> 1.3 Redis 限流的核心优势</h3> <p>相较于本地限流（如 Guava RateLimiter）、网关限流（如 Nginx），Redis 限流具备不可替代的优势：</p> <ul><li><strong>分布式一致性</strong>：多节点、多服务部署时，能保证全局限流阈值统一（如多实例部署的应用，共同遵守“1 秒 100 次请求”规则）；</li> <li><strong>高性能</strong>：内存操作 + 原子命令，响应时间 &lt; 1ms，支持每秒 10 万+ 限流请求；</li> <li><strong>灵活性</strong>：支持多种限流算法，可通过 Lua 脚本扩展自定义逻辑；</li> <li><strong>可扩展性</strong>：结合 Redis Cluster 可横向扩展，突破单机性能瓶颈。</li></ul> <h2 id="二、经典限流算法深度解析-原理-数学模型-适用场景"><a href="#二、经典限流算法深度解析-原理-数学模型-适用场景" class="header-anchor">#</a> 二、经典限流算法深度解析：原理+数学模型+适用场景</h2> <p>四种经典限流算法是 Redis 限流的基础，其核心差异在于“流量控制的灵活性”和“抗突发能力”。以下从数学模型、数据结构选择、底层逻辑三个维度，彻底讲透每种算法的设计思路。</p> <h3 id="_2-1-固定窗口计数器-最简单的-计数限流"><a href="#_2-1-固定窗口计数器-最简单的-计数限流" class="header-anchor">#</a> 2.1 固定窗口计数器：最简单的“计数限流”</h3> <h4 id="核心原理"><a href="#核心原理" class="header-anchor">#</a> 核心原理</h4> <p>将时间划分为固定长度的窗口（如 1 秒），用 Redis 的 <code>INCR</code> 命令原子计数，窗口结束后计数器自动重置。数学模型可表示为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>count (t) ≤ threshold, 其中 t ∈ [k*window, (k+1)*window)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><code>count(t)</code>：时间 t 所在窗口的请求数；</li> <li><code>threshold</code>：窗口内最大请求数；</li> <li><code>window</code>：窗口时长。</li></ul> <h4 id="数据结构选择"><a href="#数据结构选择" class="header-anchor">#</a> 数据结构选择</h4> <ul><li>采用 Redis String 类型存储计数器，key 为“限流粒度+窗口标识”（如 <code>limiter:fixed:/api/pay:1690000000</code>）；</li> <li>利用 <code>EXPIRE</code> 命令设置窗口过期时间，避免手动清理。</li></ul> <h4 id="底层执行流程"><a href="#底层执行流程" class="header-anchor">#</a> 底层执行流程</h4> <ol><li>新请求到来时，计算当前窗口标识（如时间戳整除窗口时长：<code>System.currentTimeMillis() / 1000</code>）；</li> <li>拼接 Redis key：<code>limiter:fixed:{key}:{windowId}</code>；</li> <li>执行 <code>INCR</code> 命令递增计数器，若为第一次递增则设置 <code>EXPIRE</code> 过期时间；</li> <li>若计数器值 &gt; 阈值则限流，否则允许通过。</li></ol> <h4 id="优缺点与适用场景"><a href="#优缺点与适用场景" class="header-anchor">#</a> 优缺点与适用场景</h4> <ul><li>优点：实现最简单、Redis 操作最少（2 个命令）、性能最高（单机 QPS 可达 50 万+）；</li> <li>缺点：存在<strong>临界问题</strong>——窗口切换时可能出现“双倍流量”（如 0.9 秒到 1.1 秒跨两个窗口，共通过 2*threshold 次请求）；</li> <li>适用场景：对流量平滑性要求低的场景（如普通接口限流、非核心业务防护）。</li></ul> <h3 id="_2-2-滑动窗口计数器-解决临界问题的-精准限流"><a href="#_2-2-滑动窗口计数器-解决临界问题的-精准限流" class="header-anchor">#</a> 2.2 滑动窗口计数器：解决临界问题的“精准限流”</h3> <h4 id="核心原理-2"><a href="#核心原理-2" class="header-anchor">#</a> 核心原理</h4> <p>将固定窗口拆分为 N 个连续的小窗口（如 1 秒拆分为 10 个 100ms 小窗口），通过滑动窗口的方式计算单位时间内的请求数。数学模型可表示为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>count (t) = Σ count (t-i*subWindow) ，其中 i=0 到 N-1，subWindow = window/N
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><code>subWindow</code>：小窗口时长；</li> <li>N：小窗口数量（N 越大，流量控制越精准，但性能开销越高）。</li></ul> <h4 id="数据结构选择-2"><a href="#数据结构选择-2" class="header-anchor">#</a> 数据结构选择</h4> <ul><li>采用 Redis ZSET 类型，score 为请求时间戳，value 为唯一标识（如 UUID）；</li> <li>ZSET 天然支持按 score 范围删除和计数，完美适配滑动窗口的“删除过期请求+统计当前请求数”需求。</li></ul> <h4 id="底层执行流程-2"><a href="#底层执行流程-2" class="header-anchor">#</a> 底层执行流程</h4> <ol><li>新请求到来时，获取当前时间戳 <code>currentTime</code>；</li> <li>计算窗口起始时间：<code>windowStartTime = currentTime - window*1000</code>；</li> <li>执行 <code>ZREMRANGEBYSCORE</code> 删除 ZSET 中 score &lt; <code>windowStartTime</code> 的过期请求；</li> <li>执行 <code>ZCARD</code> 统计当前窗口内的请求数，若 &gt;= 阈值则限流；</li> <li>若允许通过，执行 <code>ZADD</code> 将当前请求的时间戳和 UUID 加入 ZSET；</li> <li>设置 ZSET 过期时间为 <code>window+1</code> 秒，避免垃圾数据堆积。</li></ol> <h4 id="优缺点与适用场景-2"><a href="#优缺点与适用场景-2" class="header-anchor">#</a> 优缺点与适用场景</h4> <ul><li>优点：解决固定窗口的临界问题，流量控制精准，支持任意时间粒度的窗口；</li> <li>缺点：Redis 操作较多（3 个命令），高并发下性能略低于固定窗口（单机 QPS 约 30 万+）；</li> <li>适用场景：对流量平滑性有要求的核心场景（如电商商品详情页、支付接口限流）。</li></ul> <h3 id="_2-3-漏桶算法-严格控制输出速率的-平稳限流"><a href="#_2-3-漏桶算法-严格控制输出速率的-平稳限流" class="header-anchor">#</a> 2.3 漏桶算法：严格控制输出速率的“平稳限流”</h3> <h4 id="核心原理-3"><a href="#核心原理-3" class="header-anchor">#</a> 核心原理</h4> <p>将请求比作“水流”，漏桶的容量为最大并发等待数，漏桶的“漏水速率”为单位时间允许通过的请求数。数学模型可表示为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>inRate ≤ outRate, 且 queueSize ≤ capacity
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><code>inRate</code>：请求流入速率；</li> <li><code>outRate</code>：请求流出速率（服务承载速率）；</li> <li><code>queueSize</code>：当前排队请求数；</li> <li><code>capacity</code>：漏桶容量（最大排队数）。</li></ul> <h4 id="数据结构选择-3"><a href="#数据结构选择-3" class="header-anchor">#</a> 数据结构选择</h4> <ul><li>采用 Redis LIST 类型作为漏桶，存储待处理的请求（可存入请求 ID、时间戳等元数据）；</li> <li>结合 Redis 定时任务（或外部定时任务）实现“漏水”逻辑。</li></ul> <h4 id="底层执行流程-3"><a href="#底层执行流程-3" class="header-anchor">#</a> 底层执行流程</h4> <ol><li>新请求到来时，执行 <code>LLEN</code> 统计 LIST 长度，若 &lt; 容量则执行 <code>RPUSH</code> 入队；</li> <li>定时任务按 <code>outRate</code> 速率执行 <code>LPOP</code> 出队，触发业务逻辑处理；</li> <li>若 LIST 长度 &gt;= 容量则限流，返回“请求过于频繁”。</li></ol> <h4 id="优缺点与适用场景-3"><a href="#优缺点与适用场景-3" class="header-anchor">#</a> 优缺点与适用场景</h4> <ul><li>优点：严格控制请求输出速率，避免服务因突发流量过载，适用于下游服务性能有限的场景；</li> <li>缺点：抗突发能力差（即使漏桶为空，突发流量也需排队），需额外维护定时任务；</li> <li>适用场景：数据库写入限流、第三方 API 调用频率控制（如微信支付 API 每天限 1 万次）。</li></ul> <h3 id="_2-4-令牌桶算法-平衡灵活性与抗突发的-最优解"><a href="#_2-4-令牌桶算法-平衡灵活性与抗突发的-最优解" class="header-anchor">#</a> 2.4 令牌桶算法：平衡灵活性与抗突发的“最优解”</h3> <h4 id="核心原理-4"><a href="#核心原理-4" class="header-anchor">#</a> 核心原理</h4> <p>系统按固定速率向令牌桶中放入令牌，桶的最大容量为阈值；新请求需获取 1 个令牌才能通过，无令牌则限流。数学模型可表示为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>tokenCount(t) = min(capacity, tokenCount(t0) + (t - t0)*refillRate)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><code>tokenCount(t)</code>：时间 t 时的令牌数；</li> <li><code>capacity</code>：令牌桶容量；</li> <li><code>refillRate</code>：令牌填充速率（单位：个/秒）；</li> <li><code>t0</code>：上次填充令牌的时间。</li></ul> <h4 id="数据结构选择-4"><a href="#数据结构选择-4" class="header-anchor">#</a> 数据结构选择</h4> <ul><li>采用 Redis HASH 类型存储令牌桶状态：<code>{ &quot;lastRefillTime&quot;: 上次填充时间戳, &quot;tokenCount&quot;: 当前令牌数 }</code>；</li> <li>HASH 支持原子更新多个字段，且存储紧凑，适合高频读写。</li></ul> <h4 id="底层执行流程-4"><a href="#底层执行流程-4" class="header-anchor">#</a> 底层执行流程</h4> <ol><li>新请求到来时，获取当前时间戳 <code>currentTime</code>；</li> <li>执行 <code>HGETALL</code> 获取令牌桶状态，若不存在则初始化（<code>tokenCount=capacity</code>，<code>lastRefillTime=currentTime</code>）；</li> <li>计算时间差 <code>timeDiff = currentTime - lastRefillTime</code>，补充令牌：<code>addTokens = timeDiff * refillRate / 1000</code>，更新 <code>tokenCount = min(tokenCount + addTokens, capacity)</code>；</li> <li>若 <code>tokenCount &gt; 0</code> 则令牌数减 1，允许通过；否则限流；</li> <li>执行 <code>HMSET</code> 更新令牌桶状态，设置过期时间避免垃圾数据。</li></ol> <h4 id="优缺点与适用场景-4"><a href="#优缺点与适用场景-4" class="header-anchor">#</a> 优缺点与适用场景</h4> <ul><li>优点：兼顾灵活性（固定填充速率）和抗突发（令牌预存），适配大多数高并发场景；</li> <li>缺点：实现略复杂，需处理令牌填充的时间差计算；</li> <li>适用场景：秒杀、抢购、首页核心接口等对流量平滑性和抗突发能力均有要求的场景。</li></ul> <h3 id="四种算法核心对比-生产选型参考"><a href="#四种算法核心对比-生产选型参考" class="header-anchor">#</a> 四种算法核心对比（生产选型参考）</h3> <table><thead><tr><th>算法</th> <th>数学模型复杂度</th> <th>单机 QPS 上限</th> <th>抗突发能力</th> <th>流量平滑性</th> <th>存储开销</th> <th>适用场景</th></tr></thead> <tbody><tr><td>固定窗口计数器</td> <td>低</td> <td>50 万+</td> <td>一般</td> <td>差</td> <td>极低</td> <td>普通接口、非核心业务</td></tr> <tr><td>滑动窗口计数器</td> <td>中</td> <td>30 万+</td> <td>一般</td> <td>中</td> <td>中</td> <td>核心 API、商品详情页</td></tr> <tr><td>漏桶算法</td> <td>中</td> <td>20 万+</td> <td>差</td> <td>极高</td> <td>中高</td> <td>数据库写入、第三方 API 调用</td></tr> <tr><td>令牌桶算法</td> <td>中高</td> <td>25 万+</td> <td>极高</td> <td>中高</td> <td>中</td> <td>秒杀、抢购、高并发核心业务</td></tr></tbody></table> <h2 id="三、redis-限流生产级实现-架构设计-代码落地"><a href="#三、redis-限流生产级实现-架构设计-代码落地" class="header-anchor">#</a> 三、Redis 限流生产级实现：架构设计+代码落地</h2> <h3 id="_3-1-整体架构设计-可扩展、易集成"><a href="#_3-1-整体架构设计-可扩展、易集成" class="header-anchor">#</a> 3.1 整体架构设计（可扩展、易集成）</h3> <p>为了适配不同业务场景，采用“工厂模式+注解驱动”的设计思路，核心架构如下：</p> <ul><li><strong>限流算法工厂</strong>：封装四种算法的实现，支持按类型动态选择；</li> <li><strong>自定义注解</strong>：通过 <code>@RedisLimit</code> 注解快速集成到接口，无需侵入业务代码；</li> <li><strong>Lua 脚本原子化</strong>：所有算法均通过 Lua 脚本实现，避免竞态条件；</li> <li><strong>降级策略</strong>：Redis 异常时降级为本地限流（Guava RateLimiter），保证服务可用性。</li></ul> <h3 id="_3-2-前置准备-环境配置与依赖引入"><a href="#_3-2-前置准备-环境配置与依赖引入" class="header-anchor">#</a> 3.2 前置准备：环境配置与依赖引入</h3> <h4 id="_1-maven-依赖"><a href="#_1-maven-依赖" class="header-anchor">#</a> 1. Maven 依赖</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- Spring Boot 核心依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- Redis 依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- Redis 连接池 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- Guava 本地限流（降级用） --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
    &lt;artifactId&gt;guava&lt;/artifactId&gt;
    &lt;version&gt;32.1.2-jre&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- AOP 依赖（注解驱动） --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h4 id="_2-redis-配置-application-yml"><a href="#_2-redis-配置-application-yml" class="header-anchor">#</a> 2. Redis 配置（application.yml）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>spring:
  redis:
    host: 127.0.0.1
    port: 6379
    password: # 生产环境必填
    lettuce:
      pool:
        max-active: 64 # 最大连接数（按并发量调整）
        max-idle: 32 # 最大空闲连接
        min-idle: 8 # 最小空闲连接
        max-wait: 3000ms # 连接等待时间
    timeout: 2000ms # 连接超时时间
  redis-limiter:
    default-window-seconds: 1 # 默认窗口时长（秒）
    default-threshold: 100 # 默认限流阈值
    fallback-enabled: true # 启用降级策略
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="_3-redistemplate-优化配置"><a href="#_3-redistemplate-优化配置" class="header-anchor">#</a> 3. RedisTemplate 优化配置</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(factory);

        // Key 序列化（String 序列化，避免乱码）
        StringRedisSerializer stringSerializer = new StringRedisSerializer();
        template.setKeySerializer(stringSerializer);
        template.setHashKeySerializer(stringSerializer);

        // Value 序列化（JSON 序列化，支持对象存储）
        GenericJackson2JsonRedisSerializer jsonSerializer = new GenericJackson2JsonRedisSerializer();
        template.setValueSerializer(jsonSerializer);
        template.setHashValueSerializer(jsonSerializer);

        // 开启事务支持（可选，根据业务需求）
        template.setEnableTransactionSupport(true);
        template.afterPropertiesSet();
        return template;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h3 id="_3-3-核心组件实现"><a href="#_3-3-核心组件实现" class="header-anchor">#</a> 3.3 核心组件实现</h3> <h4 id="_1-限流算法枚举-统一标识"><a href="#_1-限流算法枚举-统一标识" class="header-anchor">#</a> 1. 限流算法枚举（统一标识）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>public enum LimitAlgorithm {
    FIXED_WINDOW,    // 固定窗口计数器
    SLIDING_WINDOW,  // 滑动窗口计数器
    LEAKY_BUCKET,    // 漏桶算法
    TOKEN_BUCKET     // 令牌桶算法
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="_2-自定义注解-redislimit"><a href="#_2-自定义注解-redislimit" class="header-anchor">#</a> 2. 自定义注解（@RedisLimit）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import java.lang.annotation.*;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RedisLimit {
    /**
     * 限流键（支持 SpEL 表达式，如 &quot;#userId + ':' + '/api/order'&quot;）
     */
    String key() default &quot;&quot;;

    /**
     * 限流算法类型
     */
    LimitAlgorithm algorithm() default LimitAlgorithm.TOKEN_BUCKET;

    /**
     * 窗口时长（秒）
     */
    int windowSeconds() default 1;

    /**
     * 限流阈值（窗口内最大请求数）
     */
    int threshold() default 100;

    /**
     * 漏桶算法专用：桶容量
     */
    int bucketCapacity() default 10;

    /**
     * 漏桶/令牌桶专用：速率（个/秒）
     */
    int rate() default 5;

    /**
     * 限流提示信息
     */
    String message() default &quot;请求过于频繁，请稍后再试&quot;;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h4 id="_3-限流算法工厂与实现-lua-脚本原子化"><a href="#_3-限流算法工厂与实现-lua-脚本原子化" class="header-anchor">#</a> 3. 限流算法工厂与实现（Lua 脚本原子化）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * Redis 限流算法工厂（封装四种核心算法）
 */
@Component
public class RedisLimitFactory {

    @Resource
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    // 固定窗口计数器 Lua 脚本（原子执行 INCR + EXPIRE + 阈值判断）
    private static final String FIXED_WINDOW_SCRIPT = &quot;&quot;&quot;
            local key = KEYS[1]
            local windowSeconds = tonumber(ARGV[1])
            local threshold = tonumber(ARGV[2])
            
            -- 原子递增计数器
            local count = redis.call('incr', key)
            -- 第一次递增时设置过期时间
            if count == 1 then
                redis.call('expire', key, windowSeconds)
            end
            -- 返回是否允许通过（1 允许，0 限流）
            return count &lt;= threshold and 1 or 0
            &quot;&quot;&quot;;

    // 滑动窗口计数器 Lua 脚本
    private static final String SLIDING_WINDOW_SCRIPT = &quot;&quot;&quot;
            local key = KEYS[1]
            local windowSeconds = tonumber(ARGV[1])
            local threshold = tonumber(ARGV[2])
            local currentTime = tonumber(ARGV[3])
            local windowStartTime = currentTime - windowSeconds * 1000
            
            -- 删除过期的请求（时间戳 &lt; 窗口起始时间）
            redis.call('zremrangebyscore', key, 0, windowStartTime)
            -- 统计当前窗口内的请求数
            local count = redis.call('zcard', key)
            if count &gt;= threshold then
                return 0 -- 限流
            end
            -- 加入当前请求（value 用 UUID 避免重复）
            redis.call('zadd', key, currentTime, ARGV[4])
            -- 设置过期时间（窗口时长 + 1 秒，避免垃圾数据）
            redis.call('expire', key, windowSeconds + 1)
            return 1 -- 允许通过
            &quot;&quot;&quot;;

    // 令牌桶算法 Lua 脚本
    private static final String TOKEN_BUCKET_SCRIPT = &quot;&quot;&quot;
            local key = KEYS[1]
            local capacity = tonumber(ARGV[1]) -- 桶容量
            local refillRate = tonumber(ARGV[2]) -- 填充速率（个/秒）
            local currentTime = tonumber(ARGV[3])
            
            -- 获取令牌桶状态，不存在则初始化
            local bucket = redis.call('hgetall', key)
            local lastRefillTime = currentTime
            local tokenCount = capacity
            if #bucket &gt; 0 then
                for i = 1, #bucket, 2 do
                    if bucket[i] == 'lastRefillTime' then
                        lastRefillTime = tonumber(bucket[i+1])
                    elseif bucket[i] == 'tokenCount' then
                        tokenCount = tonumber(bucket[i+1])
                    end
                end
            end
            
            -- 计算应补充的令牌数
            local timeDiff = currentTime - lastRefillTime
            local addTokens = timeDiff * refillRate / 1000
            if addTokens &gt; 0 then
                tokenCount = math.min(tokenCount + addTokens, capacity)
                lastRefillTime = currentTime
            end
            
            -- 尝试获取令牌
            if tokenCount &lt;= 0 then
                return 0 -- 限流
            end
            tokenCount = tokenCount - 1
            
            -- 更新令牌桶状态
            redis.call('hmset', key, 'lastRefillTime', lastRefillTime, 'tokenCount', tokenCount)
            -- 设置过期时间（10 分钟，避免长期无请求的垃圾数据）
            redis.call('expire', key, 600)
            return 1 -- 允许通过
            &quot;&quot;&quot;;

    // 漏桶算法 Lua 脚本
    private static final String LEAKY_BUCKET_SCRIPT = &quot;&quot;&quot;
            local key = KEYS[1]
            local capacity = tonumber(ARGV[1]) -- 桶容量
            local currentTime = tonumber(ARGV[2])
            
            -- 统计当前桶中请求数
            local size = redis.call('llen', key)
            if size &gt;= capacity then
                return 0 -- 桶满，限流
            end
            
            -- 入桶（存储请求时间戳）
            redis.call('rpush', key, currentTime)
            -- 设置过期时间（5 分钟，避免请求处理完后残留）
            redis.call('expire', key, 300)
            return 1 -- 入桶成功
            &quot;&quot;&quot;;

    /**
     * 执行限流判断
     */
    public boolean doLimit(LimitAlgorithm algorithm, String key, int windowSeconds, int threshold,
                           int bucketCapacity, int rate) {
        try {
            switch (algorithm) {
                case FIXED_WINDOW:
                    return fixedWindowLimit(key, windowSeconds, threshold);
                case SLIDING_WINDOW:
                    return slidingWindowLimit(key, windowSeconds, threshold);
                case TOKEN_BUCKET:
                    return tokenBucketLimit(key, bucketCapacity, rate);
                case LEAKY_BUCKET:
                    return leakyBucketLimit(key, bucketCapacity);
                default:
                    return false;
            }
        } catch (Exception e) {
            // Redis 异常时，降级为本地限流（Guava RateLimiter）
            return localFallbackLimit(rate);
        }
    }

    /**
     * 固定窗口计数器限流
     */
    private boolean fixedWindowLimit(String key, int windowSeconds, int threshold) {
        String redisKey = buildRedisKey(key, LimitAlgorithm.FIXED_WINDOW);
        DefaultRedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;(FIXED_WINDOW_SCRIPT, Long.class);
        Long result = redisTemplate.execute(script, Collections.singletonList(redisKey),
                String.valueOf(windowSeconds), String.valueOf(threshold));
        return result != null &amp;&amp; result == 1;
    }

    /**
     * 滑动窗口计数器限流
     */
    private boolean slidingWindowLimit(String key, int windowSeconds, int threshold) {
        String redisKey = buildRedisKey(key, LimitAlgorithm.SLIDING_WINDOW);
        long currentTime = System.currentTimeMillis();
        String uuid = UUID.randomUUID().toString();
        DefaultRedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;(SLIDING_WINDOW_SCRIPT, Long.class);
        Long result = redisTemplate.execute(script, Collections.singletonList(redisKey),
                String.valueOf(windowSeconds), String.valueOf(threshold),
                String.valueOf(currentTime), uuid);
        return result != null &amp;&amp; result == 1;
    }

    /**
     * 令牌桶算法限流
     */
    private boolean tokenBucketLimit(String key, int capacity, int rate) {
        String redisKey = buildRedisKey(key, LimitAlgorithm.TOKEN_BUCKET);
        long currentTime = System.currentTimeMillis();
        DefaultRedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;(TOKEN_BUCKET_SCRIPT, Long.class);
        Long result = redisTemplate.execute(script, Collections.singletonList(redisKey),
                String.valueOf(capacity), String.valueOf(rate), String.valueOf(currentTime));
        return result != null &amp;&amp; result == 1;
    }

    /**
     * 漏桶算法限流（入桶逻辑）
     */
    private boolean leakyBucketLimit(String key, int capacity) {
        String redisKey = buildRedisKey(key, LimitAlgorithm.LEAKY_BUCKET);
        long currentTime = System.currentTimeMillis();
        DefaultRedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;(LEAKY_BUCKET_SCRIPT, Long.class);
        Long result = redisTemplate.execute(script, Collections.singletonList(redisKey),
                String.valueOf(capacity), String.valueOf(currentTime));
        return result != null &amp;&amp; result == 1;
    }

    /**
     * 本地降级限流（Guava RateLimiter）
     */
    private boolean localFallbackLimit(int rate) {
        // 基于 Guava RateLimiter 实现本地限流，key 为速率（简化处理）
        String localKey = &quot;local:limiter:&quot; + rate;
        GuavaRateLimiterHolder holder = GuavaRateLimiterHolder.getInstance();
        return holder.getRateLimiter(localKey, rate).tryAcquire();
    }

    /**
     * 构建 Redis 键（避免冲突）
     */
    private String buildRedisKey(String key, LimitAlgorithm algorithm) {
        return String.format(&quot;limiter:%s:%s&quot;, algorithm.name().toLowerCase(), key);
    }

    /**
     * Guava RateLimiter 单例持有者（避免重复创建）
     */
    private static class GuavaRateLimiterHolder {
        private static final GuavaRateLimiterHolder INSTANCE = new GuavaRateLimiterHolder();
        private final Map&lt;String, com.google.common.util.concurrent.RateLimiter&gt; rateLimiterMap = new HashMap&lt;&gt;();

        private GuavaRateLimiterHolder() {}

        public static GuavaRateLimiterHolder getInstance() {
            return INSTANCE;
        }

        public com.google.common.util.concurrent.RateLimiter getRateLimiter(String key, int rate) {
            return rateLimiterMap.computeIfAbsent(key, k -&gt; com.google.common.util.concurrent.RateLimiter.create(rate));
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br><span class="line-number">174</span><br><span class="line-number">175</span><br><span class="line-number">176</span><br><span class="line-number">177</span><br><span class="line-number">178</span><br><span class="line-number">179</span><br><span class="line-number">180</span><br><span class="line-number">181</span><br><span class="line-number">182</span><br><span class="line-number">183</span><br><span class="line-number">184</span><br><span class="line-number">185</span><br><span class="line-number">186</span><br><span class="line-number">187</span><br><span class="line-number">188</span><br><span class="line-number">189</span><br><span class="line-number">190</span><br><span class="line-number">191</span><br><span class="line-number">192</span><br><span class="line-number">193</span><br><span class="line-number">194</span><br><span class="line-number">195</span><br><span class="line-number">196</span><br><span class="line-number">197</span><br><span class="line-number">198</span><br><span class="line-number">199</span><br><span class="line-number">200</span><br><span class="line-number">201</span><br><span class="line-number">202</span><br><span class="line-number">203</span><br><span class="line-number">204</span><br><span class="line-number">205</span><br><span class="line-number">206</span><br><span class="line-number">207</span><br><span class="line-number">208</span><br><span class="line-number">209</span><br><span class="line-number">210</span><br><span class="line-number">211</span><br><span class="line-number">212</span><br><span class="line-number">213</span><br><span class="line-number">214</span><br><span class="line-number">215</span><br><span class="line-number">216</span><br><span class="line-number">217</span><br><span class="line-number">218</span><br><span class="line-number">219</span><br><span class="line-number">220</span><br><span class="line-number">221</span><br><span class="line-number">222</span><br><span class="line-number">223</span><br><span class="line-number">224</span><br><span class="line-number">225</span><br><span class="line-number">226</span><br><span class="line-number">227</span><br></div></div><h4 id="_4-aop-切面-注解驱动执行"><a href="#_4-aop-切面-注解驱动执行" class="header-anchor">#</a> 4. AOP 切面（注解驱动执行）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.DefaultParameterNameDiscoverer;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.lang.reflect.Method;

@Aspect
@Component
public class RedisLimitAspect {

    @Resource
    private RedisLimitFactory redisLimitFactory;

    @Value(&quot;${spring.redis-limiter.fallback-enabled:true}&quot;)
    private boolean fallbackEnabled;

    // SpEL 解析器
    private final SpelExpressionParser parser = new SpelExpressionParser();
    private final DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();

    /**
     * 切入点：标注 @RedisLimit 注解的方法
     */
    @Pointcut(&quot;@annotation(com.example.redis.limiter.RedisLimit)&quot;)
    public void redisLimitPointcut() {}

    /**
     * 环绕通知：执行限流判断
     */
    @Around(&quot;redisLimitPointcut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        RedisLimit annotation = method.getAnnotation(RedisLimit.class);

        // 解析限流键（支持 SpEL 表达式）
        String key = parseSpelKey(annotation.key(), method, joinPoint.getArgs());
        // 若未指定 key，默认用 &quot;类名:方法名&quot;
        if (key.isEmpty()) {
            key = method.getDeclaringClass().getName() + &quot;:&quot; + method.getName();
        }

        // 执行限流判断
        boolean allow = redisLimitFactory.doLimit(
                annotation.algorithm(),
                key,
                annotation.windowSeconds(),
                annotation.threshold(),
                annotation.bucketCapacity(),
                annotation.rate()
        );

        if (!allow) {
            // 限流时抛出异常，由全局异常处理器捕获
            throw new RuntimeException(annotation.message());
        }

        // 允许通过，执行原方法
        return joinPoint.proceed();
    }

    /**
     * 解析 SpEL 表达式，获取限流键
     */
    private String parseSpelKey(String spelKey, Method method, Object[] args) {
        if (spelKey.isEmpty()) {
            return &quot;&quot;;
        }

        // 构建 SpEL 上下文
        EvaluationContext context = new StandardEvaluationContext();
        String[] parameterNames = parameterNameDiscoverer.getParameterNames(method);
        if (parameterNames != null) {
            for (int i = 0; i &lt; parameterNames.length; i++) {
                context.setVariable(parameterNames[i], args[i]);
            }
        }

        // 解析 SpEL 表达式
        Expression expression = parser.parseExpression(spelKey);
        return expression.getValue(context, String.class);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br></div></div><h4 id="_5-全局异常处理器-统一返回限流结果"><a href="#_5-全局异常处理器-统一返回限流结果" class="header-anchor">#</a> 5. 全局异常处理器（统一返回限流结果）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(RuntimeException.class)
    @ResponseStatus(HttpStatus.TOO_MANY_REQUESTS)
    public Map&lt;String, Object&gt; handleLimitException(RuntimeException e) {
        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        result.put(&quot;code&quot;, 429);
        result.put(&quot;message&quot;, e.getMessage());
        result.put(&quot;success&quot;, false);
        return result;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="_3-4-接口集成示例-注解驱动-零侵入"><a href="#_3-4-接口集成示例-注解驱动-零侵入" class="header-anchor">#</a> 3.4 接口集成示例（注解驱动，零侵入）</h3> <h4 id="_1-普通接口限流-按接口粒度"><a href="#_1-普通接口限流-按接口粒度" class="header-anchor">#</a> 1. 普通接口限流（按接口粒度）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {

    /**
     * 普通接口限流：1 秒内最多允许 100 次请求（令牌桶算法）
     */
    @GetMapping(&quot;/api/test&quot;)
    @RedisLimit(
            key = &quot;/api/test&quot;,
            algorithm = LimitAlgorithm.TOKEN_BUCKET,
            windowSeconds = 1,
            threshold = 100,
            capacity = 100,
            rate = 100,
            message = &quot;接口请求过于频繁，请稍后再试&quot;
    )
    public String testLimit() {
        return &quot;请求成功&quot;;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h4 id="_2-用户粒度限流-按用户-id-接口"><a href="#_2-用户粒度限流-按用户-id-接口" class="header-anchor">#</a> 2. 用户粒度限流（按用户 ID + 接口）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class OrderController {

    /**
     * 用户粒度限流：每个用户 10 秒内最多允许 3 次下单（滑动窗口算法）
     * 限流键：user:1001:/api/order/create（通过 SpEL 表达式解析 userId）
     */
    @GetMapping(&quot;/api/order/create&quot;)
    @RedisLimit(
            key = &quot;'user:' + #userId + ':/api/order/create'&quot;,
            algorithm = LimitAlgorithm.SLIDING_WINDOW,
            windowSeconds = 10,
            threshold = 3,
            message = &quot;您下单过于频繁，请 10 秒后再试&quot;
    )
    public String createOrder(@RequestParam Long userId) {
        // 下单业务逻辑
        return &quot;下单成功&quot;;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h4 id="_3-秒杀场景限流-商品粒度-用户粒度双重防护"><a href="#_3-秒杀场景限流-商品粒度-用户粒度双重防护" class="header-anchor">#</a> 3. 秒杀场景限流（商品粒度+用户粒度双重防护）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class SeckillController {

    /**
     * 秒杀限流：商品粒度（1 秒 100 次）+ 用户粒度（10 秒 1 次）
     * 注：此处仅演示商品粒度，用户粒度可通过多注解或手动调用工厂实现
     */
    @GetMapping(&quot;/api/seckill/{goodsId}&quot;)
    @RedisLimit(
            key = &quot;'seckill:goods:' + #goodsId&quot;,
            algorithm = LimitAlgorithm.TOKEN_BUCKET,
            windowSeconds = 1,
            threshold = 100,
            capacity = 100,
            rate = 100,
            message = &quot;秒杀过于火爆，请稍后再试&quot;
    )
    public String seckill(@PathVariable Long goodsId, @RequestParam Long userId) {
        // 手动添加用户粒度限流（也可通过自定义组合注解优化）
        String userKey = &quot;user:&quot; + userId + &quot;:seckill:&quot; + goodsId;
        boolean userAllow = redisLimitFactory.doLimit(
                LimitAlgorithm.FIXED_WINDOW,
                userKey,
                10, // 10 秒窗口
                1,  // 1 次请求
                0,  // 无关参数
                0   // 无关参数
        );
        if (!userAllow) {
            throw new RuntimeException(&quot;您已参与过该商品秒杀，请勿重复提交&quot;);
        }

        // 秒杀业务逻辑（扣减库存、创建订单）
        return &quot;秒杀成功&quot;;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h2 id="四、生产级优化-高并发、高可用、可观测"><a href="#四、生产级优化-高并发、高可用、可观测" class="header-anchor">#</a> 四、生产级优化：高并发、高可用、可观测</h2> <h3 id="_4-1-高并发优化-突破单机-redis-瓶颈"><a href="#_4-1-高并发优化-突破单机-redis-瓶颈" class="header-anchor">#</a> 4.1 高并发优化：突破单机 Redis 瓶颈</h3> <h4 id="_1-redis-cluster-分片策略"><a href="#_1-redis-cluster-分片策略" class="header-anchor">#</a> 1. Redis Cluster 分片策略</h4> <ul><li>问题：单 Redis 节点的 QPS 上限约 10 万 ~ 100 万，秒杀等场景可能压垮节点；</li> <li>解决方案：按限流键 <code>key</code> 哈希分片，将不同 <code>key</code> 的限流数据分散到 Redis Cluster 的多个节点；</li> <li>实现：利用 Redis Cluster 的哈希槽机制，无需手动分片（Redis 自动将 <code>key</code> 映射到对应哈希槽）；</li> <li>注意：同一 <code>key</code> 的限流数据会落在同一节点，保证计数准确。</li></ul> <h4 id="_2-本地缓存预热-减少-redis-访问"><a href="#_2-本地缓存预热-减少-redis-访问" class="header-anchor">#</a> 2. 本地缓存预热（减少 Redis 访问）</h4> <ul><li>问题：高频请求（如每秒 10 万+）会频繁访问 Redis，增加网络 IO 开销；</li> <li>解决方案：在应用本地缓存“限流状态”，如本地缓存 100ms，期间不访问 Redis；</li> <li>实现：在 <code>RedisLimitFactory</code> 中加入本地缓存（如 Caffeine），缓存限流键的“是否已限流”状态；</li> <li>注意：本地缓存时长需远小于 Redis 窗口时长（如 100ms vs 1 秒），避免数据不一致。</li></ul> <h4 id="_3-lua-脚本优化-减少网络往返"><a href="#_3-lua-脚本优化-减少网络往返" class="header-anchor">#</a> 3. Lua 脚本优化（减少网络往返）</h4> <ul><li>问题：分步执行 Redis 命令会增加网络往返次数，高并发下性能下降；</li> <li>解决方案：所有算法均通过 Lua 脚本原子化执行，将多个命令合并为 1 次网络请求；</li> <li>优化点：Lua 脚本避免复杂逻辑（如循环、条件判断过多），防止脚本超时（Redis 默认脚本超时时间 5 秒）。</li></ul> <h3 id="_4-2-高可用优化-避免-redis-成为单点故障"><a href="#_4-2-高可用优化-避免-redis-成为单点故障" class="header-anchor">#</a> 4.2 高可用优化：避免 Redis 成为单点故障</h3> <h4 id="_1-降级策略完善"><a href="#_1-降级策略完善" class="header-anchor">#</a> 1. 降级策略完善</h4> <ul><li>Redis 宕机/网络超时：降级为本地限流（Guava RateLimiter），保证服务基本可用；</li> <li>降级开关：通过配置中心（如 Nacos）动态控制是否启用降级，便于故障恢复；</li> <li>限流熔断：当 Redis 异常率超过阈值（如 50%），自动熔断 Redis 限流，切换为本地限流。</li></ul> <h4 id="_2-redis-集群高可用部署"><a href="#_2-redis-集群高可用部署" class="header-anchor">#</a> 2. Redis 集群高可用部署</h4> <ul><li>部署架构：Redis Cluster（3 主 3 从）+ 哨兵模式，确保节点故障时自动切换；</li> <li>数据持久化：开启 RDB + AOF 混合持久化，避免 Redis 重启后限流数据丢失；</li> <li>连接池优化：合理配置 Redis 连接池参数（最大连接数、空闲连接数），避免连接耗尽。</li></ul> <h4 id="_3-限流键过期时间优化"><a href="#_3-限流键过期时间优化" class="header-anchor">#</a> 3. 限流键过期时间优化</h4> <ul><li>问题：长期无请求的限流键会占用 Redis 存储；</li> <li>解决方案：所有限流键均设置过期时间（如窗口时长 + 1 秒、10 分钟），避免垃圾数据堆积；</li> <li>优化点：对大窗口限流（如 1 天），定期执行 <code>SCAN</code> 命令清理过期键，避免过期键过多影响性能。</li></ul> <h3 id="_4-3-可观测性优化-监控告警体系"><a href="#_4-3-可观测性优化-监控告警体系" class="header-anchor">#</a> 4.3 可观测性优化：监控告警体系</h3> <h4 id="_1-限流指标监控-接入-prometheus-grafana"><a href="#_1-限流指标监控-接入-prometheus-grafana" class="header-anchor">#</a> 1. 限流指标监控（接入 Prometheus+Grafana）</h4> <ul><li>核心指标：
<ul><li>限流总请求数、通过请求数、被拒绝请求数；</li> <li>各限流键的 QPS、拒绝率；</li> <li>Redis 限流响应时间、异常率；</li></ul></li> <li>实现：在 <code>RedisLimitFactory</code> 中埋点，通过 Prometheus 客户端暴露指标，Grafana 配置仪表盘。</li></ul> <h4 id="_2-告警配置"><a href="#_2-告警配置" class="header-anchor">#</a> 2. 告警配置</h4> <ul><li>告警阈值：拒绝率 &gt; 10%、Redis 异常率 &gt; 5%、限流响应时间 &gt; 5ms；</li> <li>告警渠道：短信、邮件、钉钉/企业微信，确保及时响应。</li></ul> <h4 id="_3-日志打印"><a href="#_3-日志打印" class="header-anchor">#</a> 3. 日志打印</h4> <ul><li>打印内容：限流键、算法类型、是否通过、当前计数器/令牌数；</li> <li>日志级别：正常通过的请求用 <code>INFO</code> 级，被限流的请求用 <code>WARN</code> 级，Redis 异常用 <code>ERROR</code> 级；</li> <li>采样打印：高并发场景下，对限流通过的请求进行采样打印（如 1% 采样率），避免日志刷屏。</li></ul> <h3 id="_4-4-可扩展性优化-动态调整与多场景适配"><a href="#_4-4-可扩展性优化-动态调整与多场景适配" class="header-anchor">#</a> 4.4 可扩展性优化：动态调整与多场景适配</h3> <h4 id="_1-动态阈值调整"><a href="#_1-动态阈值调整" class="header-anchor">#</a> 1. 动态阈值调整</h4> <ul><li>问题：固定阈值无法适配流量波动（如促销期间需临时提高阈值）；</li> <li>解决方案：将限流阈值存储到 Redis/配置中心，实时读取，支持动态调整；</li> <li>实现：修改 <code>@RedisLimit</code> 注解，支持阈值从配置中心获取（如 <code>threshold = &quot;${limiter.threshold.api.test:100}&quot;</code>）。</li></ul> <h4 id="_2-多租户限流"><a href="#_2-多租户限流" class="header-anchor">#</a> 2. 多租户限流</h4> <ul><li>问题：多租户系统中，需为不同租户配置不同限流阈值；</li> <li>解决方案：限流键中加入租户标识（如 <code>tenant:1001:api:test</code>），为每个租户配置独立阈值；</li> <li>实现：通过 SpEL 表达式解析租户 ID（如 <code>key = &quot;'tenant:' + #tenantId + ':' + '/api/test'&quot;</code>）。</li></ul> <h4 id="_3-流量染色与灰度限流"><a href="#_3-流量染色与灰度限流" class="header-anchor">#</a> 3. 流量染色与灰度限流</h4> <ul><li>场景：新功能灰度发布时，需对灰度流量单独限流；</li> <li>解决方案：通过流量染色（如请求头 <code>X-Gray-Traffic: true</code>），解析染色标识后使用独立限流键；</li> <li>实现：在 <code>RedisLimitAspect</code> 中解析请求头，拼接灰度标识到限流键。</li></ul> <h2 id="五、生产环境踩坑指南-10-个致命坑点"><a href="#五、生产环境踩坑指南-10-个致命坑点" class="header-anchor">#</a> 五、生产环境踩坑指南（10 个致命坑点）</h2> <h3 id="_5-1-坑-1-限流键冲突"><a href="#_5-1-坑-1-限流键冲突" class="header-anchor">#</a> 5.1 坑 1：限流键冲突</h3> <ul><li>现象：不同业务的限流键重复（如都用 <code>test</code>），导致计数混乱；</li> <li>原因：未给限流键加业务前缀；</li> <li>解决方案：统一用 <code>limiter:{algorithm}:{biz}:{key}</code> 格式，如 <code>limiter:token:seckill:goods:10086</code>。</li></ul> <h3 id="_5-2-坑-2-临界问题导致限流失效"><a href="#_5-2-坑-2-临界问题导致限流失效" class="header-anchor">#</a> 5.2 坑 2：临界问题导致限流失效</h3> <ul><li>现象：固定窗口算法在窗口切换时出现“双倍流量”，突破阈值；</li> <li>原因：固定窗口的天生缺陷；</li> <li>解决方案：对核心场景改用滑动窗口/令牌桶算法，或在窗口切换时增加缓冲（如窗口重叠 100ms）。</li></ul> <h3 id="_5-3-坑-3-lua-脚本超时"><a href="#_5-3-坑-3-lua-脚本超时" class="header-anchor">#</a> 5.3 坑 3：Lua 脚本超时</h3> <ul><li>现象：高并发下 Lua 脚本执行超时，Redis 抛出 <code>BUSY</code> 错误；</li> <li>原因：脚本逻辑复杂（如循环、大量 <code>ZREMRANGEBYSCORE</code> 操作）；</li> <li>解决方案：简化 Lua 脚本逻辑，避免循环；对滑动窗口算法，合理拆分小窗口数量（如 1 秒拆 10 个）。</li></ul> <h3 id="_5-4-坑-4-redis-大-key-问题"><a href="#_5-4-坑-4-redis-大-key-问题" class="header-anchor">#</a> 5.4 坑 4：Redis 大 Key 问题</h3> <ul><li>现象：滑动窗口算法的 ZSET 存储过多请求时间戳（如每秒 1 万次请求，1 秒窗口存 1 万个元素），成为大 Key；</li> <li>原因：窗口时长过长、请求量过大；</li> <li>解决方案：缩短窗口时长、增加小窗口数量；定期清理 ZSET 中的过期元素；对高频请求启用本地缓存预热。</li></ul> <h3 id="_5-5-坑-5-分布式场景下全局一致性问题"><a href="#_5-5-坑-5-分布式场景下全局一致性问题" class="header-anchor">#</a> 5.5 坑 5：分布式场景下全局一致性问题</h3> <ul><li>现象：Redis Cluster 分片后，同一限流键落在不同节点，总请求数突破阈值；</li> <li>原因：限流键哈希分片错误，同一 <code>key</code> 被分配到不同节点；</li> <li>解决方案：确保限流键的哈希计算一致（如使用 Redis Cluster 原生哈希槽机制）；对全局限流（如全系统 1 秒 1 万次），使用 Redis 主从架构（单节点计数）。</li></ul> <h3 id="_5-6-坑-6-本地缓存与-redis-数据不一致"><a href="#_5-6-坑-6-本地缓存与-redis-数据不一致" class="header-anchor">#</a> 5.6 坑 6：本地缓存与 Redis 数据不一致</h3> <ul><li>现象：本地缓存了“已限流”状态，Redis 计数器已重置，但本地仍拒绝请求；</li> <li>原因：本地缓存时长过长；</li> <li>解决方案：本地缓存时长设为 Redis 窗口时长的 1/10（如 1 秒窗口缓存 100ms）；缓存过期时间采用随机值，避免缓存雪崩。</li></ul> <h3 id="_5-7-坑-7-漏桶算法的-漏水-任务阻塞"><a href="#_5-7-坑-7-漏桶算法的-漏水-任务阻塞" class="header-anchor">#</a> 5.7 坑 7：漏桶算法的“漏水”任务阻塞</h3> <ul><li>现象：漏桶算法的定时任务阻塞，导致请求堆积在桶中，无法处理；</li> <li>原因：定时任务执行时间过长（如处理请求的业务逻辑耗时久）；</li> <li>解决方案：将“漏水”逻辑与业务逻辑解耦，通过消息队列异步处理请求；定时任务仅负责弹出请求，不处理业务逻辑。</li></ul> <h3 id="_5-8-坑-8-令牌桶算法的时间差计算误差"><a href="#_5-8-坑-8-令牌桶算法的时间差计算误差" class="header-anchor">#</a> 5.8 坑 8：令牌桶算法的时间差计算误差</h3> <ul><li>现象：高并发下，令牌桶的令牌填充速率与预期不符；</li> <li>原因：时间差计算采用毫秒级，高并发下多次请求的时间差过小，导致令牌填充不及时；</li> <li>解决方案：改用微秒级时间戳；优化令牌填充逻辑，允许批量填充令牌（如一次填充多个）。</li></ul> <h3 id="_5-9-坑-9-redis-连接池参数不合理"><a href="#_5-9-坑-9-redis-连接池参数不合理" class="header-anchor">#</a> 5.9 坑 9：Redis 连接池参数不合理</h3> <ul><li>现象：高并发下，出现 <code>Could not get a resource from the pool</code> 错误；</li> <li>原因：最大连接数设置过小，无法满足并发需求；</li> <li>解决方案：通过压测确定合理的最大连接数（如每秒 10 万次请求，最大连接数设为 64）；监控连接池状态，动态调整参数。</li></ul> <h3 id="_5-10-坑-10-未处理-redis-主从切换导致的限流数据丢失"><a href="#_5-10-坑-10-未处理-redis-主从切换导致的限流数据丢失" class="header-anchor">#</a> 5.10 坑 10：未处理 Redis 主从切换导致的限流数据丢失</h3> <ul><li>现象：Redis 主从切换后，限流计数器/令牌桶状态丢失，导致限流失效；</li> <li>原因：主从复制是异步的，切换时从库可能未同步最新的限流数据；</li> <li>解决方案：开启 Redis 持久化（RDB+AOF）；主从切换后，对限流键进行初始化（如令牌桶重置为初始容量）；对核心场景，采用 Redis Cluster 避免单主节点依赖。</li></ul> <h2 id="六、行业最佳实践总结"><a href="#六、行业最佳实践总结" class="header-anchor">#</a> 六、行业最佳实践总结</h2> <h3 id="_6-1-算法选型最佳实践"><a href="#_6-1-算法选型最佳实践" class="header-anchor">#</a> 6.1 算法选型最佳实践</h3> <ul><li>普通接口、非核心业务：固定窗口计数器（简单、高性能）；</li> <li>核心 API、商品详情页：滑动窗口计数器（精准、无临界问题）；</li> <li>数据库写入、第三方 API 调用：漏桶算法（严格控制输出速率）；</li> <li>秒杀、抢购、高并发核心业务：令牌桶算法（抗突发、流量平滑）。</li></ul> <h3 id="_6-2-限流策略组合最佳实践"><a href="#_6-2-限流策略组合最佳实践" class="header-anchor">#</a> 6.2 限流策略组合最佳实践</h3> <ul><li>多层限流：网关层（Nginx）限流 + 应用层（Redis）限流 + 本地限流（降级），形成防护体系；</li> <li>多粒度限流：商品粒度 + 用户粒度 + IP 粒度，多重防护（如秒杀场景）；</li> <li>流量削峰：结合消息队列，将突发流量缓存到队列，异步处理，与限流配合使用。</li></ul> <h3 id="_6-3-阈值调优最佳实践"><a href="#_6-3-阈值调优最佳实践" class="header-anchor">#</a> 6.3 阈值调优最佳实践</h3> <ul><li>压测确定基准：通过压测获取服务的最大承载 QPS，阈值设为基准的 80%；</li> <li>动态调整：根据流量波动（如促销、节假日）动态调整阈值；</li> <li>预留缓冲：为核心业务预留 20%~30% 的缓冲阈值，避免突发流量压垮服务。</li></ul> <h2 id="七、总结与展望"><a href="#七、总结与展望" class="header-anchor">#</a> 七、总结与展望</h2> <p>Redis 限流的核心价值，在于用高性能、分布式的方式实现流量的精细化治理，而非简单“拒绝请求”。其设计哲学是“先保系统稳定，再谈用户体验”——通过科学的算法选择、架构设计和优化手段，在流量洪峰来临时，确保核心业务可用、非核心业务降级，最终实现系统的稳定性与用户体验的平衡。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/tavio-zhang/blog/edit/master/docs/《Redis》笔记/7.Redis限流.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/tags/?tag=Redis%E9%99%90%E6%B5%81" title="标签">#Redis限流</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2026/01/21, 19:29:14</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/d2662c/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Redis大Key与热Key</div></a> <a href="/pages/aeefc4/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Redis IO多路复用</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/d2662c/" class="prev">Redis大Key与热Key</a></span> <span class="next"><a href="/pages/aeefc4/">Redis IO多路复用</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/942d4b/"><div>
            订单超时取消
            <!----></div></a> <span class="date">01-21</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/87b303/"><div>
            双 Token 登录
            <!----></div></a> <span class="date">01-21</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/a3f3fd/"><div>
            长短链接跳转
            <!----></div></a> <span class="date">01-21</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:taviozhang@gmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/tavio-zhang" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.c6ba13aa.js" defer></script><script src="/assets/js/2.8d9f533d.js" defer></script><script src="/assets/js/74.af7973c7.js" defer></script>
  </body>
</html>
