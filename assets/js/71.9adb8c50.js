(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{426:function(s,a,e){"use strict";e.r(a);var n=e(8),t=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("在分布式系统中，多个独立服务或进程往往需要共享资源（如库存、订单、分布式任务等）。由于分布式环境的异步性和网络不可靠性，单纯的本地锁（如Java的"),a("code",[s._v("synchronized")]),s._v("、"),a("code",[s._v("ReentrantLock")]),s._v("）无法跨节点生效，此时需要"),a("strong",[s._v("分布式锁")]),s._v("来保证跨进程、跨机器的并发安全。Redis凭借高性能、低延迟、支持原子操作等特性，成为实现分布式锁的主流选择。")]),s._v(" "),a("h2",{attrs:{id:"一、分布式锁的核心特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、分布式锁的核心特征"}},[s._v("#")]),s._v(" 一、分布式锁的核心特征")]),s._v(" "),a("p",[s._v("一个可靠的分布式锁是分布式系统并发安全的基础，其必须满足以下核心条件，否则可能导致业务数据不一致、死锁等严重问题：")]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("特征")]),s._v(" "),a("th",[s._v("含义")]),s._v(" "),a("th",[s._v("重要性")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("互斥性")]),s._v(" "),a("td",[s._v("同一时刻只能有一个线程持有锁，确保共享资源不会被并发修改")]),s._v(" "),a("td",[s._v("核心条件，直接决定并发安全")])]),s._v(" "),a("tr",[a("td",[s._v("安全性")]),s._v(" "),a("td",[s._v("锁只能被持有者释放，防止其他线程误删不属于自己的锁")]),s._v(" "),a("td",[s._v("避免锁被恶意释放导致互斥失效")])]),s._v(" "),a("tr",[a("td",[s._v("可用性")]),s._v(" "),a("td",[s._v("锁服务需高可用，避免单点故障导致整个锁机制崩溃")]),s._v(" "),a("td",[s._v("保证分布式系统的稳定性")])]),s._v(" "),a("tr",[a("td",[s._v("原子性")]),s._v(" "),a("td",[s._v("锁的获取、释放操作必须是原子化的，避免中间状态（如“获取锁但未设置过期时间”）")]),s._v(" "),a("td",[s._v("防止因操作拆分导致的逻辑漏洞")])]),s._v(" "),a("tr",[a("td",[s._v("过期自动释放")]),s._v(" "),a("td",[s._v("当持有锁的线程崩溃时，锁能自动过期释放，避免永久死锁")]),s._v(" "),a("td",[s._v("解决线程异常导致的资源独占问题")])]),s._v(" "),a("tr",[a("td",[s._v("可重入性（可选）")]),s._v(" "),a("td",[s._v("同一线程可多次获取同一把锁（如递归调用、嵌套业务）")]),s._v(" "),a("td",[s._v("提升锁的灵活性，适应复杂业务场景")])]),s._v(" "),a("tr",[a("td",[s._v("公平性（可选）")]),s._v(" "),a("td",[s._v("按请求顺序分配锁，避免线程长期饥饿")]),s._v(" "),a("td",[s._v("特定场景下需保证（如任务调度）")])])])]),s._v(" "),a("h2",{attrs:{id:"二、redis分布式锁的基础实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、redis分布式锁的基础实现"}},[s._v("#")]),s._v(" 二、Redis分布式锁的基础实现")]),s._v(" "),a("p",[s._v("Redis分布式锁的核心是通过原子命令实现“获取锁”和“释放锁”的原子操作。")]),s._v(" "),a("h3",{attrs:{id:"_2-1-早期实现的缺陷-setnx-expire"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-早期实现的缺陷-setnx-expire"}},[s._v("#")]),s._v(" 2.1 早期实现的缺陷：SETNX + EXPIRE")]),s._v(" "),a("p",[s._v("在Redis 2.6之前，开发者通常使用"),a("code",[s._v("SETNX")]),s._v("（Set If Not Exists）命令获取锁，再用"),a("code",[s._v("EXPIRE")]),s._v("设置过期时间，代码逻辑如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# 步骤1：获取锁（若key不存在则设置，返回1表示成功，0表示失败）\nSETNX lock:key unique-value\n# 步骤2：设置过期时间（避免死锁）\nEXPIRE lock:key 30\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[a("strong",[s._v("缺陷分析")]),s._v("："),a("br"),s._v(" "),a("code",[s._v("SETNX")]),s._v("和"),a("code",[s._v("EXPIRE")]),s._v("是两个独立命令，若线程在执行完"),a("code",[s._v("SETNX")]),s._v("后、"),a("code",[s._v("EXPIRE")]),s._v("前崩溃（如节点宕机），会导致锁没有过期时间，永久被持有，引发死锁。因此，这种方案因非原子性被淘汰。")]),s._v(" "),a("h3",{attrs:{id:"_2-2-优化实现-set命令的原子性方案-redis-2-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-优化实现-set命令的原子性方案-redis-2-6"}},[s._v("#")]),s._v(" 2.2 优化实现：SET命令的原子性方案（Redis 2.6+）")]),s._v(" "),a("p",[s._v("Redis 2.6版本为"),a("code",[s._v("SET")]),s._v("命令增加了"),a("code",[s._v("NX")]),s._v("（Not Exists）和"),a("code",[s._v("EX")]),s._v("（Expire）等扩展参数，支持“不存在则设置+过期时间”的原子操作，彻底解决了早期方案的非原子性问题。")]),s._v(" "),a("h4",{attrs:{id:"核心命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心命令"}},[s._v("#")]),s._v(" 核心命令")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('# 获取锁：原子性操作\n# key=锁名称（如lock:stock:1001，标识商品1001的库存锁）\n# value=唯一标识（如UUID，用于释放锁时校验持有者）\n# NX=仅当key不存在时设置（保证互斥性）\n# EX=设置过期时间（秒），避免死锁\nSET lock:key [unique-value] NX EX 30\n\n# 释放锁：需先校验持有者，再删除（通过Lua脚本保证原子性）\nif redis.call("GET", "lock:key") == "unique-value" then\n    return redis.call("DEL", "lock:key")  # 持有者正确，释放锁\nelse\n    return 0  # 持有者错误，不做操作\nend\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("h4",{attrs:{id:"java代码实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java代码实现"}},[s._v("#")]),s._v(" Java代码实现")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('public class RedisLock {\n    private final RedisTemplate<String, String> redisTemplate;\n\n    public RedisLock(RedisTemplate<String, String> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    // 获取锁：返回唯一标识（用于释放锁），null表示获取失败\n    public String tryLock(String lockKey, long expireSeconds) {\n        // 生成唯一标识（避免多线程/机器的value冲突）\n        String uniqueValue = UUID.randomUUID().toString();\n        // 执行SET命令：原子性获取锁并设置过期时间\n        Boolean success = redisTemplate.opsForValue()\n                .setIfAbsent(lockKey, uniqueValue, expireSeconds, TimeUnit.SECONDS);\n        return success != null && success ? uniqueValue : null;\n    }\n\n    // 释放锁：返回true表示释放成功\n    public boolean releaseLock(String lockKey, String uniqueValue) {\n        // Lua脚本：先校验value，再删除（原子操作）\n        String luaScript = """\n                if redis.call(\'get\', KEYS[1]) == ARGV[1] then\n                    return redis.call(\'del\', KEYS[1])\n                else\n                    return 0\n                end\n                """;\n        // 执行Lua脚本\n        Long result = redisTemplate.execute(\n                new DefaultRedisScript<>(luaScript, Long.class),\n                Collections.singletonList(lockKey),\n                uniqueValue\n        );\n        return result != null && result > 0;\n    }\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br")])]),a("h4",{attrs:{id:"关键参数说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关键参数说明"}},[s._v("#")]),s._v(" 关键参数说明")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("NX")]),s._v("：保证只有当锁不存在时才能获取成功，是实现互斥性的核心。")]),s._v(" "),a("li",[a("code",[s._v("EX")]),s._v("：强制设置过期时间，即使线程崩溃，锁也会在过期后自动释放，避免死锁。")]),s._v(" "),a("li",[a("code",[s._v("unique-value")]),s._v("：每个线程/请求的唯一标识（如UUID+线程ID），用于释放锁时校验“当前线程是否为锁的持有者”，防止误删其他线程的锁（例如：线程A的锁过期后，线程B获取到锁，此时线程A执行完任务，若没有校验直接删除，会误删线程B的锁）。")])]),s._v(" "),a("h2",{attrs:{id:"三、基础实现的核心缺陷"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、基础实现的核心缺陷"}},[s._v("#")]),s._v(" 三、基础实现的核心缺陷")]),s._v(" "),a("p",[s._v("基础实现满足了互斥性、安全性、原子性和过期释放，但在复杂分布式场景下仍存在以下关键问题：")]),s._v(" "),a("h3",{attrs:{id:"_3-1-锁超时问题-任务执行时间-锁过期时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-锁超时问题-任务执行时间-锁过期时间"}},[s._v("#")]),s._v(" 3.1 锁超时问题：任务执行时间 > 锁过期时间")]),s._v(" "),a("p",[a("strong",[s._v("场景示例")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("线程A获取锁，设置过期时间30秒，但业务逻辑执行了40秒（如网络延迟、任务复杂）。")]),s._v(" "),a("li",[s._v("30秒后锁自动释放，线程B此时获取到锁，开始执行任务。")]),s._v(" "),a("li",[s._v("线程A执行完任务（第40秒），通过释放锁逻辑删除了线程B持有的锁。")]),s._v(" "),a("li",[s._v("最终导致线程B的锁被误删，可能有更多线程获取到锁，引发并发安全问题（如库存超卖）。")])]),s._v(" "),a("p",[a("strong",[s._v("本质原因")]),s._v("：锁的过期时间是固定的，无法动态适应业务执行时间的波动。")]),s._v(" "),a("h3",{attrs:{id:"_3-2-不可重入问题-同一线程无法多次获取同一把锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-不可重入问题-同一线程无法多次获取同一把锁"}},[s._v("#")]),s._v(" 3.2 不可重入问题：同一线程无法多次获取同一把锁")]),s._v(" "),a("p",[a("strong",[s._v("场景示例")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("线程A获取锁后，在业务逻辑中需要递归调用或嵌套调用另一个需要同一把锁的方法。")]),s._v(" "),a("li",[s._v("此时线程A再次请求获取锁时，会因“锁已存在”被拒绝，导致死锁（自己等自己释放锁）。")])]),s._v(" "),a("p",[a("strong",[s._v("本质原因")]),s._v("：基础实现未记录“锁的持有者”和“重入次数”，无法识别同一线程的重复请求。")]),s._v(" "),a("h3",{attrs:{id:"_3-3-主从切换-集群脑裂问题-锁数据丢失"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-主从切换-集群脑裂问题-锁数据丢失"}},[s._v("#")]),s._v(" 3.3 主从切换/集群脑裂问题：锁数据丢失")]),s._v(" "),a("p",[a("strong",[s._v("场景示例")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("Redis采用主从架构（主节点M+从节点S），锁数据存储在主节点M。")]),s._v(" "),a("li",[s._v("线程A在M上获取锁成功，但数据尚未同步到S时，M突然宕机。")]),s._v(" "),a("li",[s._v("哨兵将S升级为新主节点，此时新主节点S中没有线程A的锁数据。")]),s._v(" "),a("li",[s._v("线程B可以在新主节点S上获取到同一把锁，导致多个线程同时持有锁。")])]),s._v(" "),a("p",[a("strong",[s._v("本质原因")]),s._v("：主从复制是异步的，主节点宕机可能导致锁数据未同步到从节点，引发锁丢失。")]),s._v(" "),a("h2",{attrs:{id:"四、redis分布式锁的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、redis分布式锁的优化"}},[s._v("#")]),s._v(" 四、Redis分布式锁的优化")]),s._v(" "),a("p",[s._v("针对基础实现的缺陷，Redis提出了三类优化方案，分别解决锁超时、可重入性和高可用问题。")]),s._v(" "),a("h3",{attrs:{id:"_4-1-优化1-锁续约-看门狗机制-解决锁超时问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-优化1-锁续约-看门狗机制-解决锁超时问题"}},[s._v("#")]),s._v(" 4.1 优化1：锁续约（看门狗机制）——解决锁超时问题")]),s._v(" "),a("p",[a("strong",[s._v("核心思路")]),s._v("：线程获取锁后，启动一个后台“看门狗”线程，定期延长锁的过期时间，确保锁的有效期始终覆盖业务执行时间，直到任务完成。")]),s._v(" "),a("h4",{attrs:{id:"实现逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现逻辑"}},[s._v("#")]),s._v(" 实现逻辑")]),s._v(" "),a("ol",[a("li",[s._v("线程获取锁时，设置初始过期时间（如30秒）。")]),s._v(" "),a("li",[s._v("启动看门狗线程（守护线程，与业务线程同生命周期），每隔“过期时间/3”（如10秒）执行一次"),a("code",[s._v("EXPIRE lock:key 30")]),s._v("，延长锁的过期时间。")]),s._v(" "),a("li",[s._v("业务任务执行完成后，手动释放锁，并停止看门狗线程。")]),s._v(" "),a("li",[s._v("若线程崩溃，看门狗线程也会终止，锁会在初始过期时间后自动释放。")])]),s._v(" "),a("h4",{attrs:{id:"主流框架实现-redisson的看门狗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主流框架实现-redisson的看门狗"}},[s._v("#")]),s._v(" 主流框架实现：Redisson的看门狗")]),s._v(" "),a("p",[s._v("Redisson是Redis的Java客户端框架，内置了完善的看门狗机制，无需手动实现：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('public class RedissonLockExample {\n    private final RedissonClient redissonClient;\n\n    public RedissonLockExample(RedissonClient redissonClient) {\n        this.redissonClient = redissonClient;\n    }\n\n    public void doBusiness(String lockKey) {\n        // 获取锁对象\n        RLock lock = redissonClient.getLock(lockKey);\n        try {\n            // 尝试获取锁：最多等待5秒，10秒后自动过期（看门狗会动态续约）\n            boolean locked = lock.tryLock(5, 10, TimeUnit.SECONDS);\n            if (locked) {\n                // 执行业务逻辑（即使执行时间超过10秒，看门狗会自动续约）\n                System.out.println("获取锁成功，执行业务...");\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            // 释放锁（仅当当前线程持有锁时）\n            if (lock.isHeldByCurrentThread()) {\n                lock.unlock();\n            }\n        }\n    }\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br")])]),a("p",[a("strong",[s._v("Redisson看门狗细节")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("默认初始过期时间为30秒，续约间隔为10秒（30/3）。")]),s._v(" "),a("li",[s._v("若业务线程正常执行，看门狗会无限续约；若线程崩溃，看门狗终止，锁在30秒后释放。")])]),s._v(" "),a("h3",{attrs:{id:"_4-2-优化2-可重入锁设计-解决重入问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-优化2-可重入锁设计-解决重入问题"}},[s._v("#")]),s._v(" 4.2 优化2：可重入锁设计——解决重入问题")]),s._v(" "),a("p",[a("strong",[s._v("核心思路")]),s._v("：通过Redis的Hash结构存储锁的“持有者标识”和“重入次数”，实现同一线程多次获取锁的支持。")]),s._v(" "),a("h4",{attrs:{id:"数据结构设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构设计"}},[s._v("#")]),s._v(" 数据结构设计")]),s._v(" "),a("p",[s._v("使用Hash类型存储锁信息，结构如下：")]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("Key")]),s._v(" "),a("th",[s._v("Hash key")]),s._v(" "),a("th",[s._v("Hash Value")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("lock:test")]),s._v(" "),a("td",[s._v("节点ID:线程ID")]),s._v(" "),a("td",[s._v("1（首次加锁）/2（重入1次）")])])])]),s._v(" "),a("ul",[a("li",[s._v("节点ID：Redisson客户端的唯一标识，避免多机器线程ID冲突")]),s._v(" "),a("li",[s._v("重入次数：记录同一线程获取锁的次数，解锁时递减，减至0才删除锁")])]),s._v(" "),a("h4",{attrs:{id:"核心逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心逻辑"}},[s._v("#")]),s._v(" 核心逻辑")]),s._v(" "),a("ul",[a("li",[a("p",[a("strong",[s._v("获取锁")]),s._v("：")]),s._v(" "),a("ol",[a("li",[s._v("若锁不存在，创建Hash结构，设置重入次数为1，同时设置过期时间。")]),s._v(" "),a("li",[s._v("若锁已存在且持有者是当前线程，重入次数+1，并延长过期时间。")]),s._v(" "),a("li",[s._v("若锁已存在且持有者是其他线程，获取失败。")])])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("释放锁")]),s._v("：")]),s._v(" "),a("ol",[a("li",[s._v("若持有者是当前线程，重入次数-1。")]),s._v(" "),a("li",[s._v("若重入次数减为0，删除锁（释放资源）。")]),s._v(" "),a("li",[s._v("若重入次数>0，仅延长过期时间（仍持有锁）。")])])])]),s._v(" "),a("h4",{attrs:{id:"redisson可重入锁的lua实现-核心逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redisson可重入锁的lua实现-核心逻辑"}},[s._v("#")]),s._v(" Redisson可重入锁的Lua实现（核心逻辑）")]),s._v(" "),a("p",[s._v("获取锁的Lua脚本（简化版）：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("-- KEYS[1] = lock:key\n-- ARGV[1] = 持有者标识（node:thread）\n-- ARGV[2] = 过期时间（毫秒）\nif redis.call('exists', KEYS[1]) == 0 then\n    -- 锁不存在，创建并设置重入次数1\n    redis.call('hset', KEYS[1], ARGV[1], 1)\n    redis.call('pexpire', KEYS[1], ARGV[2])\n    return 1  -- 获取成功\nend\nif redis.call('hexists', KEYS[1], ARGV[1]) == 1 then\n    -- 锁存在且持有者是当前线程，重入次数+1\n    redis.call('hincrby', KEYS[1], ARGV[1], 1)\n    redis.call('pexpire', KEYS[1], ARGV[2])\n    return 1  -- 获取成功\nend\nreturn 0  -- 其他线程持有锁，获取失败\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("释放锁的Lua脚本（简化版）：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("-- KEYS[1] = lock:key\n-- ARGV[1] = 持有者标识（node:thread）\nif redis.call('hexists', KEYS[1], ARGV[1]) == 0 then\n    return 0  -- 不是持有者，无法释放\nend\n-- 重入次数-1\nlocal count = redis.call('hincrby', KEYS[1], ARGV[1], -1)\nif count > 0 then\n    -- 重入次数仍>0，延长过期时间\n    redis.call('pexpire', KEYS[1], ARGV[2])\n    return 1\nelse\n    -- 重入次数=0，删除锁\n    redis.call('del', KEYS[1])\n    return 1\nend\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("h3",{attrs:{id:"_4-3-优化3-redlock算法-解决主从切换-集群脑裂问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-优化3-redlock算法-解决主从切换-集群脑裂问题"}},[s._v("#")]),s._v(" 4.3 优化3：Redlock算法——解决主从切换/集群脑裂问题")]),s._v(" "),a("p",[s._v("基础实现和可重入锁依赖单节点或主从架构，存在单点故障风险。Redis提出的"),a("strong",[s._v("Redlock算法")]),s._v("，通过多个独立Redis节点（无主从关系）实现高可用分布式锁。")]),s._v(" "),a("h4",{attrs:{id:"核心思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心思想"}},[s._v("#")]),s._v(" 核心思想")]),s._v(" "),a("ul",[a("li",[s._v("部署N个独立的Redis节点（推荐N=3，奇数，保证多数派），节点间无数据同步。")]),s._v(" "),a("li",[s._v("获取锁时，需在"),a("strong",[s._v("多数节点（N/2 + 1）")]),s._v(" 上成功获取锁，且总耗时不超过锁的过期时间，才算获取成功。")]),s._v(" "),a("li",[s._v("释放锁时，向所有节点发送删除命令（无论是否成功获取过锁）。")])]),s._v(" "),a("h4",{attrs:{id:"执行步骤-以n-3为例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行步骤-以n-3为例"}},[s._v("#")]),s._v(" 执行步骤（以N=3为例）")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("客户端获取当前时间戳T1")]),s._v("（毫秒级，用于计算耗时）。")]),s._v(" "),a("li",[a("strong",[s._v("依次向3个节点发送获取锁命令")]),s._v("："),a("br"),s._v("\n对每个节点执行"),a("code",[s._v("SET lock:key unique-value NX EX 30")]),s._v("（过期时间30秒），超时时间设为5-50毫秒（避免单个节点阻塞过久）。")]),s._v(" "),a("li",[a("strong",[s._v("收集结果并校验")]),s._v("：\n"),a("ul",[a("li",[s._v("统计成功获取锁的节点数量（设为K）。")]),s._v(" "),a("li",[s._v("计算总耗时：T2 - T1（T2为所有节点响应完成的时间戳）。")]),s._v(" "),a("li",[s._v("若K ≥ 2（多数派）且总耗时 < 30秒（锁过期时间），则锁获取成功，"),a("strong",[s._v("实际有效期 = 30秒 - 总耗时")]),s._v("。")])])]),s._v(" "),a("li",[a("strong",[s._v("获取失败处理")]),s._v("："),a("br"),s._v("\n若K < 2或总耗时 ≥ 30秒，立即向所有节点发送释放锁命令，避免锁残留，然后等待随机时间（如100-300毫秒）后重试。")]),s._v(" "),a("li",[a("strong",[s._v("释放锁")]),s._v("："),a("br"),s._v("\n向所有3个节点发送释放锁的Lua脚本（无论该节点是否成功获取过锁），确保所有节点的锁都被清除。")])]),s._v(" "),a("h4",{attrs:{id:"redlock的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redlock的优缺点"}},[s._v("#")]),s._v(" Redlock的优缺点")]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("优点")]),s._v(" "),a("th",[s._v("缺点")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("无单点故障：多个节点独立，少数节点故障不影响整体")]),s._v(" "),a("td",[s._v("部署成本高：需维护N个独立Redis节点")])]),s._v(" "),a("tr",[a("td",[s._v("解决主从异步复制导致的锁丢失问题")]),s._v(" "),a("td",[s._v("性能略低：需访问多个节点，耗时增加")])]),s._v(" "),a("tr",[a("td",[s._v("满足分布式系统的安全性（理论上）")]),s._v(" "),a("td",[s._v("实现复杂：需处理节点超时、网络分区、重试策略等")])])])]),s._v(" "),a("h4",{attrs:{id:"适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[s._v("#")]),s._v(" 适用场景")]),s._v(" "),a("p",[s._v("Redlock适合对数据一致性要求极高的核心业务（如金融交易、库存扣减），非核心业务建议使用主从+哨兵架构（性价比更高）。")]),s._v(" "),a("h2",{attrs:{id:"五、redis分布式锁的实战最佳实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、redis分布式锁的实战最佳实践"}},[s._v("#")]),s._v(" 五、Redis分布式锁的实战最佳实践")]),s._v(" "),a("h3",{attrs:{id:"_5-1-锁的粒度设计-细粒度优先"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-锁的粒度设计-细粒度优先"}},[s._v("#")]),s._v(" 5.1 锁的粒度设计：细粒度优先")]),s._v(" "),a("p",[a("strong",[s._v("原则")]),s._v("：锁的粒度越细，并发度越高（减少锁竞争）。")]),s._v(" "),a("ul",[a("li",[s._v("反例：使用"),a("code",[s._v("lock:stock")]),s._v("作为锁名称，所有商品的库存操作共享一把锁，并发时会严重阻塞。")]),s._v(" "),a("li",[s._v("正例：使用"),a("code",[s._v("lock:stock:{productId}")]),s._v("（如"),a("code",[s._v("lock:stock:1001")]),s._v("），每个商品独立一把锁，不同商品的操作互不影响。")])]),s._v(" "),a("p",[a("strong",[s._v("进阶")]),s._v("：结合业务场景进一步细化，如"),a("code",[s._v("lock:order:{userId}")]),s._v("（用户维度的订单锁）、"),a("code",[s._v("lock:payment:{orderId}")]),s._v("（订单维度的支付锁）。")]),s._v(" "),a("h3",{attrs:{id:"_5-2-过期时间设置-动态适配业务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-过期时间设置-动态适配业务"}},[s._v("#")]),s._v(" 5.2 过期时间设置：动态适配业务")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("不能太短")]),s._v("：需大于业务执行的最大耗时（如业务最长执行20秒，过期时间至少设为30秒），避免锁提前释放。")]),s._v(" "),a("li",[a("strong",[s._v("不能太长")]),s._v("：若线程崩溃，锁需等待过期才能释放，影响可用性（结合看门狗机制可动态调整）。")]),s._v(" "),a("li",[a("strong",[s._v("推荐值")]),s._v("：10-30秒，配合看门狗自动续约（如Redisson的默认配置）。")])]),s._v(" "),a("h3",{attrs:{id:"_5-3-避免死锁的关键措施"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-避免死锁的关键措施"}},[s._v("#")]),s._v(" 5.3 避免死锁的关键措施")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("强制设置过期时间")]),s._v("：即使看门狗失效，锁也能自动释放（兜底机制）。")]),s._v(" "),a("li",[a("strong",[s._v("释放锁放在finally块")]),s._v("：确保业务成功执行或异常时都能释放锁，示例：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("   RLock lock = redissonClient.getLock(lockKey);\n   try {\n       lock.lock(30, TimeUnit.SECONDS);\n       // 执行业务\n   } finally {\n       if (lock.isHeldByCurrentThread()) {\n           lock.unlock();  // 确保释放\n       }\n   }\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[s._v("避免锁嵌套层级过多")]),s._v("：如需获取多把锁，按固定顺序获取（如按锁名称字典序），防止循环等待（如线程A持有锁1等锁2，线程B持有锁2等锁1）。")])]),s._v(" "),a("h3",{attrs:{id:"_5-4-redis部署方案选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-redis部署方案选择"}},[s._v("#")]),s._v(" 5.4 Redis部署方案选择")]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("场景")]),s._v(" "),a("th",[s._v("部署方案")]),s._v(" "),a("th",[s._v("优势")]),s._v(" "),a("th",[s._v("适用业务")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("简单场景")]),s._v(" "),a("td",[s._v("单节点Redis")]),s._v(" "),a("td",[s._v("部署简单，性能高")]),s._v(" "),a("td",[s._v("非核心业务（如缓存更新），可容忍极低概率的锁失效")])]),s._v(" "),a("tr",[a("td",[s._v("一般场景")]),s._v(" "),a("td",[s._v("主从+哨兵")]),s._v(" "),a("td",[s._v("高可用（自动故障转移），兼顾性能")]),s._v(" "),a("td",[s._v("大部分业务（如普通订单、用户信息更新）")])]),s._v(" "),a("tr",[a("td",[s._v("核心场景")]),s._v(" "),a("td",[s._v("Redlock集群（3节点）")]),s._v(" "),a("td",[s._v("无单点故障，锁安全性极高")]),s._v(" "),a("td",[s._v("金融交易、库存扣减等核心业务，不容忍锁失效")])])])]),s._v(" "),a("h2",{attrs:{id:"六、总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、总结"}},[s._v("#")]),s._v(" 六、总结")]),s._v(" "),a("p",[s._v("Redis分布式锁是解决分布式系统并发安全的重要工具，其设计需兼顾互斥性、安全性、可用性和性能。基础实现依赖"),a("code",[s._v("SET NX EX")]),s._v("命令和Lua脚本，可满足简单场景；针对锁超时、可重入性和高可用问题，可通过看门狗机制、Hash结构重入设计和Redlock算法优化。")]),s._v(" "),a("p",[s._v("在实战中，需根据业务场景选择合适的锁粒度、过期时间和部署方案，同时通过非阻塞获取、失败重试等策略提升并发性能。Redisson等成熟框架已封装了上述优化，建议优先使用框架而非重复造轮子，以减少潜在风险。")])])}),[],!1,null,null,null);a.default=t.exports}}]);