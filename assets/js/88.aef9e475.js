(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{444:function(a,e,r){"use strict";r.r(e);var t=r(8),s=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("在多线程编程中，共享变量的线程安全问题始终是核心挑战：")]),a._v(" "),e("ul",[e("li",[a._v("加锁（如 "),e("code",[a._v("synchronized")]),a._v(" 或 "),e("code",[a._v("Lock")]),a._v("）虽能保证安全，但会导致线程阻塞，牺牲性能；")]),a._v(" "),e("li",[a._v("若通过方法参数传递变量，多层调用时会造成代码冗余，可读性下降。")])]),a._v(" "),e("p",[e("strong",[a._v("ThreadLocal 是 JDK 提供的线程隔离工具")]),a._v("，其核心能力是让每个线程持有变量的独立副本，从而彻底避免多线程对共享变量的竞态访问。简单来说：")]),a._v(" "),e("ul",[e("li",[a._v("线程 A 操作的变量副本仅属于 A，线程 B 操作的副本仅属于 B；")]),a._v(" "),e("li",[a._v("线程间的变量修改互不干扰，无需加锁即可保证线程安全。")])]),a._v(" "),e("h2",{attrs:{id:"一、threadlocal-的核心原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、threadlocal-的核心原理"}},[a._v("#")]),a._v(" 一、ThreadLocal 的核心原理")]),a._v(" "),e("p",[a._v("ThreadLocal 实现线程隔离的核心设计是："),e("strong",[a._v("让每个线程持有专属的 "),e("code",[a._v("ThreadLocalMap")]),a._v("，以 ThreadLocal 实例为 key 存储变量副本")]),a._v("。")]),a._v(" "),e("p",[a._v("可以理解为：")]),a._v(" "),e("ul",[e("li",[a._v("每个线程（"),e("code",[a._v("Thread")]),a._v("）都有一个“储物柜”（"),e("code",[a._v("ThreadLocalMap")]),a._v("）；")]),a._v(" "),e("li",[a._v("ThreadLocal 是“钥匙”，通过钥匙可在当前线程的储物柜中存取“物品”（变量副本）；")]),a._v(" "),e("li",[a._v("不同线程的储物柜相互独立，因此变量副本自然隔离。")])]),a._v(" "),e("h2",{attrs:{id:"二、内部结构详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、内部结构详解"}},[a._v("#")]),a._v(" 二、内部结构详解")]),a._v(" "),e("p",[a._v("ThreadLocal 的隔离能力依赖于 "),e("code",[a._v("Thread")]),a._v("、"),e("code",[a._v("ThreadLocalMap")]),a._v("、"),e("code",[a._v("Entry")]),a._v(" 三者的协作，其关系如下：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Thread (线程)\n├─ threadLocals: ThreadLocalMap (普通变量储物柜，默认null)\n│  └─ Entry[] (数组，存储键值对)\n│     └─ Entry: \n│        ├─ key: WeakReference<ThreadLocal<?>> (ThreadLocal的弱引用)\n│        └─ value: Object (线程本地变量副本)\n└─ inheritableThreadLocals: ThreadLocalMap (可继承变量储物柜，默认null)\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br")])]),e("h3",{attrs:{id:"_2-1-thread-类的关键属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-thread-类的关键属性"}},[a._v("#")]),a._v(" 2.1 Thread 类的关键属性")]),a._v(" "),e("p",[a._v("每个 "),e("code",[a._v("Thread")]),a._v(" 实例内置两个 "),e("code",[a._v("ThreadLocalMap")]),a._v(" 类型的属性，用于存储线程本地变量：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public class Thread implements Runnable {\n    // 存储普通 ThreadLocal 变量副本（核心）\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n    // 存储 InheritableThreadLocal 变量副本（支持子线程继承父线程变量）\n    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("ul",[e("li",[a._v("这两个属性默认值为 "),e("code",[a._v("null")]),a._v("，"),e("strong",[a._v("仅在首次调用 ThreadLocal 的 "),e("code",[a._v("set()")]),a._v(" 或 "),e("code",[a._v("get()")]),a._v(" 方法时才会初始化")]),a._v("；")]),a._v(" "),e("li",[a._v("线程销毁时，这两个 "),e("code",[a._v("ThreadLocalMap")]),a._v(" 会被回收，避免全局 Map 导致的内存浪费。")])]),a._v(" "),e("h3",{attrs:{id:"_2-2-threadlocalmap-线程专属的-map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-threadlocalmap-线程专属的-map"}},[a._v("#")]),a._v(" 2.2 ThreadLocalMap：线程专属的 Map")]),a._v(" "),e("p",[e("code",[a._v("ThreadLocalMap")]),a._v(" 是 ThreadLocal 的静态内部类，是专为线程本地存储设计的轻量级 Map，与 HashMap 相比有显著差异：")]),a._v(" "),e("table",[e("thead",[e("tr",[e("th",[a._v("特性")]),a._v(" "),e("th",[a._v("ThreadLocalMap")]),a._v(" "),e("th",[a._v("HashMap")])])]),a._v(" "),e("tbody",[e("tr",[e("td",[a._v("底层结构")]),a._v(" "),e("td",[a._v("数组（"),e("code",[a._v("Entry[]")]),a._v("）")]),a._v(" "),e("td",[a._v("数组 + 链表/红黑树")])]),a._v(" "),e("tr",[e("td",[a._v("哈希冲突解决")]),a._v(" "),e("td",[a._v("线性探测法（依次向后找空位）")]),a._v(" "),e("td",[a._v("链表法（冲突元素链成链表）")])]),a._v(" "),e("tr",[e("td",[a._v("扩容机制")]),a._v(" "),e("td",[a._v("初始容量 16，阈值为 2/3，扩容翻倍")]),a._v(" "),e("td",[a._v("初始容量 16，负载因子 0.75，扩容翻倍")])])])]),a._v(" "),e("p",[e("strong",[a._v("线性探测法的细节")]),a._v("："),e("br"),a._v("\n当计算的数组索引位置已被占用时，会依次检查下一个索引，直到找到空位。这种设计更适合线程本地存储的低冲突场景（一个线程通常不会有太多 ThreadLocal 变量）。")]),a._v(" "),e("h3",{attrs:{id:"_2-3-entry-弱引用-key-与强引用-value"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-entry-弱引用-key-与强引用-value"}},[a._v("#")]),a._v(" 2.3 Entry：弱引用 Key 与强引用 Value")]),a._v(" "),e("p",[e("code",[a._v("Entry")]),a._v(" 是 "),e("code",[a._v("ThreadLocalMap")]),a._v(" 的存储单元，其设计直接影响内存安全性：")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("Key")]),a._v("：对 ThreadLocal 实例的弱引用（"),e("code",[a._v("WeakReference<ThreadLocal<?>>")]),a._v("）；")]),a._v(" "),e("li",[e("strong",[a._v("Value")]),a._v("：对变量副本的强引用（"),e("code",[a._v("Object")]),a._v("）。")])]),a._v(" "),e("p",[e("strong",[a._v("为什么 Key 用弱引用？")]),e("br"),a._v("\n若 Key 是强引用，即使 ThreadLocal 外部强引用被释放（如 "),e("code",[a._v("local = null")]),a._v("），Key 仍会强引用 ThreadLocal，导致其无法被 GC 回收，造成 ThreadLocal 实例本身的内存泄漏。弱引用可保证 ThreadLocal 实例在无外部强引用时被及时回收。")]),a._v(" "),e("h2",{attrs:{id:"三、核心方法工作流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、核心方法工作流程"}},[a._v("#")]),a._v(" 三、核心方法工作流程")]),a._v(" "),e("p",[a._v("ThreadLocal 本身不存储变量，仅通过 "),e("code",[a._v("set()")]),a._v("、"),e("code",[a._v("get()")]),a._v("、"),e("code",[a._v("remove()")]),a._v(" 方法操作当前线程的 "),e("code",[a._v("ThreadLocalMap")]),a._v("，具体流程如下：")]),a._v(" "),e("h3",{attrs:{id:"_3-1-set-t-value-设置变量副本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-set-t-value-设置变量副本"}},[a._v("#")]),a._v(" 3.1 set(T value)：设置变量副本")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public void set(T value) {\n    // 1. 获取当前线程\n    Thread t = Thread.currentThread();\n    // 2. 获取线程的 ThreadLocalMap\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        // 3. 若 Map 存在，以当前 ThreadLocal 为 key 存入 value\n        map.set(this, value);\n    } else {\n        // 4. 若 Map 不存在，初始化 Map 并存入 value\n        createMap(t, value);\n    }\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br")])]),e("h3",{attrs:{id:"_3-2-get-获取变量副本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-get-获取变量副本"}},[a._v("#")]),a._v(" 3.2 get()：获取变量副本")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('public T get() {\n    // 1. 获取当前线程\n    Thread t = Thread.currentThread();\n    // 2. 获取线程的 ThreadLocalMap\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        // 3. 若 Map 存在，以当前 ThreadLocal 为 key 查找 Entry\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings("unchecked")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    // 4. 若 Map 不存在或 key 未找到，初始化 value 并返回\n    return setInitialValue();\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br")])]),e("h3",{attrs:{id:"_3-3-remove-移除变量副本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-remove-移除变量副本"}},[a._v("#")]),a._v(" 3.3 remove()：移除变量副本")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public void remove() {\n    // 1. 获取当前线程的 ThreadLocalMap\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null) {\n        // 2. 移除当前 ThreadLocal 对应的 Entry\n        m.remove(this);\n    }\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br")])]),e("h2",{attrs:{id:"四、内存泄漏风险与避免"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、内存泄漏风险与避免"}},[a._v("#")]),a._v(" 四、内存泄漏风险与避免")]),a._v(" "),e("p",[a._v("ThreadLocal 的内存泄漏并非单一原因导致，而是 "),e("strong",[a._v("Entry 引用设计、线程生命周期、未手动清理")]),a._v(" 三者叠加的结果。")]),a._v(" "),e("h3",{attrs:{id:"_4-1-内存泄漏的产生过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-内存泄漏的产生过程"}},[a._v("#")]),a._v(" 4.1 内存泄漏的产生过程")]),a._v(" "),e("ol",[e("li",[e("p",[e("strong",[a._v("正常状态")]),a._v("："),e("br"),a._v("\n若 ThreadLocal 有外部强引用（如 "),e("code",[a._v("static ThreadLocal local = new ThreadLocal()")]),a._v("），Entry 的 Key（弱引用）指向 ThreadLocal，且 ThreadLocal 被外部强引用持有，GC 不会回收 Key。Value 可正常访问，无泄漏风险。")])]),a._v(" "),e("li",[e("p",[e("strong",[a._v("风险状态")]),a._v("："),e("br"),a._v("\n若外部强引用被释放（如 "),e("code",[a._v("local = null")]),a._v("，或 ThreadLocal 是局部变量），Entry 的 Key 仅为弱引用，GC 会回收 Key（Key 变为 "),e("code",[a._v("null")]),a._v("）。但 Value 仍被 "),e("code",[a._v("Thread -> ThreadLocalMap -> Entry -> Value")]),a._v(" 的强引用链关联，若线程长期存活（如线程池中的核心线程），Value 无法被回收，最终导致内存泄漏。")])]),a._v(" "),e("li",[e("p",[e("strong",[a._v("被动清理机制的局限性")]),a._v("："),e("br"),a._v(" "),e("code",[a._v("ThreadLocalMap")]),a._v(" 会在 "),e("code",[a._v("get()")]),a._v("/"),e("code",[a._v("set()")]),a._v("/"),e("code",[a._v("remove()")]),a._v(" 时扫描并清理 Key 为 "),e("code",[a._v("null")]),a._v(" 的 Entry，但该机制是被动触发的。若线程长期存活且不再调用这些方法，清理逻辑永远不会执行，脏 Entry 会持续占用内存。")])])]),a._v(" "),e("h3",{attrs:{id:"_4-2-如何避免内存泄漏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-如何避免内存泄漏"}},[a._v("#")]),a._v(" 4.2 如何避免内存泄漏？")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("主动调用 "),e("code",[a._v("remove()")]),a._v(" 方法")]),a._v("：在业务代码结束后（如请求处理完成、任务执行结束），手动调用 "),e("code",[a._v("threadLocal.remove()")]),a._v("，移除 Entry 以切断 Value 的强引用链。")]),a._v(" "),e("li",[e("strong",[a._v("避免使用长生命周期线程")]),a._v("：若必须使用（如线程池），务必在任务结束时清理 ThreadLocal 变量。")]),a._v(" "),e("li",[e("strong",[a._v("慎用局部 ThreadLocal 变量")]),a._v("：局部变量在方法结束后会被回收，可能导致 Key 提前变为 "),e("code",[a._v("null")]),a._v("，增加泄漏风险。")])]),a._v(" "),e("h2",{attrs:{id:"五、inheritablethreadlocal-支持线程继承的扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、inheritablethreadlocal-支持线程继承的扩展"}},[a._v("#")]),a._v(" 五、InheritableThreadLocal：支持线程继承的扩展")]),a._v(" "),e("p",[e("code",[a._v("InheritableThreadLocal")]),a._v(" 是 ThreadLocal 的子类，用于解决“子线程需要访问父线程本地变量”的场景（如日志追踪中的 "),e("code",[a._v("traceId")]),a._v(" 传递）。")]),a._v(" "),e("h3",{attrs:{id:"核心特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心特性"}},[a._v("#")]),a._v(" 核心特性：")]),a._v(" "),e("ul",[e("li",[a._v("变量存储在 "),e("code",[a._v("Thread")]),a._v(" 的 "),e("code",[a._v("inheritableThreadLocals")]),a._v(" 中，而非 "),e("code",[a._v("threadLocals")]),a._v("；")]),a._v(" "),e("li",[a._v("子线程创建时，会自动复制父线程 "),e("code",[a._v("inheritableThreadLocals")]),a._v(" 中的变量副本（浅拷贝）。")])]),a._v(" "),e("h3",{attrs:{id:"注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[a._v("#")]),a._v(" 注意事项：")]),a._v(" "),e("ul",[e("li",[a._v("若变量是可变对象（如集合），子线程修改会影响父线程（因浅拷贝共享对象引用）；")]),a._v(" "),e("li",[a._v("线程池场景下，子线程复用可能导致变量继承异常，需结合业务手动重置。")])]),a._v(" "),e("h2",{attrs:{id:"六、threadlocal-vs-同步机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、threadlocal-vs-同步机制"}},[a._v("#")]),a._v(" 六、ThreadLocal  vs 同步机制")]),a._v(" "),e("table",[e("thead",[e("tr",[e("th",[a._v("场景")]),a._v(" "),e("th",[a._v("ThreadLocal")]),a._v(" "),e("th",[a._v("同步机制（synchronized/Lock）")])])]),a._v(" "),e("tbody",[e("tr",[e("td",[a._v("核心思想")]),a._v(" "),e("td",[a._v("线程隔离（每个线程有独立副本）")]),a._v(" "),e("td",[a._v("互斥访问（同一时间仅一个线程操作）")])]),a._v(" "),e("tr",[e("td",[a._v("性能")]),a._v(" "),e("td",[a._v("无锁，性能高")]),a._v(" "),e("td",[a._v("可能阻塞，性能较低")])]),a._v(" "),e("tr",[e("td",[a._v("内存开销")]),a._v(" "),e("td",[a._v("线程数 × 变量副本数")]),a._v(" "),e("td",[a._v("无额外内存开销")])]),a._v(" "),e("tr",[e("td",[a._v("适用场景")]),a._v(" "),e("td",[a._v("变量需线程私有（如用户会话）")]),a._v(" "),e("td",[a._v("需共享变量且保证一致性（如计数器）")])])])]),a._v(" "),e("h2",{attrs:{id:"七、实践建议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、实践建议"}},[a._v("#")]),a._v(" 七、实践建议")]),a._v(" "),e("ol",[e("li",[e("strong",[a._v("优先声明为 "),e("code",[a._v("static")])]),a._v("：减少 ThreadLocal 实例数量，降低内存开销（一个 ThreadLocal 可被多个线程共享作为 key）。")]),a._v(" "),e("li",[e("strong",[a._v("务必手动 "),e("code",[a._v("remove()")])]),a._v("：尤其是线程池环境，避免线程复用导致的变量污染和内存泄漏。")]),a._v(" "),e("li",[e("strong",[a._v("避免存储大对象")]),a._v("：每个线程持有副本会增加内存消耗，大对象可能导致 OOM。")]),a._v(" "),e("li",[e("strong",[a._v("慎用 "),e("code",[a._v("InheritableThreadLocal")])]),a._v("：明确父子线程变量传递需求时使用，避免浅拷贝带来的副作用。")])]),a._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),e("p",[a._v("ThreadLocal 是解决线程隔离问题的高效工具，其核心通过线程专属的 "),e("code",[a._v("ThreadLocalMap")]),a._v(" 实现变量副本存储。")])])}),[],!1,null,null,null);e.default=s.exports}}]);