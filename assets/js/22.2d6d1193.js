(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{377:function(t,s,a){"use strict";a.r(s);var n=a(8),_=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("在“Redis 缓存 + MySQL 数据库”的经典架构中，数据一致性是高频痛点。延时双删作为一种"),s("strong",[t._v("实现简单、成本低廉、适配多数最终一致性场景")]),t._v("的解决方案，被广泛应用于非核心业务（如商品详情、用户历史记录）。")]),t._v(" "),s("h2",{attrs:{id:"一、为什么需要-延时双删"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、为什么需要-延时双删"}},[t._v("#")]),t._v(" 一、为什么需要“延时双删”？")]),t._v(" "),s("p",[t._v("在聊延时双删前，先明确一个核心矛盾：Redis 与 MySQL 是独立存储系统，读写操作无法原子化完成，并发场景下极易出现数据不一致。我们先看两个经典错误场景，理解延时双删的诞生意义。")]),t._v(" "),s("h3",{attrs:{id:"_1-1-错误场景1-先更数据库-再更缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-错误场景1-先更数据库-再更缓存"}},[t._v("#")]),t._v(" 1.1 错误场景1：先更数据库，再更缓存")]),t._v(" "),s("ul",[s("li",[t._v("流程：\n"),s("ol",[s("li",[t._v("线程A 更新 MySQL，将值从 V1→V2，数据库现在是 V2")]),t._v(" "),s("li",[t._v("线程B 更新 MySQL，将值从 V2→V3，数据库现在是 V3")]),t._v(" "),s("li",[t._v("线程B 更新 Redis，将值从 V1→V3，Redis现在是 V3")]),t._v(" "),s("li",[t._v("线程A 更新 Redis，将值从 V3→V2，Redis现在是 V2")])])]),t._v(" "),s("li",[t._v("问题：并发修改时，MySQL 是新数据，Redis 保留旧数据，形成不一致，直到缓存过期。")])]),t._v(" "),s("h3",{attrs:{id:"_1-2-错误场景2-先删缓存-再更数据库-无延时"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-错误场景2-先删缓存-再更数据库-无延时"}},[t._v("#")]),t._v(" 1.2 错误场景2：先删缓存，再更数据库（无延时）")]),t._v(" "),s("ul",[s("li",[t._v("流程：\n"),s("ol",[s("li",[t._v("线程A 删除 Redis 缓存；")]),t._v(" "),s("li",[t._v("线程A 未完成 MySQL 更新,事务为提交；")]),t._v(" "),s("li",[t._v("线程B 读取 Redis 缓存未命中，从 MySQL 读取旧数据并回写缓存；")]),t._v(" "),s("li",[t._v("线程A 完成 MySQL 更新。")])])]),t._v(" "),s("li",[t._v("问题：Redis 被旧数据“污染”，后续请求会持续读取错误数据，直到缓存过期。")])]),t._v(" "),s("h3",{attrs:{id:"_1-3-延时双删的核心价值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-延时双删的核心价值"}},[t._v("#")]),t._v(" 1.3 延时双删的核心价值")]),t._v(" "),s("p",[t._v("延时双删通过“两次删除缓存 + 中间延时等待”，精准解决上述并发时序问题，核心目标是"),s("strong",[t._v("让缓存数据最终收敛到与数据库一致")]),t._v("，同时兼顾实现成本与性能。")]),t._v(" "),s("h2",{attrs:{id:"二、延时双删核心原理与实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、延时双删核心原理与实现"}},[t._v("#")]),t._v(" 二、延时双删核心原理与实现")]),t._v(" "),s("h3",{attrs:{id:"_2-1-三步核心流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-三步核心流程"}},[t._v("#")]),t._v(" 2.1 三步核心流程")]),t._v(" "),s("p",[t._v("延时双删的操作逻辑极简，仅需三步，就能规避并发读写导致的缓存污染：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("第一次删除")]),t._v("：更新数据前，先删除 Redis 对应缓存，让后续读请求暂时穿透到数据库；")]),t._v(" "),s("li",[s("strong",[t._v("更新数据库")]),t._v("：正常写入/更新 MySQL 数据，保证持久化存储的准确性；")]),t._v(" "),s("li",[s("strong",[t._v("延时等待后第二次删除")]),t._v("：等待一段时间，再次删除 Redis 缓存，清除可能被线程B 回写的旧数据。")])]),t._v(" "),s("h3",{attrs:{id:"_2-2-关键逻辑拆解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-关键逻辑拆解"}},[t._v("#")]),t._v(" 2.2 关键逻辑拆解")]),t._v(" "),s("p",[t._v("第二次删除的“延时等待”是核心，其目的是："),s("strong",[t._v("等待所有在“第一次删缓存后、更数据库前”发起的读请求，都完成旧数据的读取与回写")]),t._v("，再通过第二次删除清空这些旧数据。后续读请求会从数据库读取新数据，重新回写缓存，达成最终一致。")]),t._v(" "),s("h3",{attrs:{id:"_2-3-代码落地实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-代码落地实现"}},[t._v("#")]),t._v(" 2.3 代码落地实现")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 延时双删核心方法（更新数据场景）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("updateData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Long")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" newData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 缓存键（按业务设计，如前缀+ID）")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" cacheKey "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"data:"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一步：第一次删除缓存")]),t._v("\n    redisTemplate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cacheKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第二步：更新 MySQL 数据库（实际业务中需加事务）")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("updateMySQL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 数据库更新失败，可回滚缓存（可选，视业务容错性）")]),t._v("\n        redisTemplate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("opsForValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cacheKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getOldDataFromMySQL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TimeUnit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MINUTES")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RuntimeException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"数据库更新失败"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第三步：延时 1 秒后，第二次删除缓存")]),t._v("\n    executorService"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("schedule")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        redisTemplate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cacheKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TimeUnit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SECONDS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br")])]),s("h2",{attrs:{id:"三、关键参数-延时时间怎么定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、关键参数-延时时间怎么定"}},[t._v("#")]),t._v(" 三、关键参数：延时时间怎么定？")]),t._v(" "),s("p",[t._v("延时时间的设定直接影响一致性效果与性能，不能凭感觉定，需结合三个核心因素：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("数据库事务耗时")]),t._v("：若更新操作涉及复杂事务（如多表关联），需预留足够时间让事务提交完成；")]),t._v(" "),s("li",[s("strong",[t._v("业务 QPS 与并发量")]),t._v("：高并发场景下，读请求回写缓存的速度更快，可适当缩短延时；低并发场景可延长，避免过早删除；")]),t._v(" "),s("li",[s("strong",[t._v("网络延迟")]),t._v("：Redis 与 MySQL 部署在不同节点时，需考虑网络传输耗时。")])]),t._v(" "),s("h3",{attrs:{id:"推荐取值与校准方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#推荐取值与校准方法"}},[t._v("#")]),t._v(" 推荐取值与校准方法")]),t._v(" "),s("ul",[s("li",[t._v("常规场景：默认 1-3 秒，覆盖大部分中小并发业务；")]),t._v(" "),s("li",[t._v("高并发场景：0.5-1 秒，减少缓存穿透时间，降低数据库压力；")]),t._v(" "),s("li",[t._v("复杂事务场景：3-5 秒，确保事务完全提交后再二次删除。")])]),t._v(" "),s("h3",{attrs:{id:"校准技巧"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#校准技巧"}},[t._v("#")]),t._v(" 校准技巧")]),t._v(" "),s("p",[t._v("上线后通过日志监控“第一次删缓存到第二次删缓存”期间的读请求量，若仍存在缓存污染，逐步增加延时时间（每次加 500ms），直到不一致问题消失。")]),t._v(" "),s("h2",{attrs:{id:"四、延时双删的优缺点与适用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、延时双删的优缺点与适用场景"}},[t._v("#")]),t._v(" 四、延时双删的优缺点与适用场景")]),t._v(" "),s("h3",{attrs:{id:"_4-1-优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-优点"}},[t._v("#")]),t._v(" 4.1 优点")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("实现简单")]),t._v("：无需引入 Canal、消息队列等中间件，代码侵入性极低；")]),t._v(" "),s("li",[s("strong",[t._v("成本低廉")]),t._v("：仅增加两次缓存删除操作，对性能影响可忽略；")]),t._v(" "),s("li",[s("strong",[t._v("容错性强")]),t._v("：即使第二次删除失败，缓存设置了过期时间，也能兜底保证最终一致。")])]),t._v(" "),s("h3",{attrs:{id:"_4-2-缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-缺点"}},[t._v("#")]),t._v(" 4.2 缺点")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("存在短时间不一致窗口")]),t._v("：从第一次删缓存到第二次删缓存的间隙，仍可能读取到旧数据，不适用于超强一致性场景（如支付、库存）；")]),t._v(" "),s("li",[s("strong",[t._v("延时时间难精准把控")]),t._v("：不同业务场景下需反复校准，无统一标准；")]),t._v(" "),s("li",[s("strong",[t._v("高并发写场景有局限")]),t._v("：频繁删除缓存会导致大量读请求穿透到数据库，可能引发数据库压力飙升。")])]),t._v(" "),s("h3",{attrs:{id:"_4-3-适用与不适用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-适用与不适用场景"}},[t._v("#")]),t._v(" 4.3 适用与不适用场景")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("场景类型")]),t._v(" "),s("th",[t._v("是否适用")]),t._v(" "),s("th",[t._v("原因")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("商品详情、用户资料")]),t._v(" "),s("td",[t._v("适用")]),t._v(" "),s("td",[t._v("允许秒级不一致，追求高读性能")])]),t._v(" "),s("tr",[s("td",[t._v("订单列表、历史记录")]),t._v(" "),s("td",[t._v("适用")]),t._v(" "),s("td",[t._v("数据变更频率低，最终一致即可")])]),t._v(" "),s("tr",[s("td",[t._v("支付金额、库存数量")]),t._v(" "),s("td",[t._v("不适用")]),t._v(" "),s("td",[t._v("需强一致性，避免超卖、资金误差")])])])]),t._v(" "),s("h2",{attrs:{id:"五、实战避坑-这些问题一定要注意"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、实战避坑-这些问题一定要注意"}},[t._v("#")]),t._v(" 五、实战避坑：这些问题一定要注意")]),t._v(" "),s("h3",{attrs:{id:"_5-1-缓存删除失败怎么办"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-缓存删除失败怎么办"}},[t._v("#")]),t._v(" 5.1 缓存删除失败怎么办？")]),t._v(" "),s("p",[t._v("两次删除操作都可能因 Redis 宕机、网络超时失败，需做好兜底：")]),t._v(" "),s("ul",[s("li",[t._v("第一次删除失败：直接放弃更新操作，返回错误提示，避免“数据库新数据、缓存旧数据”；")]),t._v(" "),s("li",[t._v("第二次删除失败：借助异步重试机制（如消息队列），或依赖缓存过期时间兜底，同时监控删除失败率，超过阈值告警。")])]),t._v(" "),s("h3",{attrs:{id:"_5-2-避免缓存穿透放大"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-避免缓存穿透放大"}},[t._v("#")]),t._v(" 5.2 避免缓存穿透放大")]),t._v(" "),s("p",[t._v("延时双删会导致短时间内缓存穿透（第一次删后到第二次删前，读请求直接透库），高并发下需配合防护：")]),t._v(" "),s("ul",[s("li",[t._v("非核心数据：设置空值缓存（如缓存不存在的数据为“null”，过期时间 5-10 秒）；")]),t._v(" "),s("li",[t._v("核心热点数据：结合互斥锁，同一时间仅允许一个线程读库回写缓存，避免数据库雪崩。")])]),t._v(" "),s("h3",{attrs:{id:"_5-3-不要滥用延时双删"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-不要滥用延时双删"}},[t._v("#")]),t._v(" 5.3 不要滥用延时双删")]),t._v(" "),s("p",[t._v("并非所有缓存更新场景都需要延时双删：")]),t._v(" "),s("ul",[s("li",[t._v("写少读多场景：优先用“先删缓存+缓存过期”，可省略第二次删除，减少复杂度；")]),t._v(" "),s("li",[t._v("数据变更频率极高场景：建议改用 Canal 异步同步方案，避免频繁删除缓存。")])]),t._v(" "),s("h2",{attrs:{id:"六、延时双删-vs-其他一致性方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、延时双删-vs-其他一致性方案"}},[t._v("#")]),t._v(" 六、延时双删 vs 其他一致性方案")]),t._v(" "),s("p",[t._v("为帮你精准选型，对比主流缓存一致性方案的差异：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("方案")]),t._v(" "),s("th",[t._v("一致性级别")]),t._v(" "),s("th",[t._v("实现复杂度")]),t._v(" "),s("th",[t._v("性能")]),t._v(" "),s("th",[t._v("适用场景")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("延时双删")]),t._v(" "),s("td",[t._v("最终一致性")]),t._v(" "),s("td",[t._v("低")]),t._v(" "),s("td",[t._v("高")]),t._v(" "),s("td",[t._v("中小并发、非核心业务")])]),t._v(" "),s("tr",[s("td",[t._v("分布式锁+同步更新")]),t._v(" "),s("td",[t._v("强一致性")]),t._v(" "),s("td",[t._v("中")]),t._v(" "),s("td",[t._v("中")]),t._v(" "),s("td",[t._v("核心业务（库存、支付）")])]),t._v(" "),s("tr",[s("td",[t._v("Canal+Binlog 异步同步")]),t._v(" "),s("td",[t._v("最终一致性")]),t._v(" "),s("td",[t._v("高")]),t._v(" "),s("td",[t._v("高")]),t._v(" "),s("td",[t._v("高并发、海量数据场景")])]),t._v(" "),s("tr",[s("td",[t._v("先更库再更缓存")]),t._v(" "),s("td",[t._v("最终一致性")]),t._v(" "),s("td",[t._v("低")]),t._v(" "),s("td",[t._v("中")]),t._v(" "),s("td",[t._v("低并发、缓存更新成功率 100% 场景")])])])]),t._v(" "),s("h2",{attrs:{id:"七、最佳实践总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七、最佳实践总结"}},[t._v("#")]),t._v(" 七、最佳实践总结")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("必加缓存过期时间")]),t._v("：无论延时双删多稳定，都要给缓存设置过期时间（5-30 分钟），作为不一致的最后兜底；")]),t._v(" "),s("li",[s("strong",[t._v("延时时间动态校准")]),t._v("：上线后根据业务并发量、事务耗时调整延时时间，避免一刀切；")]),t._v(" "),s("li",[s("strong",[t._v("失败重试兜底")]),t._v("：第二次删除失败时，通过消息队列异步重试，确保删除操作最终执行；")]),t._v(" "),s("li",[s("strong",[t._v("结合业务场景选型")]),t._v("：非核心最终一致性场景用延时双删，核心强一致场景用分布式锁，高并发场景用 Canal 方案。")])]),t._v(" "),s("h2",{attrs:{id:"八、总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#八、总结"}},[t._v("#")]),t._v(" 八、总结")]),t._v(" "),s("p",[t._v("Redis 延时双删是“性价比极高”的缓存一致性解决方案，核心优势在于"),s("strong",[t._v("简单落地、低侵入、高性能")]),t._v("，完美适配多数非核心业务的最终一致性需求。其本质是通过“两次删除+延时等待”，巧妙规避并发读写的时序问题，同时借助缓存过期时间兜底，平衡一致性与性能。")])])}),[],!1,null,null,null);s.default=_.exports}}]);