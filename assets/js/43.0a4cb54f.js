(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{401:function(v,_,a){"use strict";a.r(_);var s=a(8),r=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("无论是Java源代码（.java）还是编译后的字节码文件（.class），都无法直接被操作系统执行。Java之所以能实现“一次编译，到处运行”，核心在于Java虚拟机（JVM）——它作为字节码与底层操作系统之间的中间层，屏蔽了不同硬件和操作系统的差异，同时自动管理内存（如垃圾回收），降低了开发者的内存管理成本。")]),v._v(" "),_("h2",{attrs:{id:"一、jvm的整体架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、jvm的整体架构"}},[v._v("#")]),v._v(" 一、JVM的整体架构")]),v._v(" "),_("p",[v._v("JVM的整体架构可划分为五大核心模块，各模块协同工作完成Java程序的运行：")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("┌─────────────────────────────────────────────────┐\n│                  JVM 整体架构                   │\n├─────────────┬─────────────────────┬─────────────┤\n│  类加载子系统  │     运行时数据区     │   执行引擎   │\n├─────────────┼─────────────────────┼─────────────┤\n│  本地方法接口  │                   │   垃圾回收   │\n└─────────────┴─────────────────────┴─────────────┘\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br")])]),_("p",[v._v("各模块的核心作用：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("类加载子系统")]),v._v("：将.class字节码文件加载为JVM可识别的类对象；")]),v._v(" "),_("li",[_("strong",[v._v("运行时数据区")]),v._v("：存储程序运行时的所有数据（如对象实例、局部变量等），是内存管理的核心；")]),v._v(" "),_("li",[_("strong",[v._v("执行引擎")]),v._v("：解析并执行字节码指令，是程序运行的“动力源”；")]),v._v(" "),_("li",[_("strong",[v._v("本地方法接口")]),v._v("：衔接Java代码与非Java语言（如C/C++）编写的本地方法，弥补Java底层能力不足；")]),v._v(" "),_("li",[_("strong",[v._v("垃圾回收（GC）")]),v._v("：自动回收运行时数据区中无用的对象/类，避免内存泄漏和溢出。")])]),v._v(" "),_("h2",{attrs:{id:"二、类加载子系统-从字节码到可执行类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、类加载子系统-从字节码到可执行类"}},[v._v("#")]),v._v(" 二、类加载子系统：从字节码到可执行类")]),v._v(" "),_("p",[v._v("类加载子系统的核心任务是将.class字节码文件转换为JVM可直接使用的"),_("code",[v._v("Class")]),v._v("对象。"),_("strong",[v._v("类加载采用“按需加载”策略")]),v._v("——仅当程序首次使用某个类时（如创建实例、调用静态方法），才会触发加载流程。")]),v._v(" "),_("h3",{attrs:{id:"_2-1-类加载的完整流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-类加载的完整流程"}},[v._v("#")]),v._v(" 2.1 类加载的完整流程")]),v._v(" "),_("p",[v._v("类加载过程分为5个阶段，依次执行且不可逆：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("加载（Loading）")]),_("br"),v._v("\n类加载器根据类的全限定名（如"),_("code",[v._v("java.lang.String")]),v._v("），通过类路径（classpath）查找对应的.class文件，将字节流读入内存，并将静态存储结构（如字段、方法、常量池）转换为运行时数据结构（存储在方法区/元空间），最终生成一个代表该类的"),_("code",[v._v("Class")]),v._v("对象（作为方法区中类信息的访问入口）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("校验（Verification）")]),_("br"),v._v("\n对字节流进行合法性校验，确保其符合JVM规范且不会危害虚拟机安全，是“沙箱安全”的重要保障。具体包括：")]),v._v(" "),_("ul",[_("li",[v._v("文件格式校验（如是否以魔数"),_("code",[v._v("0xCAFEBABE")]),v._v("开头、版本号是否兼容）；")]),v._v(" "),_("li",[v._v("元数据校验（如类是否有父类、是否实现了接口的所有方法）；")]),v._v(" "),_("li",[v._v("字节码校验（确保指令逻辑合法，如不会跳转到方法体外）；")]),v._v(" "),_("li",[v._v("符号引用校验（如引用的类/方法是否存在）。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("准备（Preparation）")]),_("br"),v._v("\n在元空间为类的"),_("strong",[v._v("静态变量")]),v._v("分配内存，并赋予"),_("strong",[v._v("默认初始值")]),v._v("（非显式赋值）。例如：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("public static int num;")]),v._v(" 会被分配内存，默认值为"),_("code",[v._v("0")]),v._v("；")]),v._v(" "),_("li",[_("code",[v._v("public static final int COUNT = 10;")]),v._v(" 因被"),_("code",[v._v("final")]),v._v("修饰，此处会直接赋予显式值"),_("code",[v._v("10")]),v._v("（而非默认值）。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("解析（Resolution）")]),_("br"),v._v("\n将类中的"),_("strong",[v._v("符号引用")]),v._v("（如"),_("code",[v._v("java.util.List")]),v._v("、"),_("code",[v._v("add()")]),v._v("方法名）转换为"),_("strong",[v._v("直接引用")]),v._v("（内存地址）。例如：")]),v._v(" "),_("ul",[_("li",[v._v("类名解析为对应"),_("code",[v._v("Class")]),v._v("对象的内存地址；")]),v._v(" "),_("li",[v._v("方法名解析为方法字节码在元空间的具体地址。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("初始化（Initialization）")]),_("br"),v._v("\n执行类的静态代码块和静态变量的"),_("strong",[v._v("显式赋值语句")]),v._v("，是类加载中唯一执行用户代码的阶段。JVM会自动将静态变量显式赋值和静态代码块按顺序合并为"),_("code",[v._v("<clinit>()")]),v._v("方法，并保证该方法在多线程环境下"),_("strong",[v._v("仅被执行一次")]),v._v("（其他线程阻塞等待）。"),_("br"),v._v(" "),_("em",[v._v("注：接口初始化不会执行静态代码块，仅当接口中定义的静态变量被使用时才触发。")])])])]),v._v(" "),_("h3",{attrs:{id:"_2-2-双亲委派模型-类加载的安全保障"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-双亲委派模型-类加载的安全保障"}},[v._v("#")]),v._v(" 2.2 双亲委派模型：类加载的安全保障")]),v._v(" "),_("p",[v._v("类加载器加载类时，需遵循“双亲委派模型”——优先委托父加载器加载，仅当父加载器失败时才自己尝试加载。这一机制主要解决类重复加载和核心类安全问题。")]),v._v(" "),_("h4",{attrs:{id:"_2-2-1-类加载器的层次结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-类加载器的层次结构"}},[v._v("#")]),v._v(" 2.2.1 类加载器的层次结构")]),v._v(" "),_("p",[v._v("JVM默认提供4层类加载器（自上而下）：")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("启动类加载器（Bootstrap ClassLoader）")]),_("br"),v._v("\n由C++实现，无对应的Java对象（"),_("code",[v._v("getClassLoader()")]),v._v("返回"),_("code",[v._v("null")]),v._v("），负责加载JVM核心类库（如"),_("code",[v._v("JAVA_HOME/jre/lib")]),v._v("下的"),_("code",[v._v("rt.jar")]),v._v("、"),_("code",[v._v("charsets.jar")]),v._v("等）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("扩展类加载器（Extension ClassLoader）")]),_("br"),v._v("\n由Java实现（"),_("code",[v._v("sun.misc.Launcher$ExtClassLoader")]),v._v("），加载扩展类库（"),_("code",[v._v("JAVA_HOME/jre/lib/ext")]),v._v("目录或"),_("code",[v._v("java.ext.dirs")]),v._v("配置的jar包）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("应用类加载器（Application ClassLoader）")]),_("br"),v._v("\n由Java实现（"),_("code",[v._v("sun.misc.Launcher$AppClassLoader")]),v._v("），加载应用程序classpath下的类（如项目代码、第三方依赖），是默认的类加载器。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("自定义类加载器")]),_("br"),v._v("\n开发者通过继承"),_("code",[v._v("ClassLoader")]),v._v("类实现，可自定义加载逻辑（如加载网络中的类、加密的类文件）。")])])]),v._v(" "),_("h4",{attrs:{id:"_2-2-2-双亲委派的执行流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-双亲委派的执行流程"}},[v._v("#")]),v._v(" 2.2.2 双亲委派的执行流程")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("类加载请求 → 当前类加载器\n    ↓（检查是否已加载：是则返回，否则继续）\n    委派给父类加载器（递归）\n    ↓\n启动类加载器\n    ↓（查找核心类库）\n    找到 → 加载并返回\n    ↓（未找到）\n扩展类加载器\n    ↓（查找扩展类库）\n    找到 → 加载并返回\n    ↓（未找到）\n应用程序类加载器\n    ↓（查找classpath）\n    找到 → 加载并返回\n    ↓（未找到）\n自定义类加载器\n    ↓（查找自定义范围）\n    找到 → 加载并返回\n    ↓（未找到）\n抛出 ClassNotFoundException\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br"),_("span",{staticClass:"line-number"},[v._v("9")]),_("br"),_("span",{staticClass:"line-number"},[v._v("10")]),_("br"),_("span",{staticClass:"line-number"},[v._v("11")]),_("br"),_("span",{staticClass:"line-number"},[v._v("12")]),_("br"),_("span",{staticClass:"line-number"},[v._v("13")]),_("br"),_("span",{staticClass:"line-number"},[v._v("14")]),_("br"),_("span",{staticClass:"line-number"},[v._v("15")]),_("br"),_("span",{staticClass:"line-number"},[v._v("16")]),_("br"),_("span",{staticClass:"line-number"},[v._v("17")]),_("br"),_("span",{staticClass:"line-number"},[v._v("18")]),_("br"),_("span",{staticClass:"line-number"},[v._v("19")]),_("br"),_("span",{staticClass:"line-number"},[v._v("20")]),_("br"),_("span",{staticClass:"line-number"},[v._v("21")]),_("br")])]),_("h4",{attrs:{id:"_2-2-3-双亲委派的核心作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-双亲委派的核心作用"}},[v._v("#")]),v._v(" 2.2.3 双亲委派的核心作用")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("防止类重复加载")]),v._v("：同一类文件被不同加载器加载会生成不同"),_("code",[v._v("Class")]),v._v("对象，导致类转换异常（如"),_("code",[v._v("ClassCastException")]),v._v("）；")]),v._v(" "),_("li",[_("strong",[v._v("保障核心类安全")]),v._v("：核心类（如"),_("code",[v._v("java.lang.String")]),v._v("）只能被启动类加载器加载，避免恶意代码替换核心类（如自定义"),_("code",[v._v("java.lang.String")]),v._v("并篡改逻辑）。")])]),v._v(" "),_("h3",{attrs:{id:"_2-3-打破双亲委派模型的场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-打破双亲委派模型的场景"}},[v._v("#")]),v._v(" 2.3 打破双亲委派模型的场景")]),v._v(" "),_("p",[v._v("双亲委派模型并非强制规范，可通过重写"),_("code",[v._v("ClassLoader")]),v._v("的"),_("code",[v._v("loadClass()")]),v._v("方法（跳过父加载器委派）打破。常见场景：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("热部署")]),v._v("：需在JVM不重启的情况下替换类（如Spring Boot DevTools），通过自定义类加载器加载新类文件，替换旧"),_("code",[v._v("Class")]),v._v("对象；")]),v._v(" "),_("li",[_("strong",[v._v("Tomcat类加载")]),v._v("：Tomcat为每个Web应用创建独立的"),_("code",[v._v("WebAppClassLoader")]),v._v("，优先加载"),_("code",[v._v("WEB-INF/classes")]),v._v("和"),_("code",[v._v("WEB-INF/lib")]),v._v("下的类（而非委派给应用类加载器），避免多应用间的类冲突（如不同应用依赖同一类的不同版本）。")])]),v._v(" "),_("h2",{attrs:{id:"三、运行时数据区-jvm的内存核心"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、运行时数据区-jvm的内存核心"}},[v._v("#")]),v._v(" 三、运行时数据区：JVM的内存核心")]),v._v(" "),_("p",[v._v("类加载完成后，程序运行时的所有数据均存储在“运行时数据区”。根据是否线程共享，可分为"),_("strong",[v._v("线程私有区域")]),v._v("和"),_("strong",[v._v("线程共享区域")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"_3-1-线程私有区域-随线程创建-销毁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-线程私有区域-随线程创建-销毁"}},[v._v("#")]),v._v(" 3.1 线程私有区域（随线程创建/销毁）")]),v._v(" "),_("p",[v._v("线程私有区域的生命周期与线程一致，无需GC管理。")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("程序计数器（Program Counter Register）")])]),v._v(" "),_("ul",[_("li",[v._v("作用：记录当前线程正在执行的字节码指令地址（如行号）；")]),v._v(" "),_("li",[v._v("特点：\n"),_("ul",[_("li",[v._v("多线程切换时，通过程序计数器恢复线程执行位置；")]),v._v(" "),_("li",[v._v("若线程执行本地方法（native），计数器值为"),_("code",[v._v("undefined")]),v._v("；")]),v._v(" "),_("li",[v._v("是JVM中唯一"),_("strong",[v._v("不会发生OOM（内存溢出）")]),v._v(" 的区域。")])])])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("虚拟机栈（VM Stack）")])]),v._v(" "),_("ul",[_("li",[v._v("作用：存储线程执行Java方法时的"),_("strong",[v._v("栈帧")]),v._v("（每个方法对应一个栈帧）；")]),v._v(" "),_("li",[v._v("栈帧结构：\n"),_("ul",[_("li",[_("strong",[v._v("局部变量表")]),v._v("：存储方法的局部变量（如基本类型、对象引用），容量以"),_("code",[v._v("Slot")]),v._v("为单位（1个Slot可存boolean/byte/char/short/int/float/reference/returnAddress）；")]),v._v(" "),_("li",[_("strong",[v._v("操作数栈")]),v._v("：执行字节码指令时的临时数据栈（如执行"),_("code",[v._v("iadd")]),v._v("指令时，从栈中弹出两个int相加后压回）；")]),v._v(" "),_("li",[_("strong",[v._v("方法返回地址")]),v._v("：方法执行完后返回的位置（正常返回：调用者的下一条指令；异常返回：通过异常表确定）；")])])]),v._v(" "),_("li",[v._v("风险：递归调用过深或方法嵌套层级过多时，会触发"),_("code",[v._v("StackOverflowError")]),v._v("；若虚拟机栈可动态扩展且扩展失败，会触发"),_("code",[v._v("OutOfMemoryError")]),v._v("。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("本地方法栈（Native Method Stack）")])]),v._v(" "),_("ul",[_("li",[v._v("作用：与虚拟机栈类似，但为本地方法（native）服务；")]),v._v(" "),_("li",[v._v("实现：由JVM厂商自定义（如HotSpot直接将本地方法栈与虚拟机栈合并）；")]),v._v(" "),_("li",[v._v("风险：同样可能发生"),_("code",[v._v("StackOverflowError")]),v._v("或"),_("code",[v._v("OutOfMemoryError")]),v._v("。")])])])]),v._v(" "),_("h3",{attrs:{id:"_3-2-线程共享区域-随jvm启动-销毁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-线程共享区域-随jvm启动-销毁"}},[v._v("#")]),v._v(" 3.2 线程共享区域（随JVM启动/销毁）")]),v._v(" "),_("p",[v._v("线程共享区域被所有线程共享，是GC的主要回收区域。")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("堆（Heap）")])]),v._v(" "),_("ul",[_("li",[v._v("作用：存储所有对象实例和数组（即"),_("code",[v._v("new")]),v._v("关键字创建的对象），是JVM中最大的内存区域；")]),v._v(" "),_("li",[v._v("分代划分（基于“分代收集”思想，不同生命周期的对象用不同回收策略）：\n"),_("ul",[_("li",[_("strong",[v._v("新生代（Young Generation）")]),v._v("：存放刚创建的对象（“朝生夕死”），回收频率高（Minor GC）；\n"),_("ul",[_("li",[v._v("细分为Eden区（80%）和两个Survivor区（From Survivor、To Survivor，各占10%）；")]),v._v(" "),_("li",[v._v("对象创建优先在Eden区分配，Survivor区用于存放Minor GC后存活的对象；")])])]),v._v(" "),_("li",[_("strong",[v._v("老年代（Old Generation）")]),v._v("：存放长时间存活的对象（如多次Minor GC后仍存活）或大对象（超过阈值直接进入），回收频率低（Full GC）；")])])]),v._v(" "),_("li",[v._v("风险：若堆内存不足且无法扩展，会触发"),_("code",[v._v("OutOfMemoryError: Java heap space")]),v._v("。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("元空间（Metaspace）")])]),v._v(" "),_("ul",[_("li",[v._v("作用：存储类信息（如类结构、方法字节码）、常量池（字符串常量池在JDK7后移至堆）、静态变量等；")]),v._v(" "),_("li",[v._v("与永久代的区别：JDK8前使用“永久代”（属于堆的一部分），JDK8后改用元空间（使用本地内存），避免永久代内存溢出问题；")]),v._v(" "),_("li",[v._v("风险：若元空间内存不足，会触发"),_("code",[v._v("OutOfMemoryError: Metaspace")]),v._v("。")])])])]),v._v(" "),_("h2",{attrs:{id:"四、执行引擎-字节码的-执行者"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、执行引擎-字节码的-执行者"}},[v._v("#")]),v._v(" 四、执行引擎：字节码的“执行者”")]),v._v(" "),_("p",[v._v("执行引擎负责解析并执行.class文件中的字节码指令，是连接字节码与底层硬件的核心。Java采用“解释执行+JIT编译”的混合执行模式，兼顾启动速度和运行效率。")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("解释执行")]),_("br"),v._v("\n由解释器（如HotSpot的"),_("code",[v._v("Interpreter")]),v._v("）逐行将字节码翻译为机器码并执行，启动速度快，但执行效率低（重复代码需重复翻译）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("JIT编译（Just-In-Time Compilation）")]),_("br"),v._v("\n当某段代码被频繁执行（称为“热点代码”，如高频调用的方法、循环体），JIT编译器（如HotSpot的"),_("code",[v._v("C1")]),v._v("、"),_("code",[v._v("C2")]),v._v("编译器）会将其一次性编译为机器码并缓存，后续直接执行机器码，大幅提升效率。")]),v._v(" "),_("ul",[_("li",[v._v("热点代码判定：通过“方法调用计数器”和“循环回边计数器”统计执行次数；")]),v._v(" "),_("li",[v._v("分层编译："),_("code",[v._v("C1")]),v._v("（客户端编译器，编译快，优化简单）用于启动阶段，"),_("code",[v._v("C2")]),v._v("（服务端编译器，编译慢，优化深入）用于长期运行的热点代码。")])])])]),v._v(" "),_("h2",{attrs:{id:"五、本地方法接口-java与底层的桥梁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、本地方法接口-java与底层的桥梁"}},[v._v("#")]),v._v(" 五、本地方法接口：Java与底层的桥梁")]),v._v(" "),_("p",[v._v("Java语言的跨平台性牺牲了部分底层操作能力（如直接访问硬件、调用系统API），本地方法接口（JNI，Java Native Interface）通过以下方式弥补：")]),v._v(" "),_("ol",[_("li",[v._v("用"),_("code",[v._v("native")]),v._v("关键字标记需要调用本地方法的Java方法（仅声明，无实现）；")]),v._v(" "),_("li",[v._v("通过JNI将Java方法与C/C++实现的本地方法绑定（如注册本地方法库）；")]),v._v(" "),_("li",[v._v("执行引擎调用本地方法时，通过本地方法栈加载并执行本地代码。")])]),v._v(" "),_("p",[v._v("常见场景："),_("code",[v._v("System.currentTimeMillis()")]),v._v("（获取系统时间）、"),_("code",[v._v("Thread.sleep()")]),v._v("（线程休眠）等。")]),v._v(" "),_("h2",{attrs:{id:"六、垃圾回收-自动内存管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、垃圾回收-自动内存管理"}},[v._v("#")]),v._v(" 六、垃圾回收：自动内存管理")]),v._v(" "),_("p",[v._v("堆和元空间是线程共享区域，对象创建和类加载会持续占用内存，若不及时清理无用数据，会导致内存溢出。GC的核心是"),_("strong",[v._v("自动识别并回收无用对象/类")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"_6-1-垃圾判定算法-可达性分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-垃圾判定算法-可达性分析"}},[v._v("#")]),v._v(" 6.1 垃圾判定算法：可达性分析")]),v._v(" "),_("p",[v._v("JVM通过“可达性分析”判断对象是否可回收：")]),v._v(" "),_("ul",[_("li",[v._v("以"),_("strong",[v._v("GC Root")]),v._v("为起点，向下遍历对象引用链；")]),v._v(" "),_("li",[v._v("若对象无任何引用链连接到GC Root，则为“无用对象”，可被回收。")])]),v._v(" "),_("p",[v._v("GC Root包括：")]),v._v(" "),_("ul",[_("li",[v._v("虚拟机栈中局部变量表的对象引用；")]),v._v(" "),_("li",[v._v("元空间中静态变量的对象引用；")]),v._v(" "),_("li",[v._v("本地方法栈中本地方法的对象引用；")]),v._v(" "),_("li",[v._v("活跃线程（如正在运行的线程对象）。")])]),v._v(" "),_("h3",{attrs:{id:"_6-2-垃圾收集算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-垃圾收集算法"}},[v._v("#")]),v._v(" 6.2 垃圾收集算法")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("复制算法（Copying）")])]),v._v(" "),_("ul",[_("li",[v._v("适用：新生代（对象存活率低）；")]),v._v(" "),_("li",[v._v("过程：将存活对象从Eden区和From Survivor区复制到To Survivor区，清空原区域；")]),v._v(" "),_("li",[v._v("优点：无内存碎片；")]),v._v(" "),_("li",[v._v("缺点：需预留部分内存作为复制目标，内存利用率低。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("标记-清除算法（Mark-Sweep）")])]),v._v(" "),_("ul",[_("li",[v._v("过程：先标记所有无用对象，再统一清理；")]),v._v(" "),_("li",[v._v("优点：无需额外内存；")]),v._v(" "),_("li",[v._v("缺点：产生内存碎片（影响后续大对象分配），效率低（标记和清除均需遍历所有对象）。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("标记-整理算法（Mark-Compact）")])]),v._v(" "),_("ul",[_("li",[v._v("适用：老年代（对象存活率高）；")]),v._v(" "),_("li",[v._v("过程：标记无用对象后，将存活对象向内存一端移动，再清理边界外的无用对象；")]),v._v(" "),_("li",[v._v("优点：无内存碎片；")]),v._v(" "),_("li",[v._v("缺点：移动对象成本高（需更新引用地址）。")])])])]),v._v(" "),_("h3",{attrs:{id:"_6-3-常见垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-常见垃圾收集器"}},[v._v("#")]),v._v(" 6.3 常见垃圾收集器")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("Serial GC")]),v._v("：单线程收集，收集时暂停所有用户线程（STW），适用于单CPU、小堆场景；")]),v._v(" "),_("li",[_("strong",[v._v("Parallel GC")]),v._v("：多线程收集，注重吞吐量（运行用户代码时间/总时间），适用于后台计算；")]),v._v(" "),_("li",[_("strong",[v._v("CMS（Concurrent Mark Sweep）")]),v._v("：并发收集（与用户线程并行），低延迟，适用于响应时间敏感场景（如Web应用）；")]),v._v(" "),_("li",[_("strong",[v._v("G1（Garbage-First）")]),v._v("：面向大堆，将堆划分为多个区域，优先回收垃圾多的区域，兼顾吞吐量和延迟。")])]),v._v(" "),_("h2",{attrs:{id:"七、jvm运行流程-从代码到执行的完整链路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#七、jvm运行流程-从代码到执行的完整链路"}},[v._v("#")]),v._v(" 七、JVM运行流程：从代码到执行的完整链路")]),v._v(" "),_("p",[v._v("以"),_("code",[v._v("User.java")]),v._v("程序为例，梳理JVM的完整运行流程：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("编译阶段")]),v._v("：通过"),_("code",[v._v("javac User.java")]),v._v("将源代码编译为"),_("code",[v._v("User.class")]),v._v("字节码文件（包含类信息、方法指令等）；")]),v._v(" "),_("li",[_("strong",[v._v("启动JVM")]),v._v("：执行"),_("code",[v._v("java User")]),v._v("，JVM初始化（创建主线程、分配运行时数据区等）；")]),v._v(" "),_("li",[_("strong",[v._v("类加载")]),v._v("：主线程执行"),_("code",[v._v("main()")]),v._v("方法时，首次遇到"),_("code",[v._v("new User()")]),v._v("，触发类加载：\n"),_("ul",[_("li",[v._v("应用类加载器委派父加载器尝试加载"),_("code",[v._v("User.class")]),v._v("，最终自己在classpath中找到并加载；")]),v._v(" "),_("li",[v._v("经过加载→校验→准备→解析→初始化，生成"),_("code",[v._v("User")]),v._v("类的"),_("code",[v._v("Class")]),v._v("对象，存入元空间；")])])]),v._v(" "),_("li",[_("strong",[v._v("对象创建")]),v._v("：\n"),_("ul",[_("li",[v._v("JVM在堆的Eden区为"),_("code",[v._v("User")]),v._v("对象分配内存（采用指针碰撞或空闲列表策略）；")]),v._v(" "),_("li",[v._v("初始化对象属性为默认值（如"),_("code",[v._v("int")]),v._v("为0）；")]),v._v(" "),_("li",[v._v("设置对象头（包含类元信息指针、哈希码、GC分代年龄等）；")]),v._v(" "),_("li",[v._v("执行构造方法（"),_("code",[v._v("<init>()")]),v._v("），完成显式初始化，将对象引用存入虚拟机栈的局部变量表；")])])]),v._v(" "),_("li",[_("strong",[v._v("执行代码")]),v._v("：\n"),_("ul",[_("li",[v._v("执行引擎通过解释器逐行执行"),_("code",[v._v("main()")]),v._v("方法的字节码；")]),v._v(" "),_("li",[v._v("若"),_("code",[v._v("User")]),v._v("的"),_("code",[v._v("sayHello()")]),v._v("方法被频繁调用（成为热点代码），JIT编译器将其编译为机器码并缓存，后续直接执行；")]),v._v(" "),_("li",[v._v("若调用"),_("code",[v._v("System.currentTimeMillis()")]),v._v("，通过本地方法接口调用C++实现的本地方法；")])])]),v._v(" "),_("li",[_("strong",[v._v("垃圾回收")]),v._v("：\n"),_("ul",[_("li",[v._v("当Eden区满时，触发Minor GC，通过复制算法回收无用"),_("code",[v._v("User")]),v._v("对象，存活对象进入Survivor区；")]),v._v(" "),_("li",[v._v("若对象多次存活（如年龄达15），晋升至老年代；老年代满时触发Full GC，通过标记-整理算法回收；")])])]),v._v(" "),_("li",[_("strong",[v._v("程序终止")]),v._v("："),_("code",[v._v("main()")]),v._v("方法执行完毕，主线程销毁，虚拟机栈、程序计数器等线程私有区域释放；JVM退出，堆和元空间内存被操作系统回收。")])]),v._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("JVM是Java程序运行的核心引擎，其架构设计（类加载、内存管理、执行引擎等）直接影响程序的安全性、性能和稳定性。")])])}),[],!1,null,null,null);_.default=r.exports}}]);