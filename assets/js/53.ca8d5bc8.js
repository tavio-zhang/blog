(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{408:function(_,v,a){"use strict";a.r(v);var t=a(8),s=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("作为 MySQL 默认且最核心的存储引擎，InnoDB 凭借事务支持、行级锁、MVCC 等特性，成为互联网业务、企业级应用的首选。")]),_._v(" "),v("h2",{attrs:{id:"一、innodb-简介与核心定位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、innodb-简介与核心定位"}},[_._v("#")]),_._v(" 一、InnoDB 简介与核心定位")]),_._v(" "),v("h3",{attrs:{id:"_1-1-存储引擎的本质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-存储引擎的本质"}},[_._v("#")]),_._v(" 1.1 存储引擎的本质")]),_._v(" "),v("p",[_._v("MySQL 采用「插件式存储引擎」架构，存储引擎负责数据的存储、读取、索引管理、事务控制等核心操作。InnoDB 作为 MySQL 5.5+ 版本的默认存储引擎，替代了早期的 MyISAM，其设计目标是"),v("strong",[_._v("支持高并发、高可用、事务安全")]),_._v("的业务场景。")]),_._v(" "),v("p",[_._v("插件式存储引擎（Pluggable Storage Engine） 是 MySQL 数据库的核心架构特性之一 —— 它将数据的存储、检索、事务处理、索引管理、锁机制 等底层数据操作逻辑，设计为可动态加载 / 卸载的 “插件” 模块，而 MySQL 上层（连接管理、SQL 解析、查询优化、缓存等）保持统一。")]),_._v(" "),v("h3",{attrs:{id:"_1-2-innodb-与-myisam-核心对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-innodb-与-myisam-核心对比"}},[_._v("#")]),_._v(" 1.2 InnoDB 与 MyISAM 核心对比")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("特性")]),_._v(" "),v("th",[_._v("InnoDB")]),_._v(" "),v("th",[_._v("MyISAM")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("事务支持")]),_._v(" "),v("td",[_._v("支持 ACID 事务")]),_._v(" "),v("td",[_._v("不支持")])]),_._v(" "),v("tr",[v("td",[_._v("锁粒度")]),_._v(" "),v("td",[_._v("行级锁（默认）+ 表锁")]),_._v(" "),v("td",[_._v("表级锁")])]),_._v(" "),v("tr",[v("td",[_._v("索引类型")]),_._v(" "),v("td",[_._v("聚簇索引 + 辅助索引")]),_._v(" "),v("td",[_._v("非聚簇索引（堆表）")])]),_._v(" "),v("tr",[v("td",[_._v("数据一致性")]),_._v(" "),v("td",[_._v("支持外键、崩溃恢复")]),_._v(" "),v("td",[_._v("不支持外键，崩溃恢复依赖 myisamchk")])]),_._v(" "),v("tr",[v("td",[_._v("并发性能")]),_._v(" "),v("td",[_._v("高（行锁+MVCC 读写不冲突）")]),_._v(" "),v("td",[_._v("低（表锁导致并发阻塞）")])]),_._v(" "),v("tr",[v("td",[_._v("存储结构")]),_._v(" "),v("td",[_._v("数据与索引存储在 .ibd 文件中")]),_._v(" "),v("td",[_._v("数据(.MYD)与索引(.MYI)分离")])]),_._v(" "),v("tr",[v("td",[_._v("适用场景")]),_._v(" "),v("td",[_._v("互联网业务、金融支付、电商订单")]),_._v(" "),v("td",[_._v("只读场景、日志存储、小型应用")])])])]),_._v(" "),v("h3",{attrs:{id:"_1-3-innodb-的核心优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-innodb-的核心优势"}},[_._v("#")]),_._v(" 1.3 InnoDB 的核心优势")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("事务安全")]),_._v("：支持 ACID 事务，通过日志机制保证崩溃恢复。")]),_._v(" "),v("li",[v("strong",[_._v("高并发支持")]),_._v("：行级锁减少锁冲突，MVCC 实现读写分离，提升并发吞吐量。")]),_._v(" "),v("li",[v("strong",[_._v("高效索引")]),_._v("：聚簇索引设计，数据按主键有序存储，查询效率更高。")]),_._v(" "),v("li",[v("strong",[_._v("数据可靠性")]),_._v("：支持外键约束、崩溃恢复、数据加密等特性。")]),_._v(" "),v("li",[v("strong",[_._v("扩展性")]),_._v("：支持分区表、大表存储（最大表大小可达 64TB）。")])]),_._v(" "),v("h2",{attrs:{id:"二、innodb-底层架构解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、innodb-底层架构解析"}},[_._v("#")]),_._v(" 二、InnoDB 底层架构解析")]),_._v(" "),v("p",[_._v("InnoDB 的架构设计围绕「内存缓冲 + 磁盘持久化」展开，核心分为"),v("strong",[_._v("内存结构")]),_._v("和"),v("strong",[_._v("磁盘结构")]),_._v("两部分，两者通过日志机制协同工作，保证数据一致性和性能。")]),_._v(" "),v("h3",{attrs:{id:"_2-1-内存结构-in-memory-structures"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-内存结构-in-memory-structures"}},[_._v("#")]),_._v(" 2.1 内存结构（In-Memory Structures）")]),_._v(" "),v("p",[_._v("内存结构的核心作用是"),v("strong",[_._v("缓存热点数据、加速读写操作")]),_._v("，减少磁盘 I/O 开销。")]),_._v(" "),v("h4",{attrs:{id:"_2-1-1-缓冲池-buffer-pool"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-缓冲池-buffer-pool"}},[_._v("#")]),_._v(" 2.1.1 缓冲池（Buffer Pool）")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("定义")]),_._v("：InnoDB 最核心的内存组件，占 MySQL 内存分配的 70%-80%（通过 "),v("code",[_._v("innodb_buffer_pool_size")]),_._v(" 配置），用于缓存磁盘上的表数据、索引数据、undo 日志等。")]),_._v(" "),v("li",[v("strong",[_._v("结构")]),_._v("：缓冲池由多个「页（Page）」组成，每页大小默认 16KB（可通过 "),v("code",[_._v("innodb_page_size")]),_._v(" 配置为 4K/8K/32K/64K），与磁盘数据页一一对应。")]),_._v(" "),v("li",[v("strong",[_._v("缓存策略")]),_._v("：\n"),v("ul",[v("li",[_._v("采用 LRU（最近最少使用）算法管理页面淘汰，分为「新生代（Young List）」和「老生代（Old List）」，默认比例 5:3。")]),_._v(" "),v("li",[_._v("当读取数据时，先检查缓冲池是否存在目标页：存在则直接读取（缓存命中），不存在则从磁盘加载到缓冲池（缓存未命中）。")]),_._v(" "),v("li",[_._v("写入数据时，先修改缓冲池中的页面（脏页），再通过后台线程异步刷盘（Checkpoint 机制），避免频繁磁盘 I/O。")])])])]),_._v(" "),v("h4",{attrs:{id:"_2-1-2-日志缓冲区-log-buffer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-日志缓冲区-log-buffer"}},[_._v("#")]),_._v(" 2.1.2 日志缓冲区（Log Buffer）")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("定义")]),_._v("：用于临时存储重做日志（Redo Log）和undo 日志（Undo Log），避免频繁写入磁盘。")]),_._v(" "),v("li",[v("strong",[_._v("刷新策略")]),_._v("：\n"),v("ul",[v("li",[_._v("重做日志：默认通过 "),v("code",[_._v("innodb_flush_log_at_trx_commit")]),_._v(" 控制，取值 0/1/2（生产环境建议设为 1，保证事务 ACID）。\n"),v("ul",[v("li",[_._v("0：每秒刷新到磁盘（可能丢失 1 秒内的数据）。")]),_._v(" "),v("li",[_._v("1：事务提交时同步刷新到磁盘（最安全）。")]),_._v(" "),v("li",[_._v("2：事务提交时写入操作系统缓存，每秒刷新到磁盘（可能丢失操作系统崩溃前的数据）。")])])]),_._v(" "),v("li",[_._v("Undo 日志：默认随事务提交刷新，或通过 "),v("code",[_._v("innodb_log_buffer_size")]),_._v(" 控制缓冲区大小（默认 16MB）。")])])])]),_._v(" "),v("h4",{attrs:{id:"_2-1-3-其他内存组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-其他内存组件"}},[_._v("#")]),_._v(" 2.1.3 其他内存组件")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("自适应哈希索引（Adaptive Hash Index, AHI）")]),_._v("：InnoDB 自动将频繁访问的索引页转换为哈希索引，加速等值查询（如 "),v("code",[_._v("WHERE id = 100")]),_._v("），无需手动配置。")]),_._v(" "),v("li",[v("strong",[_._v("锁结构缓存")]),_._v("：存储当前活跃的锁信息，避免频繁创建和销毁锁对象。")]),_._v(" "),v("li",[v("strong",[_._v("数据字典缓存")]),_._v("：缓存表结构、列信息、索引信息等元数据，加速 SQL 解析。")])]),_._v(" "),v("h3",{attrs:{id:"_2-2-磁盘结构-on-disk-structures"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-磁盘结构-on-disk-structures"}},[_._v("#")]),_._v(" 2.2 磁盘结构（On-Disk Structures）")]),_._v(" "),v("p",[_._v("磁盘结构负责数据的持久化存储，核心包括"),v("strong",[_._v("数据文件、日志文件、系统表空间")]),_._v("等。")]),_._v(" "),v("h4",{attrs:{id:"_2-2-1-表空间-tablespace"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-表空间-tablespace"}},[_._v("#")]),_._v(" 2.2.1 表空间（Tablespace）")]),_._v(" "),v("p",[_._v("表空间是 InnoDB 存储数据的逻辑容器，分为以下类型：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("系统表空间（System Tablespace）")]),_._v("：\n"),v("ul",[v("li",[_._v("默认包含 "),v("code",[_._v("ibdata1")]),_._v("、"),v("code",[_._v("ibdata2")]),_._v(" 等文件（可通过 "),v("code",[_._v("innodb_data_file_path")]),_._v(" 配置），存储系统数据（如数据字典、undo 日志、临时表空间）和共享表数据（未开启独立表空间时）。")]),_._v(" "),v("li",[_._v("缺点：单文件膨胀后难以收缩，建议生产环境开启独立表空间。")])])]),_._v(" "),v("li",[v("strong",[_._v("独立表空间（File-Per-Table Tablespace）")]),_._v("：\n"),v("ul",[v("li",[_._v("每个表对应一个 "),v("code",[_._v(".ibd")]),_._v(" 文件（如 "),v("code",[_._v("user.ibd")]),_._v("），存储表数据和索引，通过 "),v("code",[_._v("innodb_file_per_table = ON")]),_._v(" 开启（MySQL 5.6+ 默认开启）。")]),_._v(" "),v("li",[_._v("优势：表删除时可回收磁盘空间，便于管理大表。")])])]),_._v(" "),v("li",[v("strong",[_._v("通用表空间（General Tablespace）")]),_._v("：\n"),v("ul",[v("li",[_._v("手动创建的共享表空间（如 "),v("code",[_._v("CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'")]),_._v("），可存储多个表，支持分区表和大表存储。")])])]),_._v(" "),v("li",[v("strong",[_._v("临时表空间（Temporary Tablespace）")]),_._v("：\n"),v("ul",[v("li",[_._v("存储临时表数据（如 "),v("code",[_._v("CREATE TEMPORARY TABLE")]),_._v("），分为会话级临时表空间（"),v("code",[_._v("ibtmp1")]),_._v("）和全局临时表空间，数据库重启后自动清空。")])])])]),_._v(" "),v("h4",{attrs:{id:"_2-2-2-数据页-data-page"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-数据页-data-page"}},[_._v("#")]),_._v(" 2.2.2 数据页（Data Page）")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("定义")]),_._v("：InnoDB 磁盘存储的最小单位，默认 16KB，与缓冲池页面大小一致。")]),_._v(" "),v("li",[v("strong",[_._v("页结构")]),_._v("：\n"),v("ul",[v("li",[_._v("页头（Page Header）：存储页类型、页编号、上一页/下一页指针（维护链表结构）。")]),_._v(" "),v("li",[_._v("页体（Page Body）：存储实际数据记录（聚簇索引页）或索引条目（辅助索引页）。")]),_._v(" "),v("li",[_._v("页尾（Page Trailer）：存储校验和和日志序列号（LSN），用于校验页完整性。")])])]),_._v(" "),v("li",[v("strong",[_._v("页类型")]),_._v("：\n"),v("ul",[v("li",[_._v("聚簇索引页（Leaf Page）：存储数据记录和主键索引。")]),_._v(" "),v("li",[_._v("辅助索引页（Non-Leaf Page）：存储辅助索引条目（索引值 + 主键值）。")]),_._v(" "),v("li",[_._v("Undo 日志页：存储 undo 日志记录。")])])])]),_._v(" "),v("h4",{attrs:{id:"_2-2-3-日志文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-日志文件"}},[_._v("#")]),_._v(" 2.2.3 日志文件")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("重做日志文件（Redo Log File）")]),_._v("：\n"),v("ul",[v("li",[_._v("默认名称为 "),v("code",[_._v("ib_logfile0")]),_._v("、"),v("code",[_._v("ib_logfile1")]),_._v("，用于记录数据页的修改操作（如插入、更新、删除），保证事务持久性。")]),_._v(" "),v("li",[_._v("特点：循环写入（文件满后覆盖旧日志），大小通过 "),v("code",[_._v("innodb_log_file_size")]),_._v(" 配置（建议设为 2G-4G，避免频繁切换日志），数量通过 "),v("code",[_._v("innodb_log_files_in_group")]),_._v(" 配置（默认 2 个）。")]),_._v(" "),v("li",[_._v("核心作用：数据库崩溃后，通过重做日志恢复未刷盘的脏页数据。")])])]),_._v(" "),v("li",[v("strong",[_._v("Undo 日志文件（Undo Log File）")]),_._v("：\n"),v("ul",[v("li",[_._v("存储事务执行前的数据镜像（如更新前的旧值、删除前的记录），用于事务回滚（ROLLBACK）和 MVCC 读取。")]),_._v(" "),v("li",[_._v("存储位置：默认在系统表空间，MySQL 8.0 后可独立存储（通过 "),v("code",[_._v("innodb_undo_tablespaces")]),_._v(" 配置）。")])])]),_._v(" "),v("li",[v("strong",[_._v("二进制日志（Binary Log）")]),_._v("：\n"),v("ul",[v("li",[_._v("不属于 InnoDB 存储引擎，但与事务密切相关，记录所有 DDL 和 DML 操作（除查询语句），用于主从复制和数据恢复。")]),_._v(" "),v("li",[_._v("与重做日志的区别：\n"),v("ul",[v("li",[_._v("重做日志：物理日志，记录数据页的修改（如“修改页 123 的偏移量 456 为值 789”）。")]),_._v(" "),v("li",[_._v("二进制日志：逻辑日志，记录 SQL 操作（如“UPDATE user SET name = 'xxx' WHERE id = 100”）。")])])])])])]),_._v(" "),v("h4",{attrs:{id:"_2-2-4-数据字典-data-dictionary"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-数据字典-data-dictionary"}},[_._v("#")]),_._v(" 2.2.4 数据字典（Data Dictionary）")]),_._v(" "),v("ul",[v("li",[_._v("存储表结构、列定义、索引信息、表空间信息等元数据，MySQL 8.0 前存储在系统表空间，8.0 后独立为 "),v("code",[_._v("mysql.ibd")]),_._v(" 文件，提升安全性和可维护性。")])]),_._v(" "),v("h2",{attrs:{id:"三、innodb-索引机制深度解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、innodb-索引机制深度解析"}},[_._v("#")]),_._v(" 三、InnoDB 索引机制深度解析")]),_._v(" "),v("p",[_._v("索引是数据库性能优化的核心，InnoDB 采用「B+ 树索引」作为默认索引结构，结合「聚簇索引」设计，大幅提升查询效率。")]),_._v(" "),v("h3",{attrs:{id:"_3-1-索引的本质与分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-索引的本质与分类"}},[_._v("#")]),_._v(" 3.1 索引的本质与分类")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("本质")]),_._v("：索引是帮助数据库快速查找数据的数据结构，相当于书籍的目录。")]),_._v(" "),v("li",[v("strong",[_._v("InnoDB 支持的索引类型")]),_._v("：\n"),v("ul",[v("li",[_._v("聚簇索引（Clustered Index）：主键索引，数据与索引存储在一起，索引的叶子节点就是数据记录。")]),_._v(" "),v("li",[_._v("辅助索引（Secondary Index）：非主键索引（如普通索引、唯一索引、联合索引），叶子节点存储索引值和主键值。")]),_._v(" "),v("li",[_._v("全文索引：用于文本内容的模糊查询（如 "),v("code",[_._v("MATCH(name) AGAINST('xxx')")]),_._v("），基于倒排索引实现。")]),_._v(" "),v("li",[_._v("空间索引：用于地理空间数据查询（如 "),v("code",[_._v("ST_Contains(geom, point)")]),_._v("）。")])])])]),_._v(" "),v("h3",{attrs:{id:"_3-2-b-树索引结构细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-b-树索引结构细节"}},[_._v("#")]),_._v(" 3.2 B+ 树索引结构细节")]),_._v(" "),v("p",[_._v("InnoDB 的 B+ 树索引是「平衡多路查找树」，具有以下特点：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("结构层次")]),_._v("：分为根节点、非叶子节点、叶子节点，层数通常为 2-4 层（百万级数据约 3 层，亿级数据约 4 层），查询时只需 2-4 次磁盘 I/O。")]),_._v(" "),v("li",[v("strong",[_._v("节点结构")]),_._v("：\n"),v("ul",[v("li",[_._v("非叶子节点：存储索引值和叶子节点指针（如主键范围 + 子节点页号），不存储数据。")]),_._v(" "),v("li",[_._v("叶子节点：\n"),v("ul",[v("li",[_._v("聚簇索引：存储完整数据记录，按主键有序排列，叶子节点通过双向链表连接（支持范围查询）。")]),_._v(" "),v("li",[_._v("辅助索引：存储索引值 + 主键值，按索引值有序排列，叶子节点同样通过双向链表连接。")])])])])]),_._v(" "),v("li",[v("strong",[_._v("示例")]),_._v("：假设主键为 "),v("code",[_._v("id")]),_._v("（INT 类型，4 字节），聚簇索引 B+ 树结构如下：\n"),v("ul",[v("li",[_._v("根节点：存储主键范围（如 1-1000、1001-2000）和子节点页号。")]),_._v(" "),v("li",[_._v("非叶子节点：存储更细粒度的主键范围（如 1-100、101-200）和子节点页号。")]),_._v(" "),v("li",[_._v("叶子节点：存储 "),v("code",[_._v("id")]),_._v(" 对应的完整数据记录（如 "),v("code",[_._v("id=1, name='xxx', age=20")]),_._v("），按 "),v("code",[_._v("id")]),_._v(" 升序排列。")])])])]),_._v(" "),v("h3",{attrs:{id:"_3-3-聚簇索引-vs-辅助索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-聚簇索引-vs-辅助索引"}},[_._v("#")]),_._v(" 3.3 聚簇索引 vs 辅助索引")]),_._v(" "),v("h4",{attrs:{id:"_3-3-1-聚簇索引-主键索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-聚簇索引-主键索引"}},[_._v("#")]),_._v(" 3.3.1 聚簇索引（主键索引）")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("创建规则")]),_._v("：\n"),v("ul",[v("li",[_._v("若表定义了主键（PRIMARY KEY），则主键作为聚簇索引。")]),_._v(" "),v("li",[_._v("若未定义主键，则选择第一个非空唯一索引（UNIQUE NOT NULL）作为聚簇索引。")]),_._v(" "),v("li",[_._v("若既无主键也无非空唯一索引，则 InnoDB 自动生成一个隐藏的聚簇索引（"),v("code",[_._v("row_id")]),_._v("，6 字节，自增）。")])])]),_._v(" "),v("li",[v("strong",[_._v("优势")]),_._v("：\n"),v("ul",[v("li",[_._v("按主键查询时，直接定位到数据记录，无需回表。")]),_._v(" "),v("li",[_._v("范围查询（如 "),v("code",[_._v("WHERE id BETWEEN 100 AND 200")]),_._v("）效率高，通过叶子节点的双向链表快速遍历。")])])]),_._v(" "),v("li",[v("strong",[_._v("注意事项")]),_._v("：\n"),v("ul",[v("li",[_._v("主键建议使用自增 INT/BIGINT 类型：避免主键值无序导致的页分裂（Page Split），保证数据有序插入。")]),_._v(" "),v("li",[_._v("不建议使用 UUID 作为主键：UUID 无序，插入时会频繁触发页分裂，降低写入性能。")])])])]),_._v(" "),v("h4",{attrs:{id:"_3-3-2-辅助索引-非主键索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-辅助索引-非主键索引"}},[_._v("#")]),_._v(" 3.3.2 辅助索引（非主键索引）")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("查询流程")]),_._v("：\n"),v("ol",[v("li",[_._v("通过辅助索引 B+ 树查找目标索引值，得到对应的主键值。")]),_._v(" "),v("li",[_._v("再通过聚簇索引 B+ 树查找主键值对应的 data 记录（回表操作）。")])])]),_._v(" "),v("li",[v("strong",[_._v("覆盖索引（Covering Index）")]),_._v("：\n"),v("ul",[v("li",[_._v("若查询的列都包含在辅助索引中（如 "),v("code",[_._v("SELECT id, name FROM user WHERE name = 'xxx'")]),_._v("，"),v("code",[_._v("name")]),_._v(" 是辅助索引，包含 "),v("code",[_._v("name")]),_._v(" 和 "),v("code",[_._v("id")]),_._v("），则无需回表，直接从辅助索引获取数据，效率极高。")]),_._v(" "),v("li",[_._v("设计联合索引时，可将查询频繁的列放在索引中，实现覆盖索引（如联合索引 "),v("code",[_._v("(name, age)")]),_._v(" 可覆盖 "),v("code",[_._v("SELECT name, age FROM user WHERE name = 'xxx'")]),_._v("）。")])])])]),_._v(" "),v("h3",{attrs:{id:"_3-4-联合索引与最左前缀原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-联合索引与最左前缀原则"}},[_._v("#")]),_._v(" 3.4 联合索引与最左前缀原则")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("联合索引定义")]),_._v("：由多个列组成的索引（如 "),v("code",[_._v("CREATE INDEX idx_name_age ON user(name, age)")]),_._v("），B+ 树按「第一列 → 第二列 → ...」的顺序排序。")]),_._v(" "),v("li",[v("strong",[_._v("最左前缀原则")]),_._v("：查询时必须匹配联合索引的最左列，否则索引失效。\n"),v("ul",[v("li",[_._v("有效查询："),v("code",[_._v("WHERE name = 'xxx'")]),_._v("、"),v("code",[_._v("WHERE name = 'xxx' AND age = 20")]),_._v("、"),v("code",[_._v("WHERE name LIKE 'xxx%'")]),_._v("（前缀匹配）。")]),_._v(" "),v("li",[_._v("无效查询："),v("code",[_._v("WHERE age = 20")]),_._v("（未匹配最左列 "),v("code",[_._v("name")]),_._v("）、"),v("code",[_._v("WHERE name LIKE '%xxx'")]),_._v("（后缀匹配）、"),v("code",[_._v("WHERE name LIKE '%xxx%'")]),_._v("（模糊匹配）。")])])]),_._v(" "),v("li",[v("strong",[_._v("联合索引优化技巧")]),_._v("：\n"),v("ul",[v("li",[_._v("将区分度高的列放在前面（如 "),v("code",[_._v("name")]),_._v(" 区分度高于 "),v("code",[_._v("age")]),_._v("），减少索引扫描范围。")]),_._v(" "),v("li",[_._v("将查询频繁的列放在前面，优先匹配索引。")])])])]),_._v(" "),v("h3",{attrs:{id:"_3-5-索引失效的常见场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-索引失效的常见场景"}},[_._v("#")]),_._v(" 3.5 索引失效的常见场景")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("函数或表达式操作索引列")]),_._v("："),v("code",[_._v("WHERE DATE(create_time) = '2024-01-01'")]),_._v("（应改为 "),v("code",[_._v("WHERE create_time BETWEEN '2024-01-01 00:00:00' AND '2024-01-01 23:59:59'")]),_._v("）。")]),_._v(" "),v("li",[v("strong",[_._v("隐式类型转换")]),_._v("："),v("code",[_._v("WHERE id = '100'")]),_._v("（"),v("code",[_._v("id")]),_._v(" 为 INT 类型，字符串 '100' 会转换为 INT，导致索引失效）。")]),_._v(" "),v("li",[v("strong",[_._v("模糊查询前缀为 %")]),_._v("："),v("code",[_._v("WHERE name LIKE '%xxx'")]),_._v("（无法使用索引，可通过全文索引优化）。")]),_._v(" "),v("li",[v("strong",[_._v("使用 OR 连接非索引列")]),_._v("："),v("code",[_._v("WHERE name = 'xxx' OR age = 20")]),_._v("（若 "),v("code",[_._v("age")]),_._v(" 无索引，则索引失效）。")]),_._v(" "),v("li",[v("strong",[_._v("联合索引不满足最左前缀原则")]),_._v("：如联合索引 "),v("code",[_._v("(name, age)")]),_._v("，查询 "),v("code",[_._v("WHERE age = 20")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("使用 NOT IN、!=、IS NOT NULL")]),_._v("：这些操作可能导致索引失效，建议用 "),v("code",[_._v("IN")]),_._v("、"),v("code",[_._v("=")]),_._v("、"),v("code",[_._v("IS NULL")]),_._v(" 替代，或通过覆盖索引优化。")])]),_._v(" "),v("h2",{attrs:{id:"四、innodb-事务实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、innodb-事务实现原理"}},[_._v("#")]),_._v(" 四、InnoDB 事务实现原理")]),_._v(" "),v("p",[_._v("事务是数据库并发控制的基础，InnoDB 通过「日志机制」和「锁机制」实现事务的 ACID 特性。")]),_._v(" "),v("h3",{attrs:{id:"_4-1-事务的-acid-特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-事务的-acid-特性"}},[_._v("#")]),_._v(" 4.1 事务的 ACID 特性")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("原子性（Atomicity）")]),_._v("：事务中的操作要么全部执行，要么全部回滚（如转账时，扣款和到账必须同时成功或失败）。")]),_._v(" "),v("li",[v("strong",[_._v("一致性（Consistency）")]),_._v("：事务执行前后，数据库数据保持逻辑一致（如转账前后，双方账户总额不变）。")]),_._v(" "),v("li",[v("strong",[_._v("隔离性（Isolation）")]),_._v("：多个事务并发执行时，一个事务的操作不会影响其他事务（通过隔离级别控制）。")]),_._v(" "),v("li",[v("strong",[_._v("持久性（Durability）")]),_._v("：事务提交后，数据永久存储在磁盘上，即使数据库崩溃也不会丢失。")])]),_._v(" "),v("h3",{attrs:{id:"_4-2-事务隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-事务隔离级别"}},[_._v("#")]),_._v(" 4.2 事务隔离级别")]),_._v(" "),v("p",[_._v("InnoDB 支持 4 种事务隔离级别（由 "),v("code",[_._v("transaction_isolation")]),_._v(" 配置），从低到高依次为：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("隔离级别")]),_._v(" "),v("th",[_._v("脏读（Dirty Read）")]),_._v(" "),v("th",[_._v("不可重复读（Non-Repeatable Read）")]),_._v(" "),v("th",[_._v("幻读（Phantom Read）")]),_._v(" "),v("th",[_._v("实现原理")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("读未提交（Read Uncommitted）")]),_._v(" "),v("td",[_._v("允许")]),_._v(" "),v("td",[_._v("允许")]),_._v(" "),v("td",[_._v("允许")]),_._v(" "),v("td",[_._v("无锁，直接读取未提交数据")])]),_._v(" "),v("tr",[v("td",[_._v("读已提交（Read Committed）")]),_._v(" "),v("td",[_._v("禁止")]),_._v(" "),v("td",[_._v("允许")]),_._v(" "),v("td",[_._v("允许")]),_._v(" "),v("td",[_._v("MVCC（Read View 每次查询生成）")])]),_._v(" "),v("tr",[v("td",[_._v("可重复读（Repeatable Read）")]),_._v(" "),v("td",[_._v("禁止")]),_._v(" "),v("td",[_._v("禁止")]),_._v(" "),v("td",[_._v("禁止（InnoDB 优化）")]),_._v(" "),v("td",[_._v("MVCC（Read View 事务开始生成）")])]),_._v(" "),v("tr",[v("td",[_._v("串行化（Serializable）")]),_._v(" "),v("td",[_._v("禁止")]),_._v(" "),v("td",[_._v("禁止")]),_._v(" "),v("td",[_._v("禁止")]),_._v(" "),v("td",[_._v("表级锁，事务串行执行")])])])]),_._v(" "),v("h4",{attrs:{id:"关键说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关键说明"}},[_._v("#")]),_._v(" 关键说明：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("脏读")]),_._v("：读取到其他事务未提交的修改（如事务 A 更新了数据但未提交，事务 B 读取了该数据，之后事务 A 回滚，事务 B 读取的是无效数据）。")]),_._v(" "),v("li",[v("strong",[_._v("不可重复读")]),_._v("：同一事务内，多次读取同一数据，结果不一致（如事务 A 第一次读取数据为 100，事务 B 更新数据为 200 并提交，事务 A 再次读取数据为 200）。")]),_._v(" "),v("li",[v("strong",[_._v("幻读")]),_._v("：同一事务内，多次执行同一查询，返回的结果集行数不一致（如事务 A 执行 "),v("code",[_._v("SELECT * FROM user WHERE age > 20")]),_._v(" 返回 10 条记录，事务 B 插入一条 "),v("code",[_._v("age=25")]),_._v(" 的记录并提交，事务 A 再次执行同一查询返回 11 条记录）。")]),_._v(" "),v("li",[v("strong",[_._v("InnoDB 对幻读的优化")]),_._v("：在「可重复读」隔离级别下，通过「Next-Key Lock」机制禁止幻读，无需升级到串行化级别。")])]),_._v(" "),v("h3",{attrs:{id:"_4-3-mvcc-实现原理-多版本并发控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-mvcc-实现原理-多版本并发控制"}},[_._v("#")]),_._v(" 4.3 MVCC 实现原理（多版本并发控制）")]),_._v(" "),v("p",[_._v("MVCC 是 InnoDB 实现「读已提交」和「可重复读」隔离级别的核心技术，通过「版本链」和「Read View」实现读写不冲突。")]),_._v(" "),v("h4",{attrs:{id:"_4-3-1-版本链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-版本链"}},[_._v("#")]),_._v(" 4.3.1 版本链")]),_._v(" "),v("ul",[v("li",[_._v("每个数据记录包含隐藏列：\n"),v("ul",[v("li",[v("code",[_._v("DB_TRX_ID")]),_._v("：修改该记录的事务 ID。")]),_._v(" "),v("li",[v("code",[_._v("DB_ROLL_PTR")]),_._v("：指向 undo 日志的指针（用于回滚数据）。")]),_._v(" "),v("li",[v("code",[_._v("DB_ROW_ID")]),_._v("：隐藏主键（无主键时自动生成）。")])])]),_._v(" "),v("li",[_._v("当事务修改数据时，InnoDB 会：\n"),v("ol",[v("li",[_._v("复制原记录到 undo 日志（形成历史版本）。")]),_._v(" "),v("li",[_._v("修改原记录的 "),v("code",[_._v("DB_TRX_ID")]),_._v(" 为当前事务 ID，"),v("code",[_._v("DB_ROLL_PTR")]),_._v(" 指向 undo 日志中的历史版本。")]),_._v(" "),v("li",[_._v("多次修改后，形成一条「版本链」（最新版本在数据页，历史版本在 undo 日志）。")])])])]),_._v(" "),v("h4",{attrs:{id:"_4-3-2-read-view-读视图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-read-view-读视图"}},[_._v("#")]),_._v(" 4.3.2 Read View（读视图）")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("定义")]),_._v("：事务读取数据时的「快照」，包含当前活跃事务的 ID 列表，用于判断数据版本是否可见。")]),_._v(" "),v("li",[v("strong",[_._v("核心逻辑")]),_._v("：\n"),v("ul",[v("li",[_._v("对于数据记录的某个版本，若其 "),v("code",[_._v("DB_TRX_ID")]),_._v(" 小于 Read View 中的最小活跃事务 ID（"),v("code",[_._v("min_trx_id")]),_._v("）：该版本是已提交事务修改的，可见。")]),_._v(" "),v("li",[_._v("若 "),v("code",[_._v("DB_TRX_ID")]),_._v(" 大于 Read View 中的最大活跃事务 ID（"),v("code",[_._v("max_trx_id")]),_._v("）：该版本是未提交事务修改的，不可见，需通过 "),v("code",[_._v("DB_ROLL_PTR")]),_._v(" 回滚到上一版本。")]),_._v(" "),v("li",[_._v("若 "),v("code",[_._v("DB_TRX_ID")]),_._v(" 在 "),v("code",[_._v("min_trx_id")]),_._v(" 和 "),v("code",[_._v("max_trx_id")]),_._v(" 之间：判断该事务是否在活跃列表中，不在则可见，在则回滚。")])])]),_._v(" "),v("li",[v("strong",[_._v("隔离级别与 Read View 生成时机")]),_._v("：\n"),v("ul",[v("li",[_._v("读已提交（RC）：每次查询时生成 Read View → 同一事务内多次查询可能看到不同版本（不可重复读）。")]),_._v(" "),v("li",[_._v("可重复读（RR）：事务开始时生成 Read View → 同一事务内多次查询看到同一版本（可重复读）。")])])])]),_._v(" "),v("h3",{attrs:{id:"_4-4-事务日志-redo-log-与-undo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-事务日志-redo-log-与-undo-log"}},[_._v("#")]),_._v(" 4.4 事务日志：Redo Log 与 Undo Log")]),_._v(" "),v("p",[_._v("InnoDB 通过两种日志保证事务的原子性和持久性：")]),_._v(" "),v("h4",{attrs:{id:"_4-4-1-重做日志-redo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1-重做日志-redo-log"}},[_._v("#")]),_._v(" 4.4.1 重做日志（Redo Log）")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("作用")]),_._v("：保证事务持久性，记录数据页的修改操作（如“页 123 的偏移量 456 从 100 改为 200”）。")]),_._v(" "),v("li",[v("strong",[_._v("写入流程")]),_._v("：\n"),v("ol",[v("li",[_._v("事务执行时，修改缓冲池中的数据页（脏页），同时将修改操作写入日志缓冲区（Log Buffer）。")]),_._v(" "),v("li",[_._v("事务提交时，日志缓冲区的 Redo Log 同步刷新到磁盘（"),v("code",[_._v("innodb_flush_log_at_trx_commit = 1")]),_._v("）。")]),_._v(" "),v("li",[_._v("后台线程异步将脏页刷盘，若刷盘前数据库崩溃，重启后通过 Redo Log 恢复脏页数据。")])])]),_._v(" "),v("li",[v("strong",[_._v("WAL 机制")]),_._v("：Write-Ahead Logging（预写日志），即先写日志，再写数据，保证日志写入成功后，即使数据未刷盘，也可通过日志恢复。")])]),_._v(" "),v("h4",{attrs:{id:"_4-4-2-undo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2-undo-log"}},[_._v("#")]),_._v(" 4.4.2 Undo Log")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("作用")]),_._v("：保证事务原子性，记录数据修改前的历史版本，用于事务回滚和 MVCC 读取。")]),_._v(" "),v("li",[v("strong",[_._v("类型")]),_._v("：\n"),v("ul",[v("li",[_._v("插入 undo 日志（Insert Undo Log）：记录插入操作，事务提交后可立即删除（插入的记录仅当前事务可见）。")]),_._v(" "),v("li",[_._v("更新 undo 日志（Update Undo Log）：记录更新/删除操作，事务提交后需保留一段时间（供 MVCC 读取），之后由 purge 线程清理。")])])]),_._v(" "),v("li",[v("strong",[_._v("回滚流程")]),_._v("：事务执行 ROLLBACK 时，InnoDB 遍历 Undo Log，将数据恢复到修改前的版本。")])]),_._v(" "),v("h3",{attrs:{id:"_4-5-事务提交与回滚流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-事务提交与回滚流程"}},[_._v("#")]),_._v(" 4.5 事务提交与回滚流程")]),_._v(" "),v("h4",{attrs:{id:"提交流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提交流程"}},[_._v("#")]),_._v(" 提交流程：")]),_._v(" "),v("ol",[v("li",[_._v("执行 SQL 操作，修改缓冲池数据页，生成 Redo Log 和 Undo Log 到日志缓冲区。")]),_._v(" "),v("li",[_._v("调用 "),v("code",[_._v("COMMIT")]),_._v(" 命令，触发日志缓冲区的 Redo Log 同步刷盘。")]),_._v(" "),v("li",[_._v("释放事务占用的锁资源。")]),_._v(" "),v("li",[_._v("标记事务为已提交，异步刷脏页到磁盘。")])]),_._v(" "),v("h4",{attrs:{id:"回滚流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回滚流程"}},[_._v("#")]),_._v(" 回滚流程：")]),_._v(" "),v("ol",[v("li",[_._v("调用 "),v("code",[_._v("ROLLBACK")]),_._v(" 命令，InnoDB 遍历当前事务的 Undo Log。")]),_._v(" "),v("li",[_._v("根据 Undo Log 恢复数据到修改前的版本。")]),_._v(" "),v("li",[_._v("释放事务占用的锁资源。")]),_._v(" "),v("li",[_._v("标记事务为已回滚，清理相关日志。")])]),_._v(" "),v("h2",{attrs:{id:"五、innodb-锁机制详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、innodb-锁机制详解"}},[_._v("#")]),_._v(" 五、InnoDB 锁机制详解")]),_._v(" "),v("p",[_._v("锁是 InnoDB 实现事务隔离性的核心，通过锁控制并发事务的访问顺序，避免数据竞争。")]),_._v(" "),v("h3",{attrs:{id:"_5-1-锁的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-锁的分类"}},[_._v("#")]),_._v(" 5.1 锁的分类")]),_._v(" "),v("h4",{attrs:{id:"_5-1-1-按锁粒度分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-按锁粒度分类"}},[_._v("#")]),_._v(" 5.1.1 按锁粒度分类")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("行级锁（Row Lock）")]),_._v("：锁定单个数据记录，粒度最小，并发性能最高，InnoDB 默认锁机制。")]),_._v(" "),v("li",[v("strong",[_._v("表级锁（Table Lock）")]),_._v("：锁定整个表，粒度最大，并发性能最低，仅在无索引查询、DDL 操作时触发。")]),_._v(" "),v("li",[v("strong",[_._v("页级锁（Page Lock）")]),_._v("：锁定数据页（16KB），粒度介于行级锁和表级锁之间，InnoDB 不常用。")])]),_._v(" "),v("h4",{attrs:{id:"_5-1-2-按锁模式分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-2-按锁模式分类"}},[_._v("#")]),_._v(" 5.1.2 按锁模式分类")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("共享锁（S 锁，读锁）")]),_._v("：多个事务可同时持有，允许其他事务加 S 锁，但禁止加 X 锁（读-读不冲突，读-写冲突）。\n"),v("ul",[v("li",[_._v("触发方式："),v("code",[_._v("SELECT ... FOR SHARE")]),_._v("（MySQL 8.0+）或 "),v("code",[_._v("SELECT ... LOCK IN SHARE MODE")]),_._v("。")])])]),_._v(" "),v("li",[v("strong",[_._v("排他锁（X 锁，写锁）")]),_._v("：仅一个事务可持有，禁止其他事务加 S 锁或 X 锁（写-读、写-写都冲突）。\n"),v("ul",[v("li",[_._v("触发方式："),v("code",[_._v("INSERT")]),_._v("、"),v("code",[_._v("UPDATE")]),_._v("、"),v("code",[_._v("DELETE")]),_._v(" 操作自动加 X 锁，或 "),v("code",[_._v("SELECT ... FOR UPDATE")]),_._v("。")])])])]),_._v(" "),v("h4",{attrs:{id:"_5-1-3-行级锁的具体类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-3-行级锁的具体类型"}},[_._v("#")]),_._v(" 5.1.3 行级锁的具体类型")]),_._v(" "),v("p",[_._v("InnoDB 的行级锁基于索引实现，主要包括：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("记录锁（Record Lock）")]),_._v("：锁定单个数据记录（如 "),v("code",[_._v("WHERE id = 100")]),_._v("），仅锁定索引对应的记录。")]),_._v(" "),v("li",[v("strong",[_._v("间隙锁（Gap Lock）")]),_._v("：锁定索引之间的间隙（如 "),v("code",[_._v("WHERE id BETWEEN 100 AND 200")]),_._v("），防止其他事务插入数据（避免幻读）。")]),_._v(" "),v("li",[v("strong",[_._v("临键锁（Next-Key Lock）")]),_._v("：记录锁 + 间隙锁，锁定索引记录及其左侧间隙（如索引值为 100、200，Next-Key Lock 锁定 (∞,100]、(100,200]），是 InnoDB 默认的行级锁模式（可重复读隔离级别下）。")])]),_._v(" "),v("h3",{attrs:{id:"_5-2-锁的触发场景与示例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-锁的触发场景与示例"}},[_._v("#")]),_._v(" 5.2 锁的触发场景与示例")]),_._v(" "),v("h4",{attrs:{id:"_5-2-1-基于主键索引的锁定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-基于主键索引的锁定"}},[_._v("#")]),_._v(" 5.2.1 基于主键索引的锁定")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("-- 事务 A：加 X 锁（记录锁），锁定 id=100 的记录\nBEGIN;\nUPDATE user SET name = 'xxx' WHERE id = 100;\n\n-- 事务 B：修改 id=100 的记录会阻塞，直到事务 A 提交/回滚\nBEGIN;\nUPDATE user SET name = 'yyy' WHERE id = 100; -- 阻塞\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br"),v("span",{staticClass:"line-number"},[_._v("6")]),v("br"),v("span",{staticClass:"line-number"},[_._v("7")]),v("br")])]),v("h4",{attrs:{id:"_5-2-2-基于辅助索引的锁定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-2-基于辅助索引的锁定"}},[_._v("#")]),_._v(" 5.2.2 基于辅助索引的锁定")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("-- 表结构：id 为主键，name 为普通索引\nCREATE TABLE user (id INT PRIMARY KEY, name VARCHAR(20), INDEX idx_name(name));\n\n-- 事务 A：修改 name='zhangsan' 的记录，加 X 锁（临键锁）\nBEGIN;\nUPDATE user SET age = 20 WHERE name = 'zhangsan';\n\n-- 事务 B：插入 name='zhangsan' 附近的记录会阻塞（间隙锁生效）\nBEGIN;\nINSERT INTO user (id, name) VALUES (200, 'zhangsan1'); -- 阻塞\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br"),v("span",{staticClass:"line-number"},[_._v("6")]),v("br"),v("span",{staticClass:"line-number"},[_._v("7")]),v("br"),v("span",{staticClass:"line-number"},[_._v("8")]),v("br"),v("span",{staticClass:"line-number"},[_._v("9")]),v("br"),v("span",{staticClass:"line-number"},[_._v("10")]),v("br")])]),v("h4",{attrs:{id:"_5-2-3-无索引查询触发表锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-3-无索引查询触发表锁"}},[_._v("#")]),_._v(" 5.2.3 无索引查询触发表锁")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("-- 无索引查询，InnoDB 无法定位行，触发表锁\nBEGIN;\nUPDATE user SET name = 'xxx' WHERE age = 20; -- age 无索引，加表级 X 锁\n\n-- 事务 B：修改表中任何记录都会阻塞\nBEGIN;\nUPDATE user SET name = 'yyy' WHERE id = 100; -- 阻塞\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br"),v("span",{staticClass:"line-number"},[_._v("6")]),v("br"),v("span",{staticClass:"line-number"},[_._v("7")]),v("br")])]),v("h3",{attrs:{id:"_5-3-死锁-deadlock"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-死锁-deadlock"}},[_._v("#")]),_._v(" 5.3 死锁（Deadlock）")]),_._v(" "),v("h4",{attrs:{id:"_5-3-1-死锁的定义与产生条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-1-死锁的定义与产生条件"}},[_._v("#")]),_._v(" 5.3.1 死锁的定义与产生条件")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("定义")]),_._v("：两个或多个事务互相持有对方需要的锁，导致所有事务阻塞（如事务 A 持有锁 1，等待锁 2；事务 B 持有锁 2，等待锁 1）。")]),_._v(" "),v("li",[v("strong",[_._v("产生条件")]),_._v("：\n"),v("ol",[v("li",[_._v("互斥条件：锁同一时间只能被一个事务持有。")]),_._v(" "),v("li",[_._v("请求与保持条件：事务持有一个锁，同时请求另一个锁。")]),_._v(" "),v("li",[_._v("不可剥夺条件：锁不能被强制剥夺，只能由持有事务释放。")]),_._v(" "),v("li",[_._v("循环等待条件：事务之间形成锁的循环等待链。")])])])]),_._v(" "),v("h4",{attrs:{id:"_5-3-2-死锁示例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-2-死锁示例"}},[_._v("#")]),_._v(" 5.3.2 死锁示例")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("-- 表结构：id 为主键，name 为普通索引\nCREATE TABLE user (id INT PRIMARY KEY, name VARCHAR(20));\n\n-- 事务 A\nBEGIN;\nUPDATE user SET name = 'a' WHERE id = 100; -- 持有 id=100 的 X 锁\nUPDATE user SET name = 'a' WHERE id = 200; -- 等待 id=200 的 X 锁\n\n-- 事务 B\nBEGIN;\nUPDATE user SET name = 'b' WHERE id = 200; -- 持有 id=200 的 X 锁\nUPDATE user SET name = 'b' WHERE id = 100; -- 等待 id=100 的 X 锁\n\n-- 死锁产生：事务 A 等待事务 B 的锁，事务 B 等待事务 A 的锁\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br"),v("span",{staticClass:"line-number"},[_._v("6")]),v("br"),v("span",{staticClass:"line-number"},[_._v("7")]),v("br"),v("span",{staticClass:"line-number"},[_._v("8")]),v("br"),v("span",{staticClass:"line-number"},[_._v("9")]),v("br"),v("span",{staticClass:"line-number"},[_._v("10")]),v("br"),v("span",{staticClass:"line-number"},[_._v("11")]),v("br"),v("span",{staticClass:"line-number"},[_._v("12")]),v("br"),v("span",{staticClass:"line-number"},[_._v("13")]),v("br"),v("span",{staticClass:"line-number"},[_._v("14")]),v("br")])]),v("h4",{attrs:{id:"_5-3-3-死锁的解决与预防"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-3-死锁的解决与预防"}},[_._v("#")]),_._v(" 5.3.3 死锁的解决与预防")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("检测与处理")]),_._v("：InnoDB 自动检测死锁（通过超时机制或死锁检测算法），选择事务大小最小、修改行数最少的事务回滚，释放锁资源。")]),_._v(" "),v("li",[v("strong",[_._v("预防措施")]),_._v("：\n"),v("ol",[v("li",[_._v("统一事务的锁申请顺序（如都按 id 升序修改）。")]),_._v(" "),v("li",[_._v("避免长事务（减少锁持有时间）。")]),_._v(" "),v("li",[_._v("尽量使用主键或唯一索引查询（避免间隙锁和临键锁）。")]),_._v(" "),v("li",[_._v("合理设置隔离级别（如读已提交可减少间隙锁）。")]),_._v(" "),v("li",[_._v("监控死锁日志（"),v("code",[_._v("SHOW ENGINE INNODB STATUS")]),_._v("），分析死锁原因。")])])])]),_._v(" "),v("h2",{attrs:{id:"六、innodb-高可用方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六、innodb-高可用方案"}},[_._v("#")]),_._v(" 六、InnoDB 高可用方案")]),_._v(" "),v("p",[_._v("InnoDB 的高可用依赖 MySQL 的主从复制、集群方案等，核心目标是"),v("strong",[_._v("避免单点故障")]),_._v("、"),v("strong",[_._v("保证数据可用性")]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"_6-1-主从复制-master-slave-replication"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-主从复制-master-slave-replication"}},[_._v("#")]),_._v(" 6.1 主从复制（Master-Slave Replication）")]),_._v(" "),v("h4",{attrs:{id:"_6-1-1-复制原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-1-复制原理"}},[_._v("#")]),_._v(" 6.1.1 复制原理")]),_._v(" "),v("p",[_._v("主从复制基于二进制日志（Binary Log）实现，流程如下：")]),_._v(" "),v("ol",[v("li",[_._v("主库（Master）开启二进制日志，记录所有 DDL 和 DML 操作。")]),_._v(" "),v("li",[_._v("从库（Slave）开启 IO 线程，连接主库，读取主库的二进制日志，写入本地中继日志（Relay Log）。")]),_._v(" "),v("li",[_._v("从库开启 SQL 线程，解析中继日志，执行与主库相同的操作，保持数据同步。")])]),_._v(" "),v("h4",{attrs:{id:"_6-1-2-复制模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-2-复制模式"}},[_._v("#")]),_._v(" 6.1.2 复制模式")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("基于日志位置的复制（Position-Based Replication）")]),_._v("：从库记录主库的二进制日志文件名和位置，用于同步（MySQL 5.6 前默认）。")]),_._v(" "),v("li",[v("strong",[_._v("基于 GTID 的复制（GTID-Based Replication）")]),_._v("：GTID（Global Transaction Identifier）是事务的全局唯一标识，从库通过 GTID 定位同步位置，无需手动指定日志文件和位置（MySQL 5.6+ 支持，推荐生产环境使用）。")])]),_._v(" "),v("h4",{attrs:{id:"_6-1-3-innodb-与复制的配合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-3-innodb-与复制的配合"}},[_._v("#")]),_._v(" 6.1.3 InnoDB 与复制的配合")]),_._v(" "),v("ul",[v("li",[_._v("主库开启 "),v("code",[_._v("innodb_flush_log_at_trx_commit = 1")]),_._v(" 和 "),v("code",[_._v("sync_binlog = 1")]),_._v("，保证主库日志写入磁盘，避免主库崩溃导致日志丢失。")]),_._v(" "),v("li",[_._v("从库开启 "),v("code",[_._v("innodb_flush_log_at_trx_commit = 1")]),_._v("，保证从库事务持久性。")]),_._v(" "),v("li",[_._v("复制延迟优化：\n"),v("ul",[v("li",[_._v("主库增大 "),v("code",[_._v("innodb_log_file_size")]),_._v("，减少日志切换频率。")]),_._v(" "),v("li",[_._v("从库使用并行复制（MySQL 5.7+ 支持 "),v("code",[_._v("slave_parallel_workers")]),_._v("），提升同步效率。")]),_._v(" "),v("li",[_._v("避免从库执行复杂查询和写入操作。")])])])]),_._v(" "),v("h3",{attrs:{id:"_6-2-innodb-cluster"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-innodb-cluster"}},[_._v("#")]),_._v(" 6.2 InnoDB Cluster")]),_._v(" "),v("p",[_._v("MySQL 8.0 推出的官方集群方案，基于「主从复制 + 组复制（Group Replication）」实现，特性如下：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("高可用")]),_._v("：支持自动故障转移，主库故障后，集群自动选举新主库。")]),_._v(" "),v("li",[v("strong",[_._v("一致性")]),_._v("：基于 Paxos 协议实现数据一致性，保证集群中多数节点数据一致。")]),_._v(" "),v("li",[v("strong",[_._v("扩展性")]),_._v("：支持动态添加/移除节点，最多支持 9 个节点。")]),_._v(" "),v("li",[v("strong",[_._v("使用场景")]),_._v("：中小型应用的高可用部署，无需依赖第三方工具（如 MGR）。")])]),_._v(" "),v("h3",{attrs:{id:"_6-3-故障转移机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-故障转移机制"}},[_._v("#")]),_._v(" 6.3 故障转移机制")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("手动故障转移")]),_._v("：主库故障后，手动将从库提升为主库，修改应用连接地址。")]),_._v(" "),v("li",[v("strong",[_._v("自动故障转移")]),_._v("：通过工具（如 MHA、Keepalived、InnoDB Cluster）实现自动检测主库故障、选举新主库、切换应用连接，无需人工干预。")])]),_._v(" "),v("h2",{attrs:{id:"七、innodb-性能优化实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七、innodb-性能优化实践"}},[_._v("#")]),_._v(" 七、InnoDB 性能优化实践")]),_._v(" "),v("p",[_._v("InnoDB 的性能优化围绕「减少磁盘 I/O」、「优化锁竞争」、「提升并发吞吐量」展开，以下是核心优化技巧：")]),_._v(" "),v("h3",{attrs:{id:"_7-1-缓冲池优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-缓冲池优化"}},[_._v("#")]),_._v(" 7.1 缓冲池优化")]),_._v(" "),v("ul",[v("li",[_._v("配置 "),v("code",[_._v("innodb_buffer_pool_size")]),_._v("：设为物理内存的 70%-80%（如 16GB 内存设为 12GB）。")]),_._v(" "),v("li",[_._v("配置 "),v("code",[_._v("innodb_buffer_pool_instances")]),_._v("：将缓冲池分为多个实例（如 12GB 缓冲池设为 4 个实例，每个 3GB），减少锁竞争。")]),_._v(" "),v("li",[_._v("开启 "),v("code",[_._v("innodb_buffer_pool_dump_at_shutdown")]),_._v(" 和 "),v("code",[_._v("innodb_buffer_pool_load_at_startup")]),_._v("，数据库重启时快速加载热点数据到缓冲池。")])]),_._v(" "),v("h3",{attrs:{id:"_7-2-索引优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-索引优化"}},[_._v("#")]),_._v(" 7.2 索引优化")]),_._v(" "),v("ul",[v("li",[_._v("主键使用自增 INT/BIGINT 类型，避免 UUID 或无序字符串。")]),_._v(" "),v("li",[_._v("为查询频繁的列创建索引，避免过度索引（索引会增加写入开销）。")]),_._v(" "),v("li",[_._v("合理设计联合索引，遵循最左前缀原则，实现覆盖索引。")]),_._v(" "),v("li",[_._v("定期优化索引（"),v("code",[_._v("OPTIMIZE TABLE")]),_._v("），清理索引碎片（适用于频繁删除/更新的表）。")])]),_._v(" "),v("h3",{attrs:{id:"_7-3-事务优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-事务优化"}},[_._v("#")]),_._v(" 7.3 事务优化")]),_._v(" "),v("ul",[v("li",[_._v("避免长事务（如大事务拆分、减少事务中的查询操作）。")]),_._v(" "),v("li",[_._v("合理选择隔离级别（读已提交隔离级别并发性能更高，可满足大部分业务场景）。")]),_._v(" "),v("li",[_._v("开启 "),v("code",[_._v("innodb_support_xa = 1")]),_._v("（默认开启），支持分布式事务（XA 事务）。")])]),_._v(" "),v("h3",{attrs:{id:"_7-4-锁优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-锁优化"}},[_._v("#")]),_._v(" 7.4 锁优化")]),_._v(" "),v("ul",[v("li",[_._v("尽量使用主键或唯一索引查询（避免间隙锁和临键锁）。")]),_._v(" "),v("li",[_._v("减少锁持有时间（如事务中先查询后修改，避免长时间占用锁）。")]),_._v(" "),v("li",[_._v("读已提交隔离级别下，InnoDB 会禁用间隙锁（仅保留记录锁），减少锁冲突。")]),_._v(" "),v("li",[_._v("避免使用 "),v("code",[_._v("SELECT ... FOR UPDATE")]),_._v(" 除非必要，改用 "),v("code",[_._v("SELECT ... FOR SHARE")]),_._v(" 或 MVCC 读取。")])]),_._v(" "),v("h3",{attrs:{id:"_7-5-日志优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-日志优化"}},[_._v("#")]),_._v(" 7.5 日志优化")]),_._v(" "),v("ul",[v("li",[_._v("配置 "),v("code",[_._v("innodb_log_file_size")]),_._v("：设为 2G-4G（太大导致恢复时间长，太小导致频繁切换日志）。")]),_._v(" "),v("li",[_._v("配置 "),v("code",[_._v("innodb_log_files_in_group")]),_._v("：设为 2-4 个（默认 2 个），避免单个日志文件损坏。")]),_._v(" "),v("li",[_._v("配置 "),v("code",[_._v("innodb_log_buffer_size")]),_._v("：设为 64MB-128MB（减少日志写入磁盘的次数）。")])]),_._v(" "),v("h3",{attrs:{id:"_7-6-配置参数调优-生产环境推荐"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-配置参数调优-生产环境推荐"}},[_._v("#")]),_._v(" 7.6 配置参数调优（生产环境推荐）")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("[mysqld]\n# 缓冲池配置\ninnodb_buffer_pool_size = 12G\ninnodb_buffer_pool_instances = 4\ninnodb_buffer_pool_dump_at_shutdown = 1\ninnodb_buffer_pool_load_at_startup = 1\n\n# 日志配置\ninnodb_log_file_size = 4G\ninnodb_log_files_in_group = 2\ninnodb_log_buffer_size = 64M\ninnodb_flush_log_at_trx_commit = 1\nsync_binlog = 1\n\n# 事务与锁配置\ntransaction_isolation = READ-COMMITTED\ninnodb_lock_wait_timeout = 50\ninnodb_deadlock_detect = 1\n\n# 其他优化\ninnodb_file_per_table = 1\ninnodb_flush_method = O_DIRECT\ninnodb_read_io_threads = 8\ninnodb_write_io_threads = 8\ninnodb_buffer_pool_dump_pct = 75\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br"),v("span",{staticClass:"line-number"},[_._v("6")]),v("br"),v("span",{staticClass:"line-number"},[_._v("7")]),v("br"),v("span",{staticClass:"line-number"},[_._v("8")]),v("br"),v("span",{staticClass:"line-number"},[_._v("9")]),v("br"),v("span",{staticClass:"line-number"},[_._v("10")]),v("br"),v("span",{staticClass:"line-number"},[_._v("11")]),v("br"),v("span",{staticClass:"line-number"},[_._v("12")]),v("br"),v("span",{staticClass:"line-number"},[_._v("13")]),v("br"),v("span",{staticClass:"line-number"},[_._v("14")]),v("br"),v("span",{staticClass:"line-number"},[_._v("15")]),v("br"),v("span",{staticClass:"line-number"},[_._v("16")]),v("br"),v("span",{staticClass:"line-number"},[_._v("17")]),v("br"),v("span",{staticClass:"line-number"},[_._v("18")]),v("br"),v("span",{staticClass:"line-number"},[_._v("19")]),v("br"),v("span",{staticClass:"line-number"},[_._v("20")]),v("br"),v("span",{staticClass:"line-number"},[_._v("21")]),v("br"),v("span",{staticClass:"line-number"},[_._v("22")]),v("br"),v("span",{staticClass:"line-number"},[_._v("23")]),v("br"),v("span",{staticClass:"line-number"},[_._v("24")]),v("br"),v("span",{staticClass:"line-number"},[_._v("25")]),v("br")])]),v("h2",{attrs:{id:"八、常见问题排查与解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#八、常见问题排查与解决"}},[_._v("#")]),_._v(" 八、常见问题排查与解决")]),_._v(" "),v("h3",{attrs:{id:"_8-1-死锁问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-死锁问题"}},[_._v("#")]),_._v(" 8.1 死锁问题")]),_._v(" "),v("ul",[v("li",[_._v("查看死锁日志："),v("code",[_._v("SHOW ENGINE INNODB STATUS")]),_._v("，分析死锁的事务和 SQL。")]),_._v(" "),v("li",[_._v("解决：优化事务锁申请顺序、减少长事务、使用读已提交隔离级别。")])]),_._v(" "),v("h3",{attrs:{id:"_8-2-慢查询问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-慢查询问题"}},[_._v("#")]),_._v(" 8.2 慢查询问题")]),_._v(" "),v("ul",[v("li",[_._v("开启慢查询日志："),v("code",[_._v("slow_query_log = 1")]),_._v("，"),v("code",[_._v("long_query_time = 1")]),_._v("（记录执行时间超过 1 秒的查询）。")]),_._v(" "),v("li",[_._v("分析慢查询：使用 "),v("code",[_._v("EXPLAIN")]),_._v(" 查看 SQL 执行计划，检查是否使用索引、是否回表、是否全表扫描。")]),_._v(" "),v("li",[_._v("解决：优化索引、重写 SQL、避免大表全表扫描。")])]),_._v(" "),v("h3",{attrs:{id:"_8-3-复制延迟问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-复制延迟问题"}},[_._v("#")]),_._v(" 8.3 复制延迟问题")]),_._v(" "),v("ul",[v("li",[_._v("查看复制延迟："),v("code",[_._v("SHOW SLAVE STATUS")]),_._v(" 中的 "),v("code",[_._v("Seconds_Behind_Master")]),_._v("。")]),_._v(" "),v("li",[_._v("解决：主库优化（增大日志文件、减少慢查询）、从库并行复制、避免从库写入操作。")])]),_._v(" "),v("h3",{attrs:{id:"_8-4-缓冲池命中率低"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-缓冲池命中率低"}},[_._v("#")]),_._v(" 8.4 缓冲池命中率低")]),_._v(" "),v("ul",[v("li",[_._v("查看缓冲池命中率："),v("code",[_._v("SHOW ENGINE INNODB STATUS")]),_._v(" 中的 "),v("code",[_._v("Buffer Pool Hit Rate")]),_._v("（目标 > 99%）。")]),_._v(" "),v("li",[_._v("解决：增大 "),v("code",[_._v("innodb_buffer_pool_size")]),_._v("、优化索引（减少全表扫描）、清理无用数据。")])]),_._v(" "),v("h2",{attrs:{id:"九、总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#九、总结"}},[_._v("#")]),_._v(" 九、总结")]),_._v(" "),v("p",[_._v("InnoDB 作为 MySQL 最强大的存储引擎，其设计思想涵盖了"),v("strong",[_._v("内存缓存、磁盘存储、事务机制、锁机制、高可用")]),_._v("等多个核心领域。")])])}),[],!1,null,null,null);v.default=s.exports}}]);