(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{443:function(t,_,v){"use strict";v.r(_);var s=v(8),a=Object(s.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v('在多线程编程中，当多个线程共享资源时，"并发操作导致数据不一致"是最常见的问题。例如两个线程同时执行'),_("code",[t._v("count++")]),t._v("，最终结果可能比预期少1——这就是"),_("strong",[t._v("竞态条件（Race Condition）")]),t._v("。线程锁作为解决该问题的核心机制，通过控制共享资源的访问权限，保证多线程操作的安全性。")]),t._v(" "),_("h2",{attrs:{id:"一、线程锁的核心概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、线程锁的核心概念"}},[t._v("#")]),t._v(" 一、线程锁的核心概念")]),t._v(" "),_("h3",{attrs:{id:"_1-1-什么是线程锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-什么是线程锁"}},[t._v("#")]),t._v(" 1.1 什么是线程锁？")]),t._v(" "),_("p",[t._v("线程锁是一种同步机制，用于"),_("strong",[t._v("保证多个线程对共享资源的互斥访问")]),t._v('。它通过限制"同一时间只有一个线程能操作共享资源"，避免并发操作导致的数据错乱。')]),t._v(" "),_("h3",{attrs:{id:"_1-2-为什么需要线程锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-为什么需要线程锁"}},[t._v("#")]),t._v(" 1.2 为什么需要线程锁？")]),t._v(" "),_("p",[t._v("线程共享进程的内存空间，当多个线程同时操作共享变量、对象等资源时，单条指令（如"),_("code",[t._v("count++")]),t._v("）可能被拆分为多个步骤（读取→修改→写入）。若步骤被其他线程打断，会导致结果异常。")]),t._v(" "),_("p",[_("strong",[t._v("示例：竞态条件导致的错误")])]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('public class RaceConditionDemo {\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        // 两个线程同时执行1000次count++\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) count++;\n        });\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) count++;\n        });\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println("最终结果：" + count); // 预期2000，实际可能小于2000\n    }\n}\n')])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br"),_("span",{staticClass:"line-number"},[t._v("8")]),_("br"),_("span",{staticClass:"line-number"},[t._v("9")]),_("br"),_("span",{staticClass:"line-number"},[t._v("10")]),_("br"),_("span",{staticClass:"line-number"},[t._v("11")]),_("br"),_("span",{staticClass:"line-number"},[t._v("12")]),_("br"),_("span",{staticClass:"line-number"},[t._v("13")]),_("br"),_("span",{staticClass:"line-number"},[t._v("14")]),_("br"),_("span",{staticClass:"line-number"},[t._v("15")]),_("br"),_("span",{staticClass:"line-number"},[t._v("16")]),_("br"),_("span",{staticClass:"line-number"},[t._v("17")]),_("br"),_("span",{staticClass:"line-number"},[t._v("18")]),_("br")])]),_("p",[t._v("原因：线程1读取"),_("code",[t._v("count=500")]),t._v("后，线程2也读取"),_("code",[t._v("count=500")]),t._v("，两者分别加1后写入，最终"),_("code",[t._v("count=501")]),t._v("（而非502）。")]),t._v(" "),_("h2",{attrs:{id:"二、线程锁的分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、线程锁的分类"}},[t._v("#")]),t._v(" 二、线程锁的分类")]),t._v(" "),_("p",[t._v("根据设计思想、粒度和特性，线程锁可分为以下类型：")]),t._v(" "),_("h3",{attrs:{id:"_2-1-按核心策略-悲观锁-vs-乐观锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-按核心策略-悲观锁-vs-乐观锁"}},[t._v("#")]),t._v(" 2.1 按核心策略：悲观锁 vs 乐观锁")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("悲观锁")]),_("br"),t._v("\n假设线程一定会发生并发冲突，因此在访问资源前"),_("strong",[t._v("必须先获取锁")]),t._v("，全程独占资源。")]),t._v(" "),_("ul",[_("li",[t._v("典型例子：Java的"),_("code",[t._v("Synchronized")]),t._v("、"),_("code",[t._v("ReentrantLock")]),t._v("，数据库的行锁/表锁。")]),t._v(" "),_("li",[t._v("优点：安全性高；缺点：频繁加锁释放锁会增加性能开销。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("乐观锁")]),_("br"),t._v("\n假设线程不会发生冲突，因此"),_("strong",[t._v("不主动加锁")]),t._v("，仅在更新资源时检查是否被其他线程修改。")]),t._v(" "),_("ul",[_("li",[t._v("实现方式：版本号机制（如数据库乐观锁）、CAS（Compare-And-Swap，比较并交换）。")]),t._v(" "),_("li",[t._v("优点：无锁竞争，性能高；缺点：冲突频繁时会不断重试，反而降低效率。")])])])]),t._v(" "),_("h3",{attrs:{id:"_2-2-按互斥粒度-独占锁-vs-共享锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-按互斥粒度-独占锁-vs-共享锁"}},[t._v("#")]),t._v(" 2.2 按互斥粒度：独占锁 vs 共享锁")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("独占锁（排他锁）")]),_("br"),t._v("\n同一时间只允许一个线程获取锁，其他线程必须等待。")]),t._v(" "),_("ul",[_("li",[t._v("典型例子："),_("code",[t._v("Synchronized")]),t._v("、"),_("code",[t._v("ReentrantLock")]),t._v("（默认模式）。")]),t._v(" "),_("li",[t._v("适用场景：写操作（修改共享资源）。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("共享锁")]),_("br"),t._v("\n允许多个线程同时获取锁，但仅支持读操作；写操作仍需独占锁。")]),t._v(" "),_("ul",[_("li",[t._v("典型例子："),_("code",[t._v("ReentrantReadWriteLock.ReadLock")]),t._v("（读锁共享，写锁独占）。")]),t._v(" "),_("li",[t._v("优点：提高读操作的并发效率（多线程可同时读）。")])])])]),t._v(" "),_("h3",{attrs:{id:"_2-3-按可重入性-可重入锁-vs-不可重入锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-按可重入性-可重入锁-vs-不可重入锁"}},[t._v("#")]),t._v(" 2.3 按可重入性：可重入锁 vs 不可重入锁")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("可重入锁")]),_("br"),t._v('\n同一线程可多次获取同一把锁，锁会记录"持有次数"，释放次数需与获取次数一致（避免自己锁死自己）。')]),t._v(" "),_("ul",[_("li",[t._v("典型例子："),_("code",[t._v("Synchronized")]),t._v("、"),_("code",[t._v("ReentrantLock")]),t._v('（名称中"Reentrant"即表示可重入）。')]),t._v(" "),_("li",[t._v("示例：递归调用同步方法时，不会因重复获取锁而死锁。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("不可重入锁")]),_("br"),t._v("\n同一线程多次获取同一把锁会导致死锁（线程已持有锁，再次获取时会阻塞自己）。")]),t._v(" "),_("ul",[_("li",[t._v("典型例子：早期的"),_("code",[t._v("SimpleLock")]),t._v("（自定义简易锁，未实现重入逻辑）。")])])])]),t._v(" "),_("h3",{attrs:{id:"_2-4-按公平性-公平锁-vs-非公平锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-按公平性-公平锁-vs-非公平锁"}},[t._v("#")]),t._v(" 2.4 按公平性：公平锁 vs 非公平锁")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("公平锁")]),_("br"),t._v("\n按线程请求锁的"),_("strong",[t._v("先后顺序分配锁")]),t._v("（先到先得），避免线程饥饿（长期得不到锁）。")]),t._v(" "),_("ul",[_("li",[t._v("典型例子："),_("code",[t._v("ReentrantLock(true)")]),t._v("（构造参数传"),_("code",[t._v("true")]),t._v("）。")]),t._v(" "),_("li",[t._v("优点：公平性高；缺点：需维护等待队列，性能较低。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("非公平锁")]),_("br"),t._v('\n线程获取锁时不按顺序，允许"插队"（刚释放锁的线程可能立即再次获取锁）。')]),t._v(" "),_("ul",[_("li",[t._v("典型例子："),_("code",[t._v("Synchronized")]),t._v("（默认非公平）、"),_("code",[t._v("ReentrantLock(false)")]),t._v("（默认）。")]),t._v(" "),_("li",[t._v("优点：性能高（减少线程切换开销）；缺点：可能导致部分线程长期等待。")])])])]),t._v(" "),_("h2",{attrs:{id:"三、java-内置锁-synchronized"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、java-内置锁-synchronized"}},[t._v("#")]),t._v(" 三、Java 内置锁：Synchronized")]),t._v(" "),_("p",[_("code",[t._v("synchronized")]),t._v("是Java最常用的内置锁机制，可保证代码块/方法的"),_("strong",[t._v("原子性、可见性和有序性")]),t._v("，无需手动释放锁（JVM自动管理）。")]),t._v(" "),_("h3",{attrs:{id:"_3-1-用法-三种同步场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-用法-三种同步场景"}},[t._v("#")]),t._v(" 3.1 用法：三种同步场景")]),t._v(" "),_("p",[_("code",[t._v("synchronized")]),t._v("的锁对象由修饰范围决定，具体用法如下：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("用法")]),t._v(" "),_("th",[t._v("锁对象")]),t._v(" "),_("th",[t._v("作用范围")]),t._v(" "),_("th",[t._v("示例代码")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("修饰静态方法")]),t._v(" "),_("td",[t._v("当前类的"),_("code",[t._v("Class")]),t._v("对象")]),t._v(" "),_("td",[t._v("整个静态方法")]),t._v(" "),_("td",[_("code",[t._v("public static synchronized void staticMethod() { ... }")])])]),t._v(" "),_("tr",[_("td",[t._v("修饰实例方法")]),t._v(" "),_("td",[t._v("当前实例对象（"),_("code",[t._v("this")]),t._v("）")]),t._v(" "),_("td",[t._v("整个实例方法")]),t._v(" "),_("td",[_("code",[t._v("public synchronized void instanceMethod() { ... }")])])]),t._v(" "),_("tr",[_("td",[t._v("修饰代码块")]),t._v(" "),_("td",[t._v("自定义对象（如"),_("code",[t._v("lock")]),t._v("）")]),t._v(" "),_("td",[t._v("代码块内部")]),t._v(" "),_("td",[_("code",[t._v("synchronized (lock) { ... }")]),t._v(" （"),_("code",[t._v("lock")]),t._v("可为任意Object对象）")])])])]),t._v(" "),_("p",[_("strong",[t._v("注意")]),t._v("：")]),t._v(" "),_("ul",[_("li",[t._v("静态方法锁是类级别的，所有实例共享同一把锁；")]),t._v(" "),_("li",[t._v("实例方法锁是对象级别的，不同实例的锁相互独立（不会互斥）。")])]),t._v(" "),_("h3",{attrs:{id:"_3-2-底层实现-字节码视角"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-底层实现-字节码视角"}},[t._v("#")]),t._v(" 3.2 底层实现：字节码视角")]),t._v(" "),_("p",[_("code",[t._v("synchronized")]),t._v("的底层依赖JVM的"),_("strong",[t._v("监视器（Monitor）")]),t._v(" 机制，通过字节码指令或标志位实现锁的获取与释放。")]),t._v(" "),_("h4",{attrs:{id:"_3-2-1-同步代码块-monitorenter与monitorexit"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-同步代码块-monitorenter与monitorexit"}},[t._v("#")]),t._v(" 3.2.1 同步代码块："),_("code",[t._v("monitorenter")]),t._v("与"),_("code",[t._v("monitorexit")])]),t._v(" "),_("p",[t._v("编译后，同步代码块会生成"),_("code",[t._v("monitorenter")]),t._v("（获取锁）和"),_("code",[t._v("monitorexit")]),t._v("（释放锁）指令：")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('public class SyncBlockDemo {\n    private final Object lock = new Object();\n    public void test() {\n        synchronized (lock) { // 同步代码块\n            System.out.println("临界区代码");\n        }\n    }\n}\n')])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br"),_("span",{staticClass:"line-number"},[t._v("8")]),_("br")])]),_("p",[t._v("反编译字节码（"),_("code",[t._v("javap -v SyncBlockDemo.class")]),t._v("）核心片段：")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("Code:\n     0: aload_0         // 加载锁对象lock\n     1: getfield      #2 // Field lock:Ljava/lang/Object;\n     4: dup\n     5: astore_1\n     6: monitorenter   // 尝试获取锁（进入Monitor）\n     7: getstatic     #3 // 执行临界区代码（打印逻辑）\n    37: aload_1\n    38: monitorexit    // 正常释放锁（退出Monitor）\n    39: goto          47\n    43: astore_2\n    44: aload_1\n    45: monitorexit    // 异常时也释放锁（避免锁泄露）\n    46: aload_2\n    47: return\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br"),_("span",{staticClass:"line-number"},[t._v("8")]),_("br"),_("span",{staticClass:"line-number"},[t._v("9")]),_("br"),_("span",{staticClass:"line-number"},[t._v("10")]),_("br"),_("span",{staticClass:"line-number"},[t._v("11")]),_("br"),_("span",{staticClass:"line-number"},[t._v("12")]),_("br"),_("span",{staticClass:"line-number"},[t._v("13")]),_("br"),_("span",{staticClass:"line-number"},[t._v("14")]),_("br"),_("span",{staticClass:"line-number"},[t._v("15")]),_("br")])]),_("ul",[_("li",[_("code",[t._v("monitorenter")]),t._v("：线程尝试获取锁，成功则进入临界区，失败则阻塞（进入Monitor的等待队列）。")]),t._v(" "),_("li",[_("code",[t._v("monitorexit")]),t._v("：无论代码正常执行还是抛出异常，都会释放锁（保证锁一定会被释放）。")])]),t._v(" "),_("h4",{attrs:{id:"_3-2-2-同步方法-acc-synchronized标志"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-同步方法-acc-synchronized标志"}},[t._v("#")]),t._v(" 3.2.2 同步方法："),_("code",[t._v("ACC_SYNCHRONIZED")]),t._v("标志")]),t._v(" "),_("p",[t._v("同步方法通过方法表中的"),_("code",[t._v("ACC_SYNCHRONIZED")]),t._v("标志实现，无需显式指令：")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('public class SyncMethodDemo {\n    public synchronized void test() { // 同步实例方法\n        System.out.println("同步方法代码");\n    }\n}\n')])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br")])]),_("p",[t._v("反编译字节码核心片段：")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("public synchronized void test();\ndescriptor: ()V\nflags: ACC_PUBLIC, ACC_SYNCHRONIZED  // 同步方法标志\nCode:\n    0: getstatic     #2 // 执行方法逻辑\n   30: return\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br")])]),_("p",[t._v("JVM执行时会检查"),_("code",[t._v("ACC_SYNCHRONIZED")]),t._v("标志：若存在，先获取锁（锁对象为"),_("code",[t._v("this")]),t._v("或"),_("code",[t._v("Class")]),t._v("），执行完方法后自动释放锁。")]),t._v(" "),_("h3",{attrs:{id:"_3-3-锁的底层结构-对象头与monitor"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-锁的底层结构-对象头与monitor"}},[t._v("#")]),t._v(" 3.3 锁的底层结构：对象头与Monitor")]),t._v(" "),_("p",[_("code",[t._v("synchronized")]),t._v("的本质是"),_("strong",[t._v("对象锁")]),t._v("——所有Java对象都可作为锁，因为每个对象内置了一个"),_("code",[t._v("Monitor")]),t._v("（监视器），且对象头存储了锁的状态信息。")]),t._v(" "),_("h4",{attrs:{id:"_3-3-1-对象的内存结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-对象的内存结构"}},[t._v("#")]),t._v(" 3.3.1 对象的内存结构")]),t._v(" "),_("p",[t._v("Java对象在堆内存中分为三部分：")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("对象头（Header） | 实例数据（Instance Data） | 对齐填充（Padding）\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("其中"),_("strong",[t._v("对象头")]),t._v("是实现锁的核心，包含：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("Mark Word")]),t._v("：存储对象的锁状态、哈希码（HashCode）、GC年龄、线程ID等（动态变化）。")]),t._v(" "),_("li",[_("strong",[t._v("Klass Pointer")]),t._v("：指向对象所属类的元数据（如类的方法、字段信息）。")])]),t._v(" "),_("h4",{attrs:{id:"_3-3-2-mark-word的动态变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-mark-word的动态变化"}},[t._v("#")]),t._v(" 3.3.2 Mark Word的动态变化")]),t._v(" "),_("p",[t._v("Mark Word的内容会随锁状态改变，以32位JVM为例：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("锁状态")]),t._v(" "),_("th",[t._v("Mark Word存储内容（32位）")]),t._v(" "),_("th",[t._v("锁标志位")]),t._v(" "),_("th",[t._v("偏向锁标志")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("无锁")]),t._v(" "),_("td",[t._v("哈希码（25位） + GC年龄（4位） + 0 + 01（未使用）")]),t._v(" "),_("td",[t._v("01")]),t._v(" "),_("td",[t._v("0")])]),t._v(" "),_("tr",[_("td",[t._v("偏向锁")]),t._v(" "),_("td",[t._v("线程ID（23位） + 偏向时间戳（2位） + GC年龄（4位） + 1 + 01")]),t._v(" "),_("td",[t._v("01")]),t._v(" "),_("td",[t._v("1")])]),t._v(" "),_("tr",[_("td",[t._v("轻量级锁")]),t._v(" "),_("td",[t._v("指向栈中锁记录（Lock Record）的指针（30位） + 00")]),t._v(" "),_("td",[t._v("00")]),t._v(" "),_("td",[t._v("-")])]),t._v(" "),_("tr",[_("td",[t._v("重量级锁")]),t._v(" "),_("td",[t._v("指向Monitor对象的指针（30位） + 10")]),t._v(" "),_("td",[t._v("10")]),t._v(" "),_("td",[t._v("-")])]),t._v(" "),_("tr",[_("td",[t._v("GC标记")]),t._v(" "),_("td",[t._v("空 + 11")]),t._v(" "),_("td",[t._v("11")]),t._v(" "),_("td",[t._v("-")])])])]),t._v(" "),_("h4",{attrs:{id:"_3-3-3-monitor的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-3-monitor的作用"}},[t._v("#")]),t._v(" 3.3.3 Monitor的作用")]),t._v(" "),_("p",[t._v("当锁升级为"),_("strong",[t._v("重量级锁")]),t._v("时，Mark Word会指向一个"),_("code",[t._v("Monitor")]),t._v("对象（C++结构体），其核心结构包括：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("_owner")]),t._v("：持有锁的线程（初始为null）。")]),t._v(" "),_("li",[_("code",[t._v("_WaitSet")]),t._v("：等待锁的线程队列（调用"),_("code",[t._v("wait()")]),t._v("后进入）。")]),t._v(" "),_("li",[_("code",[t._v("_EntryList")]),t._v("：竞争锁失败的线程队列（阻塞状态）。")])]),t._v(" "),_("p",[t._v("线程获取锁时，"),_("code",[t._v("_owner")]),t._v("设为当前线程；释放锁时，"),_("code",[t._v("_owner")]),t._v("设为null，并唤醒"),_("code",[t._v("_EntryList")]),t._v("中的线程竞争锁。")]),t._v(" "),_("h3",{attrs:{id:"_3-4-锁的升级机制-jdk-1-6"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-锁的升级机制-jdk-1-6"}},[t._v("#")]),t._v(" 3.4 锁的升级机制（JDK 1.6+）")]),t._v(" "),_("p",[t._v("为减少锁的性能开销，JDK 1.6引入"),_("strong",[t._v("锁升级机制")]),t._v('：锁状态从"无锁"逐步升级为"偏向锁"→"轻量级锁"→"重量级锁"，避免直接使用重量级锁（性能低）。')]),t._v(" "),_("h4",{attrs:{id:"升级流程详解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#升级流程详解"}},[t._v("#")]),t._v(" 升级流程详解：")]),t._v(" "),_("ol",[_("li",[_("p",[_("strong",[t._v("无锁状态")]),_("br"),t._v("\n对象刚创建时，Mark Word存储哈希码和GC年龄，无锁标志（01），偏向锁标志（0）。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("偏向锁（单线程优化）")])]),t._v(" "),_("ul",[_("li",[t._v("触发条件：只有一个线程竞争锁。")]),t._v(" "),_("li",[t._v('原理：线程第一次获取锁时，通过CAS将Mark Word的"线程ID"设为自己的ID。后续该线程进入/退出锁时，只需检查线程ID是否为自己，无需CAS操作（几乎无开销）。')]),t._v(" "),_("li",[t._v("撤销：若其他线程尝试获取锁，偏向锁会撤销为无锁或轻量级锁（有额外开销，因此适合单线程长期持有锁的场景）。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("轻量级锁（多线程交替执行）")])]),t._v(" "),_("ul",[_("li",[t._v("触发条件：多个线程交替竞争锁（非同时竞争）。")]),t._v(" "),_("li",[t._v("原理：线程获取锁时，在栈中创建"),_("strong",[t._v("Lock Record")]),t._v("（存储Mark Word副本），通过CAS将Mark Word改为指向Lock Record的指针。成功则获取锁；失败则通过"),_("strong",[t._v("自旋")]),t._v("（循环重试）获取锁（避免线程阻塞，适合短任务）。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("重量级锁（多线程同时竞争）")])]),t._v(" "),_("ul",[_("li",[t._v("触发条件：自旋次数超过阈值（默认10次），或有线程阻塞。")]),t._v(" "),_("li",[t._v("原理：锁膨胀为重量级锁，Mark Word指向Monitor对象。竞争失败的线程进入Monitor的"),_("code",[t._v("_EntryList")]),t._v("阻塞（不消耗CPU，但线程切换开销大）。")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-5-核心特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-核心特性"}},[t._v("#")]),t._v(" 3.5 核心特性")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("原子性")]),t._v("：通过Monitor保证同一时间只有一个线程进入临界区，确保代码块/方法的操作不可分割。")]),t._v(" "),_("li",[_("strong",[t._v("可见性")]),t._v("：依赖内存屏障（Memory Barrier）：\n"),_("ul",[_("li",[t._v("释放锁时，线程工作内存的变量会刷新到主内存；")]),t._v(" "),_("li",[t._v("获取锁时，线程工作内存会清空，从主内存重新读取变量。")])])]),t._v(" "),_("li",[_("strong",[t._v("有序性")]),t._v("：禁止指令重排序（临界区内代码执行顺序稳定）。")]),t._v(" "),_("li",[_("strong",[t._v("可重入性")]),t._v("：同一线程多次获取同一锁时，Mark Word记录线程ID，无需重新竞争（避免死锁）。")])]),t._v(" "),_("h2",{attrs:{id:"四、轻量级同步-volatile"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、轻量级同步-volatile"}},[t._v("#")]),t._v(" 四、轻量级同步：Volatile")]),t._v(" "),_("p",[_("code",[t._v("volatile")]),t._v("是Java的轻量级同步关键字，用于修饰共享变量，解决"),_("strong",[t._v("可见性和有序性")]),t._v("问题，但"),_("strong",[t._v("不保证原子性")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"_4-1-核心作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-核心作用"}},[t._v("#")]),t._v(" 4.1 核心作用")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("可见性")]),t._v("：一个线程修改"),_("code",[t._v("volatile")]),t._v("变量后，其他线程能立即看到最新值（通过内存屏障强制刷新主内存）。")]),t._v(" "),_("li",[_("strong",[t._v("有序性")]),t._v("：禁止指令重排序（通过内存屏障限制编译器和CPU的优化）。")])]),t._v(" "),_("h3",{attrs:{id:"_4-2-为什么不保证原子性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-为什么不保证原子性"}},[t._v("#")]),t._v(" 4.2 为什么不保证原子性？")]),t._v(" "),_("p",[_("code",[t._v("volatile")]),t._v("仅能保证单个变量的读写可见，但无法保证复合操作（如"),_("code",[t._v("i++")]),t._v("）的原子性。例如：")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("public class VolatileAtomicDemo {\n    private static volatile int i = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> { for (int j = 0; j < 1000; j++) i++; });\n        Thread t2 = new Thread(() -> { for (int j = 0; j < 1000; j++) i++; });\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(i); // 结果可能小于2000（原子性不保证）\n    }\n}\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br"),_("span",{staticClass:"line-number"},[t._v("8")]),_("br"),_("span",{staticClass:"line-number"},[t._v("9")]),_("br"),_("span",{staticClass:"line-number"},[t._v("10")]),_("br"),_("span",{staticClass:"line-number"},[t._v("11")]),_("br"),_("span",{staticClass:"line-number"},[t._v("12")]),_("br"),_("span",{staticClass:"line-number"},[t._v("13")]),_("br")])]),_("h3",{attrs:{id:"_4-3-适用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-适用场景"}},[t._v("#")]),t._v(" 4.3 适用场景")]),t._v(" "),_("ul",[_("li",[t._v("状态标记位（如"),_("code",[t._v("boolean isRunning")]),t._v("，控制线程启动/停止）；")]),t._v(" "),_("li",[t._v("单线程写、多线程读的变量（无需原子性）。")])]),t._v(" "),_("h2",{attrs:{id:"五、总结-线程锁的选择与实践"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、总结-线程锁的选择与实践"}},[t._v("#")]),t._v(" 五、总结：线程锁的选择与实践")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("synchronized")]),t._v("：适合大多数场景，无需手动释放锁，JDK优化后性能接近"),_("code",[t._v("ReentrantLock")]),t._v("。")]),t._v(" "),_("li",[_("strong",[t._v("ReentrantLock")]),t._v("：适合需要灵活控制（如公平锁、尝试获取锁、中断等待）的场景。")]),t._v(" "),_("li",[_("strong",[t._v("volatile")]),t._v("：适合轻量级同步（可见性/有序性），不涉及复合操作的场景。")])]),t._v(" "),_("p",[t._v("核心原则：根据并发强度（竞争频率）、功能需求（公平性、可中断性）选择合适的锁，优先使用JDK内置机制（减少手动管理成本）。")]),t._v(" "),_("h2",{attrs:{id:"扩展-常见问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扩展-常见问题"}},[t._v("#")]),t._v(" 扩展：常见问题")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("死锁如何产生？")]),_("br"),t._v("\n多个线程相互持有对方需要的锁，且不释放（如线程1持有锁A等待锁B，线程2持有锁B等待锁A）。")]),t._v(" "),_("li",[_("strong",[t._v("如何避免死锁？")]),t._v(" "),_("ul",[_("li",[t._v("按固定顺序获取锁；")]),t._v(" "),_("li",[t._v("设定锁的获取超时时间（如"),_("code",[t._v("ReentrantLock.tryLock(timeout)")]),t._v("）；")]),t._v(" "),_("li",[t._v("使用"),_("code",[t._v("LockSupport")]),t._v("中断线程等待。")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);