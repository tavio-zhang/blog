(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{424:function(s,e,a){"use strict";a.r(e);var n=a(8),r=Object(n.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[s._v("在分布式消息队列架构中，消费者作为消息流转的最终处理节点，其可靠性直接影响业务数据的一致性与系统稳定性。")]),s._v(" "),e("h2",{attrs:{id:"一、消费者可靠性的核心挑战"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、消费者可靠性的核心挑战"}},[s._v("#")]),s._v(" 一、消费者可靠性的核心挑战")]),s._v(" "),e("p",[s._v("消费者在处理消息时，受网络波动、系统故障、业务异常等因素影响，容易面临四类典型问题，这些问题可能直接导致业务故障：")]),s._v(" "),e("table",[e("thead",[e("tr",[e("th",[s._v("问题类型")]),s._v(" "),e("th",[s._v("产生场景")]),s._v(" "),e("th",[s._v("业务影响")])])]),s._v(" "),e("tbody",[e("tr",[e("td",[s._v("消息丢失")]),s._v(" "),e("td",[s._v("消费者自动确认消息后宕机，未完成业务处理，MQ因已确认而删除消息")]),s._v(" "),e("td",[s._v("业务数据不完整，出现数据一致性问题（如订单支付成功但未发货）")])]),s._v(" "),e("tr",[e("td",[s._v("重复消费")]),s._v(" "),e("td",[s._v("生产者重试、MQ网络超时重投、消费者确认延迟等场景导致消息重复投递")]),s._v(" "),e("td",[s._v("未做幂等处理时，可能引发业务重复执行（如重复扣款、重复生成订单）")])]),s._v(" "),e("tr",[e("td",[s._v("消费阻塞")]),s._v(" "),e("td",[s._v("单条消息处理耗时过长（如复杂计算、第三方接口超时），占用消费者线程资源")]),s._v(" "),e("td",[s._v("后续消息堆积，队列积压加剧，整体消费能力下降")])]),s._v(" "),e("tr",[e("td",[s._v("异常扩散")]),s._v(" "),e("td",[s._v("消费者处理消息时未捕获异常，导致线程崩溃甚至应用宕机")]),s._v(" "),e("td",[s._v("所有消息无法处理，服务整体不可用，引发级联故障")])])])]),s._v(" "),e("p",[s._v("基于以上挑战，消费者可靠性设计需围绕四大目标："),e("strong",[s._v("消息不丢失、消费不重复、流程不阻塞、异常可兜底")]),s._v("。")]),s._v(" "),e("h2",{attrs:{id:"二、消费者确认机制-确保消息处理状态的准确反馈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、消费者确认机制-确保消息处理状态的准确反馈"}},[s._v("#")]),s._v(" 二、消费者确认机制：确保消息处理状态的准确反馈")]),s._v(" "),e("p",[s._v("为避免消息丢失，RabbitMQ 提供了消费者确认机制（Consumer Acknowledgement）：消费者处理消息后，需向 MQ 发送回执告知处理状态，MQ 再根据回执决定消息的保留或删除。")]),s._v(" "),e("h3",{attrs:{id:"_2-1-三种确认回执类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-三种确认回执类型"}},[s._v("#")]),s._v(" 2.1 三种确认回执类型")]),s._v(" "),e("p",[s._v("RabbitMQ 定义了三种回执状态，分别对应不同的业务场景：")]),s._v(" "),e("ul",[e("li",[e("p",[e("strong",[s._v("ack（Acknowledgment）")]),s._v("：消息处理成功，MQ 收到后删除该消息。"),e("br"),s._v("\n适用场景：业务逻辑正常执行完毕（如订单状态更新成功、通知发送完成）。")])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("nack（Negative Acknowledgment）")]),s._v("：消息处理失败，MQ 需重新投递该消息（可指定是否重回原队列）。"),e("br"),s._v("\n适用场景：临时故障（如数据库连接短暂超时），重试后可能成功。")])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("reject（Reject）")]),s._v("：消息处理失败且拒绝再次投递，MQ 直接删除该消息（或路由到死信队列）。"),e("br"),s._v("\n适用场景：永久故障（如消息格式错误、业务参数非法），重试无意义。")])])]),s._v(" "),e("h3",{attrs:{id:"_2-2-spring-amqp-中的确认模式配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-spring-amqp-中的确认模式配置"}},[s._v("#")]),s._v(" 2.2 Spring AMQP 中的确认模式配置")]),s._v(" "),e("p",[s._v("Spring AMQP 对 RabbitMQ 的确认机制进行了封装，支持三种确认模式，可通过配置文件指定：")]),s._v(" "),e("h4",{attrs:{id:"_1-none-自动确认-不推荐"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-none-自动确认-不推荐"}},[s._v("#")]),s._v(" （1）none：自动确认（不推荐）")]),s._v(" "),e("p",[s._v("消息投递到消费者后，MQ 立即标记为已消费并删除，无需等待消费者反馈。"),e("br"),s._v(" "),e("strong",[s._v("风险")]),s._v("：若消费者处理过程中宕机，消息会丢失。"),e("br"),s._v(" "),e("strong",[s._v("配置")]),s._v("：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("spring:\n  rabbitmq:\n    listener:\n      simple:\n        acknowledge-mode: none  # 自动确认，投递后立即删除\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("h4",{attrs:{id:"_2-manual-手动确认-高可控场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-manual-手动确认-高可控场景"}},[s._v("#")]),s._v(" （2）manual：手动确认（高可控场景）")]),s._v(" "),e("p",[s._v("消费者需在业务代码中手动调用 "),e("code",[s._v("channel.basicAck()")]),s._v("、"),e("code",[s._v("channel.basicNack()")]),s._v(" 或 "),e("code",[s._v("channel.basicReject()")]),s._v(" 发送回执，适合需要精确控制确认时机的场景（如分布式事务中的二段提交）。")]),s._v(" "),e("p",[e("strong",[s._v("示例代码")]),s._v("：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('@RabbitListener(queues = "business.queue")\npublic void processMessage(String msg, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) throws IOException {\n    try {\n        // 业务处理逻辑\n        log.info("处理消息：{}", msg);\n        // 处理成功，发送ack（第二个参数false表示不批量确认）\n        channel.basicAck(deliveryTag, false);\n    } catch (Exception e) {\n        log.error("消息处理失败", e);\n        // 处理失败，发送nack（第三个参数true表示重回队列）\n        channel.basicNack(deliveryTag, false, true);\n        // 若为永久失败，可拒绝并丢弃：channel.basicReject(deliveryTag, false);\n    }\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("p",[e("strong",[s._v("注意")]),s._v("：手动模式需避免遗漏确认（如未捕获异常导致未发送回执），否则消息会一直处于“未确认”状态，占用 MQ 内存。")]),s._v(" "),e("h4",{attrs:{id:"_3-auto-自动确认-推荐默认"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-auto-自动确认-推荐默认"}},[s._v("#")]),s._v(" （3）auto：自动确认（推荐默认）")]),s._v(" "),e("p",[s._v("Spring 通过 AOP 对消息处理过程进行环绕增强，自动根据业务执行结果发送回执：")]),s._v(" "),e("ul",[e("li",[s._v("若业务方法正常返回，自动发送 ack；")]),s._v(" "),e("li",[s._v("若抛出未捕获异常，自动发送 nack（消息重回队列）。")])]),s._v(" "),e("p",[e("strong",[s._v("配置")]),s._v("：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("spring:\n  rabbitmq:\n    listener:\n      simple:\n        acknowledge-mode: auto  # 自动确认，基于业务结果\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("p",[e("strong",[s._v("风险")]),s._v("：若业务异常未抛出（如捕获异常但未处理），Spring 会误判为处理成功并发送 ack，导致消息丢失。因此需确保异常正确抛出或手动处理确认逻辑。")]),s._v(" "),e("h2",{attrs:{id:"三、重试机制与异常兜底-避免无效重试与消息堆积"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、重试机制与异常兜底-避免无效重试与消息堆积"}},[s._v("#")]),s._v(" 三、重试机制与异常兜底：避免无效重试与消息堆积")]),s._v(" "),e("p",[s._v("自动确认模式下，若消费者抛出异常，消息会不断重回队列并重复投递，导致“无限重试-业务阻塞-节点宕机”的恶性循环。需通过重试机制与异常兜底策略解决。")]),s._v(" "),e("h3",{attrs:{id:"_3-1-本地重试-限制重试次数与间隔"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-本地重试-限制重试次数与间隔"}},[s._v("#")]),s._v(" 3.1 本地重试：限制重试次数与间隔")]),s._v(" "),e("p",[s._v("Spring AMQP 提供本地重试机制，当消息处理失败时，先在消费者本地重试（不回退到 MQ），避免消息频繁在 MQ 与消费者间流转。")]),s._v(" "),e("p",[e("strong",[s._v("核心配置")]),s._v("：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("spring:\n  rabbitmq:\n    listener:\n      simple:\n        acknowledge-mode: auto\n        retry:\n          enabled: true  # 开启本地重试\n          initial-interval: 1000ms  # 首次重试间隔（如1秒）\n          multiplier: 2  # 重试间隔倍数（如2表示下次间隔为2秒、4秒...）\n          max-attempts: 3  # 最大重试次数（含首次处理，共3次）\n          stateless: true  # 是否无状态（默认true，适合非事务场景）\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br")])]),e("p",[e("strong",[s._v("参数说明")]),s._v("：")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("initial-interval")]),s._v("：控制首次重试延迟，避免瞬时故障（如缓存热点）立即重试加剧压力；")]),s._v(" "),e("li",[e("code",[s._v("multiplier")]),s._v("：通过指数增长的间隔时间，降低重试频率，给系统恢复留时间；")]),s._v(" "),e("li",[e("code",[s._v("max-attempts")]),s._v("：限制总重试次数，防止无限重试。")])]),s._v(" "),e("h3",{attrs:{id:"_3-2-重试耗尽后的兜底处理-messagerecoverer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-重试耗尽后的兜底处理-messagerecoverer"}},[s._v("#")]),s._v(" 3.2 重试耗尽后的兜底处理：MessageRecoverer")]),s._v(" "),e("p",[s._v("当本地重试次数耗尽后，需通过 "),e("code",[s._v("MessageRecoverer")]),s._v(" 接口处理最终失败的消息，常见策略包括：")]),s._v(" "),e("h4",{attrs:{id:"_1-路由到死信队列-推荐"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-路由到死信队列-推荐"}},[s._v("#")]),s._v(" （1）路由到死信队列（推荐）")]),s._v(" "),e("p",[s._v("将失败消息转发到专门的死信队列（Error Queue），由独立消费者监听并处理（如人工介入、告警通知）。")]),s._v(" "),e("p",[e("strong",[s._v("配置示例")]),s._v("：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('// 1. 定义死信交换机、队列及绑定关系\n@Bean\npublic DirectExchange errorExchange() {\n    return new DirectExchange("error.direct");\n}\n\n@Bean\npublic Queue errorQueue() {\n    return QueueBuilder.durable("error.queue").build();\n}\n\n@Bean\npublic Binding errorBinding(DirectExchange errorExchange, Queue errorQueue) {\n    return BindingBuilder.bind(errorQueue).to(errorExchange).with("error.routing.key");\n}\n\n// 2. 配置消息恢复器，将失败消息转发到死信队列\n@Bean\npublic MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate) {\n    return new RepublishMessageRecoverer(\n        rabbitTemplate, \n        "error.direct",  // 死信交换机\n        "error.routing.key"  // 死信路由键\n    );\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br")])]),e("h4",{attrs:{id:"_2-其他兜底策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-其他兜底策略"}},[s._v("#")]),s._v(" （2）其他兜底策略")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("LogAndDontRequeueRecoverer")]),s._v("：记录错误日志并丢弃消息（适合非核心业务）；")]),s._v(" "),e("li",[s._v("自定义 "),e("code",[s._v("MessageRecoverer")]),s._v("：如发送告警邮件、写入数据库等。")])]),s._v(" "),e("h2",{attrs:{id:"四、消息幂等性-确保重复消费的结果一致性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、消息幂等性-确保重复消费的结果一致性"}},[s._v("#")]),s._v(" 四、消息幂等性：确保重复消费的结果一致性")]),s._v(" "),e("p",[s._v("重复消费是分布式消息队列的必然现象（如网络超时重投、消费者重启后重连），需通过幂等设计保证“重复消费与一次消费结果一致”。")]),s._v(" "),e("h3",{attrs:{id:"_4-1-幂等设计的核心原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-幂等设计的核心原则"}},[s._v("#")]),s._v(" 4.1 幂等设计的核心原则")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("唯一标识")]),s._v("：为每条消息或业务操作生成唯一标识（如消息 ID、业务单号）；")]),s._v(" "),e("li",[e("strong",[s._v("原子判断")]),s._v("：通过原子操作判断该标识是否已被处理，避免并发问题。")])]),s._v(" "),e("h3",{attrs:{id:"_4-2-常见实现方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-常见实现方案"}},[s._v("#")]),s._v(" 4.2 常见实现方案")]),s._v(" "),e("h4",{attrs:{id:"_1-基于-redis-的原子操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于-redis-的原子操作"}},[s._v("#")]),s._v(" （1）基于 Redis 的原子操作")]),s._v(" "),e("p",[s._v("利用 Redis 的 "),e("code",[s._v("SETNX")]),s._v("（SET if Not Exists）命令，判断消息是否已消费：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('@Service\npublic class IdempotentConsumer {\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n\n    @RabbitListener(queues = "business.queue")\n    public void processMessage(Message msg) {\n        // 1. 获取消息唯一ID（需生产者在消息头中携带）\n        String messageId = msg.getMessageProperties().getMessageId();\n        if (messageId == null) {\n            throw new IllegalArgumentException("消息缺少唯一ID");\n        }\n\n        // 2. 用SETNX判断是否已消费（过期时间避免Redis内存溢出）\n        Boolean isFirstConsume = redisTemplate.opsForValue().setIfAbsent(\n            "msg:consumed:" + messageId, \n            "1", \n            24, \n            TimeUnit.HOURS\n        );\n\n        if (Boolean.TRUE.equals(isFirstConsume)) {\n            // 3. 首次消费，执行业务逻辑\n            executeBusiness(msg);\n        } else {\n            // 4. 重复消费，直接返回\n            log.info("消息已消费，忽略重复处理：{}", messageId);\n        }\n    }\n\n    private void executeBusiness(Message msg) {\n        // 实际业务处理（如订单创建、库存扣减）\n    }\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br")])]),e("h4",{attrs:{id:"_2-基于数据库唯一索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于数据库唯一索引"}},[s._v("#")]),s._v(" （2）基于数据库唯一索引")]),s._v(" "),e("p",[s._v("针对订单、支付等业务，使用业务唯一标识（如订单号）作为数据库唯一索引，避免重复插入：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('-- 创建订单表，订单号唯一\nCREATE TABLE `t_order` (\n  `id` bigint NOT NULL AUTO_INCREMENT,\n  `order_no` varchar(64) NOT NULL COMMENT \'订单号（唯一）\',\n  `amount` decimal(10,2) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_order_no` (`order_no`)  -- 唯一索引保证幂等\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n@Service\npublic class OrderConsumer {\n    @Autowired\n    private OrderMapper orderMapper;\n\n    @RabbitListener(queues = "order.queue")\n    public void createOrder(OrderMessage msg) {\n        try {\n            // 插入订单，若订单号已存在，会触发唯一索引冲突异常\n            orderMapper.insert(new Order(msg.getOrderNo(), msg.getAmount()));\n        } catch (DuplicateKeyException e) {\n            log.info("订单已创建，忽略重复消息：{}", msg.getOrderNo());\n        }\n    }\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br")])]),e("h2",{attrs:{id:"五、消费阻塞解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、消费阻塞解决方案"}},[s._v("#")]),s._v(" 五、消费阻塞解决方案")]),s._v(" "),e("p",[s._v("单条消息处理耗时过长会导致消费者线程被占用，引发队列堆积。可从以下角度优化：")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("异步化处理")]),s._v("：将耗时操作（如文件上传、第三方接口调用）异步化，消费者仅做消息接收与任务分发，不等待结果；")]),s._v(" "),e("li",[e("strong",[s._v("拆分大任务")]),s._v("：将单条复杂消息拆分为多个子任务，分批次处理；")]),s._v(" "),e("li",[e("strong",[s._v("线程池隔离")]),s._v("：为不同优先级的队列配置独立线程池，避免低优先级消息阻塞高优先级任务；")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("   spring:\n     rabbitmq:\n       listener:\n         simple:\n           concurrency: 5  # 核心线程数\n           max-concurrency: 10  # 最大线程数\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("ol",{attrs:{start:"4"}},[e("li",[e("strong",[s._v("设置超时时间")]),s._v("：对业务处理逻辑设置超时时间，超过阈值则中断并按失败处理（避免无限阻塞）。")])]),s._v(" "),e("h2",{attrs:{id:"六、总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、总结"}},[s._v("#")]),s._v(" 六、总结")]),s._v(" "),e("p",[s._v("消费者可靠性是消息队列架构稳定性的最后一道防线，需结合业务场景综合运用：")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("确认机制")]),s._v("：选择 auto 或 manual 模式，确保消息处理状态准确反馈；")]),s._v(" "),e("li",[e("strong",[s._v("重试与兜底")]),s._v("：通过本地重试减少无效 MQ 交互，死信队列兜底最终失败消息；")]),s._v(" "),e("li",[e("strong",[s._v("幂等设计")]),s._v("：基于 Redis 或数据库唯一索引，解决重复消费问题；")]),s._v(" "),e("li",[e("strong",[s._v("阻塞优化")]),s._v("：异步化、线程池隔离等手段避免队列堆积。")])]),s._v(" "),e("p",[s._v("通过以上措施，可构建“不丢、不重、不堵、可兜底”的可靠消费者体系，保障业务数据一致性与系统稳定性。")])])}),[],!1,null,null,null);e.default=r.exports}}]);