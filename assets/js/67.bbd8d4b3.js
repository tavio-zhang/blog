(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{422:function(s,t,e){"use strict";e.r(t);var a=e(8),n=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("Redis作为高性能键值数据库，其核心优势不仅在于内存存储和单线程模型，更在于对五大基础数据结构（String、List、Hash、Set、ZSet）的极致优化——通过动态切换底层存储结构，在内存占用与读写性能间找到完美平衡。")]),s._v(" "),t("h2",{attrs:{id:"string-二进制安全的动态字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-二进制安全的动态字符串"}},[s._v("#")]),s._v(" String：二进制安全的动态字符串")]),s._v(" "),t("p",[s._v("String是Redis最基础的数据结构，支持存储字符串、数字、二进制数据（如图片、序列化对象），最大容量512MB。其底层并非C语言原生字符串，而是"),t("strong",[s._v("SDS（Simple Dynamic String）")]),s._v("——一种专为Redis设计的动态字符串结构，替代了C语言原生字符串，解决了原生字符串的缺陷。")]),s._v(" "),t("h3",{attrs:{id:"_1-sds-解决c字符串的三大缺陷"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-sds-解决c字符串的三大缺陷"}},[s._v("#")]),s._v(" 1. SDS：解决C字符串的三大缺陷")]),s._v(" "),t("p",[s._v("C语言原生字符串以"),t("code",[s._v("\\0")]),s._v("为结束标识，存在三大问题：长度获取需O(n)遍历、二进制数据中含"),t("code",[s._v("\\0")]),s._v("会被截断、修改需频繁内存重分配。SDS通过精巧设计彻底解决这些问题：")]),s._v(" "),t("h4",{attrs:{id:"核心结构体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心结构体"}},[s._v("#")]),s._v(" 核心结构体")]),s._v(" "),t("p",[s._v("Redis为不同长度字符串设计4种头部（"),t("code",[s._v("sdshdr8/16/32/64")]),s._v("），用最小位数存储长度，避免内存浪费。以最常用的"),t("code",[s._v("sdshdr8")]),s._v("为例：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("# 核心代码\nstruct sdshdr8 {\n    uint8_t len;        // 已使用字节数（O(1)获取长度）\n    uint8_t alloc;      // 总分配字节数（不含头部和终止符）\n    unsigned char flags;// 标识类型（8/16/32/64，占1字节）\n    char buf[];         // 柔性数组，存储实际数据（二进制安全）\n};\n// flags 0=sdshdr8, 1=sdshdr16, 2=sdshdr32,3=sdshdr64\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("ul",[t("li",[t("strong",[s._v("二进制安全")]),s._v("：通过"),t("code",[s._v("len")]),s._v("字段记录有效长度，读取时直接按"),t("code",[s._v("len")]),s._v("截取"),t("code",[s._v("buf")]),s._v("，即使数据含"),t("code",[s._v("\\0")]),s._v("也不会截断（末尾额外存"),t("code",[s._v("\\0")]),s._v("仅为兼容C函数）。")]),s._v(" "),t("li",[t("strong",[s._v("内存预分配")]),s._v("：修改时减少内存重分配次数（malloc/free是昂贵操作）：\n"),t("ul",[t("li",[s._v("若新长度≤1MB："),t("code",[s._v("alloc")]),s._v("翻倍（如从100字节扩容到200字节）；")]),s._v(" "),t("li",[s._v("若新长度>1MB："),t("code",[s._v("alloc")]),s._v("增加1MB（避免过度预分配）；")]),s._v(" "),t("li",[s._v("若新长度过大：触发"),t("code",[s._v("SDS")]),s._v("结构体升级（如新数据长度>2^8-1字节，会先创建并分配sdshdr16的结构体，将原sdshdr8的buf数据完整拷贝到sdshdr16的buf中，写入新增数据，更新len字段，释放当前sdshdr8结构体占用的内存，完成扩容）。")])])]),s._v(" "),t("li",[t("strong",[s._v("惰性缩容")]),s._v("：缩短字符串时仅更新"),t("code",[s._v("len")]),s._v("，不释放多余内存，后续写入可复用已分配的buf，减少内存重分配开销。"),t("strong",[t("code",[s._v("SDS仅升级不会主动降级")])])])]),s._v(" "),t("h3",{attrs:{id:"_2-string的三种编码-按需切换的内存优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-string的三种编码-按需切换的内存优化"}},[s._v("#")]),s._v(" 2. String的三种编码：按需切换的内存优化")]),s._v(" "),t("p",[s._v("String实际是"),t("code",[s._v("redisObject")]),s._v("包裹的底层编码，根据存储内容自动切换：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("# 核心代码（redisObject结构）\ntypedef struct redisObject {\n    unsigned type:4;    // 数据类型（STRING/LIST/HASH等）\n    unsigned encoding:4;// 编码类型（int/embstr/raw等）\n    unsigned lru:24;    // LRU时间戳（用于内存淘汰）\n    int refcount;       // 引用计数（内存回收）\n    void *ptr;          // 指向底层数据（SDS/整数）\n} robj;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("table",[t("thead",[t("tr",[t("th",[s._v("编码类型")]),s._v(" "),t("th",[s._v("适用场景")]),s._v(" "),t("th",[s._v("内存布局")]),s._v(" "),t("th",[s._v("优势")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("int")]),s._v(" "),t("td",[s._v('字符串为64位内整数（如"123"）')]),s._v(" "),t("td",[t("code",[s._v("ptr")]),s._v("直接存整数，无SDS")]),s._v(" "),t("td",[s._v("极致省内存，O(1)读写")])]),s._v(" "),t("tr",[t("td",[s._v("embstr")]),s._v(" "),t("td",[s._v("短字符串（≤44字节）")]),s._v(" "),t("td",[t("code",[s._v("redisObject + sdshdr + buf")]),s._v("连续内存（一次malloc）")]),s._v(" "),t("td",[s._v("内存碎片少，创建/销毁效率高")])]),s._v(" "),t("tr",[t("td",[s._v("raw")]),s._v(" "),t("td",[s._v("长字符串（>44字节）")]),s._v(" "),t("td",[t("code",[s._v("redisObject")]),s._v("与"),t("code",[s._v("sdshdr")]),s._v("分开分配（两次malloc）")]),s._v(" "),t("td",[s._v("避免长字符串重分配影响对象头")])])])]),s._v(" "),t("ul",[t("li",[t("p",[t("strong",[s._v("什么是malloc？")]),t("br"),s._v(" "),t("code",[s._v("malloc")]),s._v("是C语言动态申请堆内存的核心接口，Redis依靠它实现"),t("code",[s._v("SDS")]),s._v("、哈希表等数据结构的动态内存管理，是Redis能灵活存储任意长度的基础，而"),t("code",[s._v("free")]),s._v("是配套的内存回收操作。")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("为什么embstr上限是44字节？")]),t("br"),s._v(" "),t("code",[s._v("redisObject")]),s._v("占16字节，"),t("code",[s._v("sdshdr8")]),s._v("头部占3字节，末尾"),t("code",[s._v("\\0")]),s._v("占1字节，总固定开销20字节。64字节内存块中剩余44字节用于存储实际数据（64-16-3-1=44），刚好适配CPU缓存行（64字节），提升访问速度。")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("embstr的ptr指向")]),t("br"),s._v(" "),t("code",[s._v("ptr")]),s._v("字段在"),t("code",[s._v("embstr")]),s._v("编码下，并非指向独立的"),t("code",[s._v("SDS")]),s._v("，而是指向同一块内存中紧跟redisObject后的"),t("code",[s._v("sdshdr")]),s._v("起始地址。")])])]),s._v(" "),t("h3",{attrs:{id:"实战建议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战建议"}},[s._v("#")]),s._v(" 实战建议")]),s._v(" "),t("ul",[t("li",[s._v("存储数字时优先用String的int编码（如计数器场景），避免转为embstr/raw；")]),s._v(" "),t("li",[s._v("二进制数据（如图片）建议拆分后存储（单key不超过100KB），避免大字符串扩容开销；")]),s._v(" "),t("li",[s._v("频繁修改的短字符串（如用户昵称）天然适配embstr，无需额外优化。")])]),s._v(" "),t("h2",{attrs:{id:"list-从ziplist到quicklist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list-从ziplist到quicklist"}},[s._v("#")]),s._v(" List：从ziplist到quicklist")]),s._v(" "),t("p",[s._v("List是有序、可重复的字符串集合，支持两端插入/删除、范围查询，底层实现随数据规模动态变化，核心目标是"),t("strong",[s._v("小数据省内存，大数据保性能")]),s._v("。")]),s._v(" "),t("h3",{attrs:{id:"_1-ziplist-紧凑存储的双向链表-小列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-ziplist-紧凑存储的双向链表-小列表"}},[s._v("#")]),s._v(" 1. ziplist：紧凑存储的双向链表（小列表）")]),s._v(" "),t("p",[s._v("ziplist是Redis为小数据设计的紧凑结构，用连续内存块存储元素 + 无指针开销的设计大幅降低内存占用，替代普通双向链表（普通双向链表每个节点都包含前后指针，内存开销大且易产生碎片）适合节点少、元素小的场景。")]),s._v(" "),t("h4",{attrs:{id:"核心结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心结构"}},[s._v("#")]),s._v(" 核心结构")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("# 结构示意图\n+--------+--------+--------+---------+---------+-------+\n| zlbytes| zltail | zllen  | entry1  | entry2  | zlend |\n+--------+--------+--------+---------+---------+-------+\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("ul",[t("li",[t("code",[s._v("zlbytes")]),s._v("：总字节数（快速内存重分配）；")]),s._v(" "),t("li",[t("code",[s._v("zltail")]),s._v("：尾节点偏移量（O(1)定位尾节点）；")]),s._v(" "),t("li",[t("code",[s._v("zllen")]),s._v("：节点数（≤65535时准确，超则需遍历）；")]),s._v(" "),t("li",[t("code",[s._v("entry")]),s._v("：存储元素（含"),t("code",[s._v("prevlen")]),s._v("+"),t("code",[s._v("encoding")]),s._v("+"),t("code",[s._v("data")]),s._v("）；")]),s._v(" "),t("li",[t("code",[s._v("zlend")]),s._v("：结束标记（固定为0xFF）。")])]),s._v(" "),t("h4",{attrs:{id:"entry结构细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#entry结构细节"}},[s._v("#")]),s._v(" entry结构细节")]),s._v(" "),t("p",[s._v("每个元素由三部分组成：")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("prevlen")]),s._v("：前节点长度（1字节或5字节，<254用1字节，否则用1字节0xFE+4字节长度）；")]),s._v(" "),t("li",[t("code",[s._v("encoding")]),s._v("：数据类型（区分字符串/整数，如0x00表示短字符串）；")]),s._v(" "),t("li",[t("code",[s._v("data")]),s._v("：实际数据（按encoding规则存储）。")])]),s._v(" "),t("h4",{attrs:{id:"双向遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向遍历"}},[s._v("#")]),s._v(" 双向遍历")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("正向遍历")]),s._v("是从首节点开始，通过解析当前节点的encoding计算长度，定位下一个节点；")]),s._v(" "),t("li",[t("code",[s._v("反向遍历")]),s._v("是通过zltail定位尾节点，再通过节点的prevlen反向找前一个节点。")])]),s._v(" "),t("h4",{attrs:{id:"痛点-连锁更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#痛点-连锁更新"}},[s._v("#")]),s._v(" 痛点：连锁更新")]),s._v(" "),t("p",[s._v("当某节点长度从253→254时，下节点的"),t("code",[s._v("prevlen")]),s._v("需从1字节扩为5字节，可能触发下下个节点的"),t("code",[s._v("prevlen")]),s._v("更新，形成连锁反应（极端O(n)耗时）。因此Redis对ziplist使用限制严格：")]),s._v(" "),t("ul",[t("li",[s._v("节点数≤"),t("code",[s._v("list-max-ziplist-entries")]),s._v("（默认512）；")]),s._v(" "),t("li",[s._v("单个元素≤"),t("code",[s._v("list-max-ziplist-value")]),s._v("（默认64字节）。")])]),s._v(" "),t("h3",{attrs:{id:"_2-adlist-通用双向链表-旧版大列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-adlist-通用双向链表-旧版大列表"}},[s._v("#")]),s._v(" 2. adlist：通用双向链表（旧版大列表）")]),s._v(" "),t("p",[s._v("adlist是Redis早期用于大列表的底层结构，兼顾灵活性但内存开销较高。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("# 核心代码（adlist结构）\n// 链表节点\ntypedef struct listNode {\n    struct listNode *prev;  // 前驱节点指针\n    struct listNode *next;  // 后继节点指针\n    void *value;            // 数据指针（支持任意类型）\n} listNode;\n\n// 链表本体\ntypedef struct list {\n    listNode *head;          // 头节点指针\n    listNode *tail;          // 尾节点指针\n    unsigned long len;       // 节点数量（O(1)获取长度）\n    void *(*dup)(void *ptr); // 节点值复制函数（自定义逻辑）\n    void (*free)(void *ptr); // 节点值释放函数（自定义逻辑）\n    int (*match)(void *ptr, void *key); // 节点值匹配函数（自定义逻辑）\n} list;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br")])]),t("h4",{attrs:{id:"adlist核心特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#adlist核心特征"}},[s._v("#")]),s._v(" adlist核心特征")]),s._v(" "),t("ul",[t("li",[s._v("双向遍历+无环设计：通过prev/next指针支持正反遍历，避免死循环；")]),s._v(" "),t("li",[s._v("O(1)核心操作：直接通过len字段获取长度，无需遍历；")]),s._v(" "),t("li",[s._v("缺陷：节点分散导致内存碎片多，遍历需频繁切换内存地址，效率低于ziplist。")])]),s._v(" "),t("h3",{attrs:{id:"_3-quicklist-ziplist与链表的融合-redis3-2-默认"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-quicklist-ziplist与链表的融合-redis3-2-默认"}},[s._v("#")]),s._v(" 3. quicklist：ziplist与链表的融合（Redis3.2+默认）")]),s._v(" "),t("p",[s._v("为解决ziplist连锁更新和adlist内存碎片问题，quicklist采用“链表包裹ziplist”的设计：每个链表节点（"),t("code",[s._v("quicklistNode")]),s._v("）封装一个ziplist，兼顾紧凑性和灵活性。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("# 核心代码（quicklist结构）\n// quicklist 整体结构体\ntypedef struct quicklist {\n    quicklistNode *head;          // 链表头节点指针\n    quicklistNode *tail;          // 链表尾节点指针\n    unsigned long count;          // 所有ziplist中的总元素数（O(1)获取长度）\n    unsigned long len;            // quicklistNode的数量（链表节点数）\n    int fill : 16;                // 每个ziplist的最大填充限制（元素数/字节数）\n    unsigned int compress : 16;   // 压缩深度（控制中间节点LZF压缩）\n} quicklist;\n\n// quicklist 链表节点\ntypedef struct quicklistNode {\n    struct quicklistNode *prev;   // 前驱节点指针\n    struct quicklistNode *next;   // 后继节点指针\n    unsigned char *zl;            // 指向ziplist的指针（未压缩）\n    unsigned int zl_bytes;        // ziplist的总字节数\n    unsigned int count : 16;      // 当前ziplist中的元素数\n    unsigned int encoding : 2;    // 编码方式：RAW（未压缩）/LZF（压缩）\n    unsigned int container : 2;   // 容器类型：仅支持ZIPLIST\n    unsigned int recompress : 1;  // 标记：是否需要重新压缩（临时解压后）\n    unsigned int attempted_compress : 1; // 标记：是否尝试过压缩\n    unsigned int extra : 10;      // 预留位\n} quicklistNode;\n\n// 压缩后的ziplist结构（LZF压缩）\ntypedef struct quicklistLZF {\n    unsigned int sz;  // 压缩后的字节数\n    char compressed[];// 压缩后的ziplist数据\n} quicklistLZF;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br")])]),t("h4",{attrs:{id:"关键优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关键优化"}},[s._v("#")]),s._v(" 关键优化")]),s._v(" "),t("ul",[t("li",[s._v("压缩策略：通过"),t("code",[s._v("compress")]),s._v("控制中间节点LZF压缩（头尾部不压缩，保证读写效率）；")]),s._v(" "),t("li",[s._v("动态拆分/合并：插入元素时若ziplist超"),t("code",[s._v("fill")]),s._v("阈值，自动拆分新节点；删除后若ziplist过空，合并相邻节点。")])]),s._v(" "),t("h3",{attrs:{id:"实战建议-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战建议-2"}},[s._v("#")]),s._v(" 实战建议")]),s._v(" "),t("ul",[t("li",[s._v("消息队列场景建议将"),t("code",[s._v("list-max-ziplist-entries")]),s._v("调大（如1024），减少quicklist节点数；")]),s._v(" "),t("li",[s._v("频繁修改中间元素的场景（如日志记录）避免用List，改用ZSet按时间戳排序；")]),s._v(" "),t("li",[s._v("启用压缩（"),t("code",[s._v("compress=1")]),s._v("）可降低长列表内存占用（如历史记录）。")])]),s._v(" "),t("h2",{attrs:{id:"hash-键值对集合的两种存储策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash-键值对集合的两种存储策略"}},[s._v("#")]),s._v(" Hash：键值对集合的两种存储策略")]),s._v(" "),t("p",[s._v("Hash用于存储field-value键值对（如用户信息："),t("code",[s._v('user:1 {name: "xxx", age: 20}')]),s._v("），底层根据数据规模在ziplist和dict间切换。")]),s._v(" "),t("h3",{attrs:{id:"_1-ziplist-小hash的紧凑存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-ziplist-小hash的紧凑存储"}},[s._v("#")]),s._v(" 1. ziplist：小Hash的紧凑存储")]),s._v(" "),t("p",[s._v("当Hash满足：")]),s._v(" "),t("ul",[t("li",[s._v("节点数≤"),t("code",[s._v("hash-max-ziplist-entries")]),s._v("（默认512）；")]),s._v(" "),t("li",[s._v("单个field/value≤"),t("code",[s._v("hash-max-ziplist-value")]),s._v("（默认64字节）；")])]),s._v(" "),t("p",[s._v("存储格式为"),t("code",[s._v("field1 → value1 → field2 → value2")]),s._v("（连续排列），查找时需遍历ziplist匹配field。")]),s._v(" "),t("h3",{attrs:{id:"_2-dict-大hash的高效存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-dict-大hash的高效存储"}},[s._v("#")]),s._v(" 2. dict：大Hash的高效存储")]),s._v(" "),t("p",[s._v("dict是Redis实现的高性能哈希表，支持O(1)读写，核心解决普通哈希表扩容阻塞问题。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("# 核心代码（dict结构）\n// 哈希节点（最小单元）\ntypedef struct dictEntry {\n    void *key;                // 键（Redis中通常是字符串对象）\n    union {                   // 值（支持多类型，节省内存）\n        void *val;            // 通用值指针（如Hash的value）\n        uint64_t u64;         // 无符号整数（优化小整数存储）\n        int64_t s64;          // 有符号整数\n        double d;             // 浮点数\n    } v;\n    struct dictEntry *next;   // 下一个节点指针（解决哈希冲突，形成链表）\n} dictEntry;\n\n// 哈希表\ntypedef struct dictht {\n    dictEntry **table;        // 哈希槽数组（元素是dictEntry*，初始为NULL）\n    unsigned long size;       // 哈希槽数组大小（2的幂次，如4、8、16）\n    unsigned long sizemask;   // 掩码 = size - 1，用于计算哈希槽索引（hash & sizemask）\n    unsigned long used;       // 已存储的dictEntry数量（键值对总数）\n    unsigned long deleted;    // 已标记删除的节点数（惰性删除）\n} dictht;\n\n// 字典本体\ntypedef struct dict {\n    dictType *type;           // 自定义操作函数（哈希、对比、复制、释放）\n    void *privdata;           // 私有数据（传给自定义函数）\n    dictht ht[2];             // 双哈希表：ht[0]正常使用，ht[1]用于rehash\n    long rehashidx;           // rehash进度索引（-1表示未开启rehash）\n    int16_t pauserehash;      // 标记：是否暂停rehash（如阻塞操作时）\n} dict;\n\n// 自定义操作函数（适配不同数据类型）\ntypedef struct dictType {\n    uint64_t (*hashFunction)(const void *key); // 哈希函数（默认SIPHASH）\n    int (*keyCompare)(const void *privdata, const void *key1, const void *key2); // 键对比\n    void *(*keyDup)(void *privdata, const void *key); // 键复制\n    void *(*valDup)(void *privdata, const void *obj); // 值复制\n    void (*keyFree)(void *privdata, void *key); // 键释放\n    void (*valFree)(void *privdata, void *obj); // 值释放\n} dictType;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br"),t("span",{staticClass:"line-number"},[s._v("31")]),t("br"),t("span",{staticClass:"line-number"},[s._v("32")]),t("br"),t("span",{staticClass:"line-number"},[s._v("33")]),t("br"),t("span",{staticClass:"line-number"},[s._v("34")]),t("br"),t("span",{staticClass:"line-number"},[s._v("35")]),t("br"),t("span",{staticClass:"line-number"},[s._v("36")]),t("br"),t("span",{staticClass:"line-number"},[s._v("37")]),t("br"),t("span",{staticClass:"line-number"},[s._v("38")]),t("br"),t("span",{staticClass:"line-number"},[s._v("39")]),t("br"),t("span",{staticClass:"line-number"},[s._v("40")]),t("br")])]),t("h4",{attrs:{id:"渐进式rehash-避免主线程阻塞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渐进式rehash-避免主线程阻塞"}},[s._v("#")]),s._v(" 渐进式rehash：避免主线程阻塞")]),s._v(" "),t("p",[s._v("普通哈希表扩容需一次性迁移所有数据，会阻塞Redis。dict采用分批次迁移：")]),s._v(" "),t("ol",[t("li",[s._v("触发条件：\n"),t("ul",[t("li",[s._v("扩容：负载因子（"),t("code",[s._v("used/size")]),s._v("）>1（非BGSAVE时）或>5（强制）；")]),s._v(" "),t("li",[s._v("缩容：负载因子<0.1或已删除节点数>used/2；")])])]),s._v(" "),t("li",[s._v("迁移过程：每次操作（增删改查）或定时任务迁移部分槽，"),t("code",[s._v("rehashidx")]),s._v("记录进度；")]),s._v(" "),t("li",[s._v("读写逻辑：读查"),t("code",[s._v("ht[0]")]),s._v("→"),t("code",[s._v("ht[1]")]),s._v("，写直接入"),t("code",[s._v("ht[1]")]),s._v("，保证数据一致性。")])]),s._v(" "),t("h4",{attrs:{id:"redis7-0-优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis7-0-优化"}},[s._v("#")]),s._v(" Redis7.0+优化")]),s._v(" "),t("ul",[t("li",[s._v("哈希冲突解决：桶内元素>8时，链表转为跳表（查询从O(n)→O(logn)）；")]),s._v(" "),t("li",[s._v("异步rehash：迁移任务交给后台线程，彻底避免主线程阻塞。")])]),s._v(" "),t("h3",{attrs:{id:"实战建议-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战建议-3"}},[s._v("#")]),s._v(" 实战建议")]),s._v(" "),t("ul",[t("li",[s._v("存储对象属性时优先用Hash（比多个String节省内存）；")]),s._v(" "),t("li",[s._v("高频更新的大Hash（如商品属性）建议提前将"),t("code",[s._v("hash-max-ziplist-entries")]),s._v("设为较小值（如128），避免ziplist遍历耗时；")]),s._v(" "),t("li",[s._v("避免大量小Hash（如千万级用户信息），可按ID分片（"),t("code",[s._v("user:1000:info")]),s._v("、"),t("code",[s._v("user:2000:info")]),s._v("）。")])]),s._v(" "),t("h2",{attrs:{id:"set-无序唯一集合的两种实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set-无序唯一集合的两种实现"}},[s._v("#")]),s._v(" Set：无序唯一集合的两种实现")]),s._v(" "),t("p",[s._v("Set是无序、唯一的字符串集合（如标签、好友ID），底层根据元素类型自动选择intset或dict。")]),s._v(" "),t("h3",{attrs:{id:"_1-intset-纯整数集合的紧凑存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-intset-纯整数集合的紧凑存储"}},[s._v("#")]),s._v(" 1. intset：纯整数集合的紧凑存储")]),s._v(" "),t("p",[s._v("当Set元素全为整数且数量少（≤"),t("code",[s._v("set-max-intset-entries")]),s._v("，默认512）时，用intset存储：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("# 核心代码（intset结构）\ntypedef struct intset {\n    uint32_t encoding; // 编码（INT16/32/64，根据最大元素确定）\n    uint32_t length;   // 元素数\n    int8_t contents[]; // 柔性数组，存储有序、唯一的整数（按编码对齐）\n} intset;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("h4",{attrs:{id:"核心特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心特性"}},[s._v("#")]),s._v(" 核心特性")]),s._v(" "),t("ul",[t("li",[s._v("自动升级：插入元素超出当前编码范围时，扩容内存并迁移所有元素（不可逆）；")]),s._v(" "),t("li",[s._v("有序性：元素按升序排列，支持二分查找（O(logn)）；")]),s._v(" "),t("li",[s._v("唯一性：插入前检查元素是否存在，避免重复。")])]),s._v(" "),t("h3",{attrs:{id:"_2-dict-通用集合存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-dict-通用集合存储"}},[s._v("#")]),s._v(" 2. dict：通用集合存储")]),s._v(" "),t("p",[s._v("当元素含字符串或数量超阈值时，用dict存储：key为集合元素，value为NULL（仅用key保证唯一性）。")]),s._v(" "),t("h3",{attrs:{id:"实战建议-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战建议-4"}},[s._v("#")]),s._v(" 实战建议")]),s._v(" "),t("ul",[t("li",[s._v("纯整数集合（如用户ID）优先用Set的intset编码，内存占用仅为List的1/10；")]),s._v(" "),t("li",[s._v("交集/并集操作（"),t("code",[s._v("SINTER")]),s._v("/"),t("code",[s._v("SUNION")]),s._v("）适合用Set，底层通过哈希表高效实现；")]),s._v(" "),t("li",[s._v("避免存储大量重复元素（Set会自动去重，浪费写入资源）。")])]),s._v(" "),t("h2",{attrs:{id:"zset-有序唯一集合的跳表-字典组合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zset-有序唯一集合的跳表-字典组合"}},[s._v("#")]),s._v(" ZSet：有序唯一集合的跳表+字典组合")]),s._v(" "),t("p",[s._v("ZSet是按score排序的唯一集合（如排行榜、延迟队列），底层根据数据规模在ziplist和“跳表+dict”间切换。")]),s._v(" "),t("h3",{attrs:{id:"_1-ziplist-小zset的紧凑存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-ziplist-小zset的紧凑存储"}},[s._v("#")]),s._v(" 1. ziplist：小ZSet的紧凑存储")]),s._v(" "),t("p",[s._v("当满足：")]),s._v(" "),t("ul",[t("li",[s._v("元素数≤"),t("code",[s._v("zset-max-ziplist-entries")]),s._v("（默认128）；")]),s._v(" "),t("li",[s._v("单个元素≤"),t("code",[s._v("zset-max-ziplist-value")]),s._v("（默认64字节）；")])]),s._v(" "),t("p",[s._v("存储格式为"),t("code",[s._v("member1 → score1 → member2 → score2")]),s._v("（按score升序），插入时需遍历找到位置。")]),s._v(" "),t("h3",{attrs:{id:"_2-跳表-dict-大zset的高效存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-跳表-dict-大zset的高效存储"}},[s._v("#")]),s._v(" 2. 跳表+dict：大ZSet的高效存储")]),s._v(" "),t("p",[s._v("为同时支持“按score排序”和“快速查询member的score”，ZSet采用双结构：")]),s._v(" "),t("ul",[t("li",[s._v("跳表（zskiplist）：按score排序存储member+score，支持O(logn)插入、删除、范围查询；")]),s._v(" "),t("li",[s._v("dict：映射member→score，支持O(1)查询score和判断member是否存在。")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("# 核心代码（ZSet结构）\n// 跳表节点\ntypedef struct zskiplistNode {\n    sds ele;               // member字符串（SDS）\n    double score;          // 分值\n    struct zskiplistNode *backward; // 后退指针（仅用于尾节点遍历）\n    struct zskiplistLevel {\n        struct zskiplistNode *forward; // 前进指针\n        unsigned long span; // 到下一个节点的元素个数（用于排名计算）\n    } level[];             // 随机层数（1-32）\n} zskiplistNode;\n\n// 跳表主结构\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail; // 头/尾节点\n    unsigned long length; // 节点数\n    int level;            // 最大层数\n} zskiplist;\n\n// ZSet组合结构\ntypedef struct zset {\n    dict *dict; // member → score映射\n    zskiplist *zsl; // 按score排序的跳表\n} zset;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br")])]),t("h4",{attrs:{id:"跳表核心特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跳表核心特征"}},[s._v("#")]),s._v(" 跳表核心特征")]),s._v(" "),t("ul",[t("li",[s._v("分层设计：底层（0层）含所有节点，高层节点更少，作为“快速通道”，查找效率O(logn)；")]),s._v(" "),t("li",[s._v("严格有序：按score升序排列，所有层的链表遵循同一顺序；")]),s._v(" "),t("li",[s._v("随机层数：新节点层数随机生成（1-32），避免层级结构失衡。")])]),s._v(" "),t("h4",{attrs:{id:"结构示例-简化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构示例-简化"}},[s._v("#")]),s._v(" 结构示例（简化）")]),s._v(" "),t("p",[s._v("假设 Zset 存储 {a:1, b:2, c:3}，跳表结构简化如下（仅展示核心层）：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("# 层 2（最高层）：header → c (span=3) → NULL\n# 层 1：header → b (span=2) → c (span=1) → NULL\n# 层 0（基础层）：header → a (span=1) → b (span=1) → c (span=1) → NULL\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("h3",{attrs:{id:"实战建议-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战建议-5"}},[s._v("#")]),s._v(" 实战建议")]),s._v(" "),t("ul",[t("li",[s._v("排行榜场景用"),t("code",[s._v("ZADD")]),s._v("+"),t("code",[s._v("ZREVRANGE")]),s._v("，利用跳表高效范围查询；")]),s._v(" "),t("li",[s._v("延迟队列（按时间戳score）用"),t("code",[s._v("ZRANGEBYSCORE")]),s._v("获取到期任务；")]),s._v(" "),t("li",[s._v("大ZSet（百万级元素）建议禁用ziplist（调小"),t("code",[s._v("zset-max-ziplist-entries")]),s._v("），避免插入耗时增长。")])]),s._v(" "),t("h2",{attrs:{id:"总结-redis数据结构的设计哲学"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结-redis数据结构的设计哲学"}},[s._v("#")]),s._v(" 总结：Redis数据结构的设计哲学")]),s._v(" "),t("p",[s._v("Redis对数据结构的优化始终围绕“"),t("strong",[s._v("平衡内存与性能")]),s._v("”：")]),s._v(" "),t("ul",[t("li",[s._v("小数据用紧凑结构（ziplist、intset、embstr）减少内存开销；")]),s._v(" "),t("li",[s._v("大数据用高效结构（quicklist、dict、跳表）保证读写性能；")]),s._v(" "),t("li",[s._v("动态切换机制（阈值控制）适配不同场景；")]),s._v(" "),t("li",[s._v("避免阻塞（渐进式rehash、异步操作）保证高可用性。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);