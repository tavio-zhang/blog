(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{425:function(_,v,t){"use strict";t.r(v);var a=t(8),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("Redis作为高性能内存数据库，数据默认存储于内存中，若服务器意外宕机，数据将全部丢失。持久化机制是Redis保障数据可靠性的核心手段，其本质是将内存数据以特定格式写入磁盘，以便重启时恢复。\nRedis提供两种经典持久化方式（RDB、AOF），并在4.0+版本引入混合持久化，兼顾性能与可靠性。")]),_._v(" "),v("h2",{attrs:{id:"rdb-快照式持久化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rdb-快照式持久化"}},[_._v("#")]),_._v(" RDB：快照式持久化")]),_._v(" "),v("p",[_._v("RDB是Redis默认的持久化方式，核心是"),v("strong",[_._v("在指定时间点生成内存数据的全量快照")]),_._v("，并写入磁盘文件（默认名为"),v("code",[_._v("dump.rdb")]),_._v("）。")]),_._v(" "),v("h3",{attrs:{id:"_1-rdb触发条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-rdb触发条件"}},[_._v("#")]),_._v(" 1. RDB触发条件")]),_._v(" "),v("p",[_._v("RDB触发分为"),v("strong",[_._v("手动触发")]),_._v("和"),v("strong",[_._v("自动触发")]),_._v("，核心区别在于是否阻塞主线程。")]),_._v(" "),v("h4",{attrs:{id:"手动触发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#手动触发"}},[_._v("#")]),_._v(" 手动触发")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("命令")]),_._v(" "),v("th",[_._v("执行方式")]),_._v(" "),v("th",[_._v("阻塞性")]),_._v(" "),v("th",[_._v("适用场景")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("SAVE")]),_._v(" "),v("td",[_._v("主线程直接执行快照")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("仅测试或紧急备份，生产环境禁用")])]),_._v(" "),v("tr",[v("td",[_._v("BGSAVE")]),_._v(" "),v("td",[_._v("fork子进程执行快照")]),_._v(" "),v("td",[_._v("否")]),_._v(" "),v("td",[_._v("生产环境手动备份（推荐）")])])])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("SAVE风险")]),_._v("：在主线程执行，期间Redis无法处理客户端请求，阻塞时间随数据量增长而延长（GB级数据可能阻塞秒级）。")]),_._v(" "),v("li",[v("strong",[_._v("BGSAVE优势")]),_._v("：通过fork子进程负责写盘，主线程继续处理请求，仅fork瞬间有短暂阻塞（微秒级）。")])]),_._v(" "),v("h4",{attrs:{id:"自动触发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自动触发"}},[_._v("#")]),_._v(" 自动触发")]),_._v(" "),v("p",[_._v("Redis通过配置文件的"),v("code",[_._v("save <秒数> <修改次数>")]),_._v("规则自动触发BGSAVE，满足任一规则即执行：")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("# redis.conf 默认配置\nsave 900 1    # 900秒内至少1次修改\nsave 300 10   # 300秒内至少10次修改\nsave 60 10000 # 60秒内至少10000次修改\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br")])]),v("p",[_._v("其他自动触发场景：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("FLUSHALL")]),_._v("：清空所有数据时，触发SAVE（生成空RDB文件）；")]),_._v(" "),v("li",[_._v("主从复制：主节点接收从节点同步请求时，自动触发BGSAVE生成快照并发送；")]),_._v(" "),v("li",[_._v("正常关闭（"),v("code",[_._v("SHUTDOWN")]),_._v("）：触发SAVE确保数据落盘后退出。")])]),_._v(" "),v("h3",{attrs:{id:"_2-rdb核心原理-写时复制-copy-on-write"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-rdb核心原理-写时复制-copy-on-write"}},[_._v("#")]),_._v(" 2. RDB核心原理：写时复制（Copy-On-Write）")]),_._v(" "),v("p",[_._v("BGSAVE的高效依赖"),v("strong",[_._v("fork子进程")]),_._v("和"),v("strong",[_._v("写时复制")]),_._v("机制，确保快照一致性且不阻塞主线程：")]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("fork子进程")]),_._v("：主线程执行"),v("code",[_._v("fork()")]),_._v("时，操作系统采用写时复制策略——父子进程共享内存页表（不立即复制实际数据），子进程拥有独立空间，可安全遍历内存生成快照，主线程继续处理请求。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("子进程生成RDB")]),_._v("：子进程遍历内存数据，按Redis二进制格式写入临时文件，完成后替换旧RDB文件。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("写时复制生效")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("若主线程不修改数据，父子进程共享内存页，子进程读取原始数据；")]),_._v(" "),v("li",[_._v("若主线程修改数据，操作系统复制该内存页，主线程操作新页，子进程继续读取旧页，确保快照数据是fork时刻的一致状态。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("资源回收")]),_._v("：子进程完成后通过信号通知主线程，主线程更新持久化状态（如"),v("code",[_._v("rdb_last_save_time")]),_._v("）。")])])]),_._v(" "),v("h3",{attrs:{id:"_3-rdb文件结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-rdb文件结构"}},[_._v("#")]),_._v(" 3. RDB文件结构")]),_._v(" "),v("p",[_._v("RDB为二进制压缩格式，结构固定，确保高效存储与校验：")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("+----------+----------+----------+----------+----------+\n| 魔数 | 版本号 | 数据部分 | 校验和 | 结束符 |\n+----------+----------+----------+----------+----------+\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br")])]),v("table",[v("thead",[v("tr",[v("th",[_._v("字段")]),_._v(" "),v("th",[_._v("作用")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("魔数")]),_._v(" "),v("td",[_._v('"REDIS"字符串，标识为Redis RDB文件')])]),_._v(" "),v("tr",[v("td",[_._v("版本号")]),_._v(" "),v("td",[_._v("无符号整数（如009表示Redis 9.0）")])]),_._v(" "),v("tr",[v("td",[_._v("数据部分")]),_._v(" "),v("td",[_._v("按数据库分块存储，包含键值对、过期时间等")])]),_._v(" "),v("tr",[v("td",[_._v("校验和")]),_._v(" "),v("td",[_._v("无符号整数，验证文件完整性")])]),_._v(" "),v("tr",[v("td",[_._v("结束符")]),_._v(" "),v("td",[_._v("固定值0xFF，标识文件结束")])])])]),_._v(" "),v("h3",{attrs:{id:"_4-rdb加载流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-rdb加载流程"}},[_._v("#")]),_._v(" 4. RDB加载流程")]),_._v(" "),v("p",[_._v("Redis启动时，若未开启AOF或AOF文件不存在，则加载RDB：")]),_._v(" "),v("ol",[v("li",[_._v("检查"),v("code",[_._v("dir")]),_._v("配置目录下是否存在"),v("code",[_._v("dump.rdb")]),_._v("；")]),_._v(" "),v("li",[_._v("验证魔数和校验和，确保文件未损坏；")]),_._v(" "),v("li",[_._v("按RDB结构解析数据并加载到内存；")]),_._v(" "),v("li",[_._v("加载完成后，启动事件循环处理客户端请求。")])]),_._v(" "),v("h3",{attrs:{id:"_5-rdb优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-rdb优缺点"}},[_._v("#")]),_._v(" 5. RDB优缺点")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("优点")]),_._v(" "),v("th",[_._v("缺点")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("加载速度快（二进制直接加载）")]),_._v(" "),v("td",[_._v("数据丢失风险高（快照间隔内数据丢失）")])]),_._v(" "),v("tr",[v("td",[_._v("磁盘占用小（压缩存储）")]),_._v(" "),v("td",[_._v("fork开销随数据量增大（页表复制可能阻塞主线程）")])]),_._v(" "),v("tr",[v("td",[_._v("性能影响低（异步执行）")]),_._v(" "),v("td",[_._v("不适合实时持久化（无法做到秒级零丢失）")])])])]),_._v(" "),v("h2",{attrs:{id:"aof-命令日志式持久化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aof-命令日志式持久化"}},[_._v("#")]),_._v(" AOF：命令日志式持久化")]),_._v(" "),v("p",[_._v("AOF（Append Only File）通过"),v("strong",[_._v("记录所有写命令")]),_._v("实现持久化，重启时重放命令恢复数据，数据完整性远高于RDB。")]),_._v(" "),v("h3",{attrs:{id:"_1-aof核心流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-aof核心流程"}},[_._v("#")]),_._v(" 1. AOF核心流程")]),_._v(" "),v("p",[_._v("AOF分为三个阶段，每个阶段可配置，平衡性能与安全性：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("命令追加")]),_._v("：Redis执行写命令后，将命令追加到内存AOF缓冲区（避免频繁写盘）；")]),_._v(" "),v("li",[v("strong",[_._v("文件写入")]),_._v("：调用"),v("code",[_._v("write()")]),_._v("系统调用，将缓冲区数据写入内核缓冲区（仍未刷盘）；")]),_._v(" "),v("li",[v("strong",[_._v("磁盘刷盘")]),_._v("：调用"),v("code",[_._v("fsync()")]),_._v("/"),v("code",[_._v("fdatasync()")]),_._v("将内核缓冲区数据刷到磁盘，刷盘时机由"),v("code",[_._v("appendfsync")]),_._v("配置决定。")])]),_._v(" "),v("h3",{attrs:{id:"_2-aof刷盘策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-aof刷盘策略"}},[_._v("#")]),_._v(" 2. AOF刷盘策略")]),_._v(" "),v("p",[v("code",[_._v("appendfsync")]),_._v("是AOF的核心配置，直接影响数据安全性与性能：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("配置值")]),_._v(" "),v("th",[_._v("刷盘时机")]),_._v(" "),v("th",[_._v("数据丢失风险")]),_._v(" "),v("th",[_._v("性能影响")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("always")]),_._v(" "),v("td",[_._v("每次命令追加后立即刷盘")]),_._v(" "),v("td",[_._v("无")]),_._v(" "),v("td",[_._v("高（IO密集）")])]),_._v(" "),v("tr",[v("td",[_._v("everysec")]),_._v(" "),v("td",[_._v("每秒异步刷盘（默认）")]),_._v(" "),v("td",[_._v("最多丢失1秒数据")]),_._v(" "),v("td",[_._v("中")])]),_._v(" "),v("tr",[v("td",[_._v("no")]),_._v(" "),v("td",[_._v("由操作系统决定（通常30秒）")]),_._v(" "),v("td",[_._v("高（可能丢失分钟级数据）")]),_._v(" "),v("td",[_._v("低")])])])]),_._v(" "),v("h3",{attrs:{id:"_3-aof重写-解决日志膨胀"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-aof重写-解决日志膨胀"}},[_._v("#")]),_._v(" 3. AOF重写：解决日志膨胀")]),_._v(" "),v("p",[_._v("AOF文件会随命令追加不断增大（如多次修改同一key会记录所有命令），导致加载慢、磁盘占用高。"),v("strong",[_._v("AOF重写")]),_._v("是Redis优化AOF文件的核心机制，通过遍历内存数据生成精简命令集（如10次"),v("code",[_._v("INCR key")]),_._v("替换为"),v("code",[_._v("SET key 10")]),_._v("），优化文件大小。")]),_._v(" "),v("h4",{attrs:{id:"触发条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#触发条件"}},[_._v("#")]),_._v(" 触发条件")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("手动触发")]),_._v("：执行"),v("code",[_._v("BGREWRITEAOF")]),_._v("（fork子进程执行，非阻塞）；")]),_._v(" "),v("li",[v("strong",[_._v("自动触发")]),_._v("：同时满足以下配置：")])]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("# redis.conf 配置\nauto-aof-rewrite-percentage 100  # AOF文件大小增长100%触发\nauto-aof-rewrite-min-size 64mb   # 文件至少64MB才触发（避免小文件频繁重写）\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br")])]),v("h4",{attrs:{id:"重写流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重写流程"}},[_._v("#")]),_._v(" 重写流程")]),_._v(" "),v("ol",[v("li",[_._v("子进程遍历内存数据，生成精简AOF命令写入新文件；")]),_._v(" "),v("li",[_._v("主线程继续处理请求，新写命令同时追加到"),v("strong",[_._v("旧AOF缓冲区")]),_._v("和"),v("strong",[_._v("AOF重写缓冲区")]),_._v("；")]),_._v(" "),v("li",[_._v("子进程完成后，主线程将重写缓冲区的增量命令追加到新文件；")]),_._v(" "),v("li",[_._v("替换旧AOF文件，完成重写。")])]),_._v(" "),v("h3",{attrs:{id:"_4-aof加载流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-aof加载流程"}},[_._v("#")]),_._v(" 4. AOF加载流程")]),_._v(" "),v("ol",[v("li",[_._v("检查"),v("code",[_._v("dir")]),_._v("目录下的"),v("code",[_._v("appendonly.aof")]),_._v("文件；")]),_._v(" "),v("li",[_._v("验证文件完整性（若损坏，Redis会尝试修复或提示手动修复）；")]),_._v(" "),v("li",[_._v("逐行解析并执行命令，恢复数据；")]),_._v(" "),v("li",[_._v("加载完成后启动事件循环。")])]),_._v(" "),v("h3",{attrs:{id:"_5-aof优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-aof优缺点"}},[_._v("#")]),_._v(" 5. AOF优缺点")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("优点")]),_._v(" "),v("th",[_._v("缺点")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("数据完整性高（可配置秒级/实时刷盘）")]),_._v(" "),v("td",[_._v("加载速度慢（需重放所有命令）")])]),_._v(" "),v("tr",[v("td",[_._v("易恢复（命令日志可读，可手动修改）")]),_._v(" "),v("td",[_._v("磁盘占用大（命令冗余）")])]),_._v(" "),v("tr",[v("td",[_._v("增量持久化（仅记录写命令）")]),_._v(" "),v("td",[_._v("高频刷盘降低吞吐量")])])])]),_._v(" "),v("h2",{attrs:{id:"混合持久化-rdb与aof的融合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化-rdb与aof的融合"}},[_._v("#")]),_._v(" 混合持久化：RDB与AOF的融合")]),_._v(" "),v("p",[_._v("为解决RDB数据丢失多、AOF加载慢的问题，Redis 4.0+引入"),v("strong",[_._v("混合持久化")]),_._v("，核心是AOF重写时，先写入RDB二进制数据，再追加AOF增量命令。")]),_._v(" "),v("h3",{attrs:{id:"_1-混合持久化结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-混合持久化结构"}},[_._v("#")]),_._v(" 1. 混合持久化结构")]),_._v(" "),v("p",[_._v("开启后，AOF文件结构为：")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("+----------+----------------+\n| RDB 头 | AOF 增量日志 |\n+----------+----------------+\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br")])]),v("p",[v("strong",[_._v("加载流程")]),_._v("：先快速加载RDB头（全量数据），再重放少量AOF增量日志（RDB之后的修改），兼顾RDB的加载速度和AOF的完整性。")]),_._v(" "),v("h3",{attrs:{id:"_2-开启方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-开启方式"}},[_._v("#")]),_._v(" 2. 开启方式")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("aof-use-rdb-preamble yes  # 默认为no，需手动开启\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("h2",{attrs:{id:"总结-如何选择持久化方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结-如何选择持久化方式"}},[_._v("#")]),_._v(" 总结：如何选择持久化方式？")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("场景")]),_._v(" "),v("th",[_._v("推荐方案")]),_._v(" "),v("th",[_._v("核心原因")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("数据可靠性要求高（如金融）")]),_._v(" "),v("td",[_._v("AOF（appendfsync everysec）")]),_._v(" "),v("td",[_._v("最多丢失1秒数据，满足高可用")])]),_._v(" "),v("tr",[v("td",[_._v("性能优先（如缓存场景）")]),_._v(" "),v("td",[_._v("RDB")]),_._v(" "),v("td",[_._v("低IO开销，加载速度快")])]),_._v(" "),v("tr",[v("td",[_._v("平衡可靠性与性能")]),_._v(" "),v("td",[_._v("混合持久化")]),_._v(" "),v("td",[_._v("兼具RDB的加载速度和AOF的完整性")])])])]),_._v(" "),v("p",[_._v("实际生产中，建议结合业务对数据安全性和性能的需求，灵活配置持久化策略，并定期备份持久化文件以应对极端故障。")])])}),[],!1,null,null,null);v.default=s.exports}}]);