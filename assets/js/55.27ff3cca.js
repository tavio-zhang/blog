(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{412:function(s,a,t){"use strict";t.r(a);var e=t(8),r=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"深度解析mysql索引底层-b-树设计精髓与索引失效本质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深度解析mysql索引底层-b-树设计精髓与索引失效本质"}},[s._v("#")]),s._v(" 深度解析MySQL索引底层：B+树设计精髓与索引失效本质")]),s._v(" "),a("p",[s._v("在MySQL数据库的性能优化中，索引无疑是最核心的手段之一。一句合适的索引设计，能让慢查询从“秒级”提升到“毫秒级”；反之，即便建了索引，也可能因“索引失效”导致全表扫描，性能断崖式下降。而这一切的根源，都要回归到索引的底层数据结构——B+树，以及MySQL优化器的执行逻辑。")]),s._v(" "),a("h2",{attrs:{id:"一、索引的核心价值-为何需要索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、索引的核心价值-为何需要索引"}},[s._v("#")]),s._v(" 一、索引的核心价值：为何需要索引？")]),s._v(" "),a("p",[s._v("在没有索引的情况下，MySQL查询数据时只能进行“全表扫描”——即从表的第一条记录开始，逐行匹配查询条件，直到找到目标数据。这种方式在数据量小时（如几千条）尚可接受，但当数据量达到百万、千万级时，全表扫描的时间成本会呈线性增长（O(n)复杂度），完全无法满足业务需求。")]),s._v(" "),a("p",[s._v("索引的核心作用，就是将“全表扫描”的线性查找，转化为“有序结构查找”的对数级查找（O(log n)复杂度），本质是通过预先生成的“有序数据结构”，快速定位数据在磁盘上的物理存储位置，减少磁盘I/O操作（数据库性能瓶颈的核心是磁盘I/O）。")]),s._v(" "),a("p",[s._v("举个通俗的例子：全表扫描如同在一本没有目录的字典里找“苹果”，需要逐页翻阅；而索引就像字典的目录，通过目录能直接定位到“苹果”所在的页码，大幅提升查找效率。")]),s._v(" "),a("h2",{attrs:{id:"二、b-树-mysql索引的底层数据结构基石"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、b-树-mysql索引的底层数据结构基石"}},[s._v("#")]),s._v(" 二、B+树：MySQL索引的底层数据结构基石")]),s._v(" "),a("p",[s._v("MySQL的索引底层默认使用B+树（B-tree的改进版），而非数组、链表、哈希表等结构。这并非偶然，而是B+树的设计完美适配了MySQL的磁盘存储特性（数据以“页”为单位存储，默认16KB，磁盘I/O按页进行）。要理解B+树的优势，我们先从B树的不足入手，再看B+树的优化设计。")]),s._v(" "),a("h3",{attrs:{id:"_2-1-先懂b树-b-树的-前身-与不足"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-先懂b树-b-树的-前身-与不足"}},[s._v("#")]),s._v(" 2.1 先懂B树：B+树的“前身”与不足")]),s._v(" "),a("p",[s._v("B树（平衡多路搜索树）的核心结构特点：")]),s._v(" "),a("ul",[a("li",[s._v("每个节点可以存储多个关键字（索引值）和对应的指针（指向子节点的磁盘地址）；")]),s._v(" "),a("li",[s._v("关键字按升序排列，子节点指针穿插在关键字之间，确保左子树的关键字均小于当前关键字，右子树的关键字均大于当前关键字；")]),s._v(" "),a("li",[s._v("所有叶子节点在同一层，保证查询效率稳定（平衡树特性）。")])]),s._v(" "),a("p",[s._v("但B树存在两个致命缺陷，无法适配MySQL的高频查询场景：")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("查询效率不稳定")]),s._v("：非叶子节点和叶子节点都存储数据，若查询的目标数据在非叶子节点，能快速命中；若在叶子节点，则需要遍历到最底层，查询次数差异较大；")]),s._v(" "),a("li",[a("strong",[s._v("范围查询低效")]),s._v("：进行范围查询（如id>100 and id<200）时，需要遍历多个分支节点，找到起始值后，再回溯其他分支，操作复杂；")]),s._v(" "),a("li",[a("strong",[s._v("磁盘I/O次数多")]),s._v("：非叶子节点存储数据占用空间，导致每个节点能存储的关键字数量减少，树的高度增加（比如百万级数据可能需要4-5层），而每一层的访问都需要一次磁盘I/O，I/O次数越多，查询越慢。")])]),s._v(" "),a("h3",{attrs:{id:"_2-2-b-树的核心设计-针对性优化与优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-b-树的核心设计-针对性优化与优势"}},[s._v("#")]),s._v(" 2.2 B+树的核心设计：针对性优化与优势")]),s._v(" "),a("p",[s._v("B+树在B树的基础上进行了三点关键优化，完美解决了B树的不足，成为MySQL索引的最优选择。其核心结构如下：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("非叶子节点仅存索引，不存数据")]),s._v("：非叶子节点只存储“关键字（索引值）+ 子节点指针”，不存储具体的数据行。这样每个非叶子节点能容纳更多的关键字，树的高度大幅降低（百万级数据通常只需2-3层），减少磁盘I/O次数；")]),s._v(" "),a("li",[a("strong",[s._v("所有数据集中在叶子节点")]),s._v("：所有关键字对应的具体数据（或数据的磁盘地址）都存储在叶子节点，且叶子节点按关键字升序排列，保证查询效率稳定（无论查询哪个数据，都需要遍历到叶子节点，查询次数固定）；")]),s._v(" "),a("li",[a("strong",[s._v("叶子节点通过双向链表连接")]),s._v("：所有叶子节点之间形成一个双向链表，相邻叶子节点可以快速访问。这使得范围查询时，只需找到起始叶子节点，然后通过链表遍历后续节点即可，效率极高。")])]),s._v(" "),a("p",[s._v("补充：MySQL中B+树的“节点”对应磁盘上的“数据页”（16KB），非叶子节点的每个关键字+指针约占16字节（8字节关键字+8字节指针），因此一个非叶子节点可存储约16KB/16B=1024个关键字，对应1025个指针（子节点）。若树高为3，则总数据量可达1024"),a("em",[s._v("1024")]),s._v("N（N为每个叶子节点存储的数据行数），足以支撑千万级数据的高效查询。")]),s._v(" "),a("h3",{attrs:{id:"_2-3-b-树的查询流程-以聚簇索引为例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-b-树的查询流程-以聚簇索引为例"}},[s._v("#")]),s._v(" 2.3 B+树的查询流程（以聚簇索引为例）")]),s._v(" "),a("p",[s._v("假设我们有一个user表，主键id为聚簇索引，B+树高度为3，查询"),a("code",[s._v("SELECT * FROM user WHERE id=10086")]),s._v("的流程如下：")]),s._v(" "),a("ol",[a("li",[s._v("MySQL先访问B+树的根节点（磁盘I/O 1次），根节点存储关键字范围，通过二分查找确定id=10086对应的子节点指针；")]),s._v(" "),a("li",[s._v("根据子节点指针访问第二层节点（磁盘I/O 2次），再次通过二分查找确定目标叶子节点的指针；")]),s._v(" "),a("li",[s._v("访问叶子节点（磁盘I/O 3次），在叶子节点中找到id=10086对应的data域（存储完整数据行），返回结果。")])]),s._v(" "),a("p",[s._v("整个过程仅需3次磁盘I/O，而全表扫描可能需要上百次甚至上千次，效率差距悬殊。")]),s._v(" "),a("h2",{attrs:{id:"三、mysql索引的核心类型-聚簇索引与二级索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、mysql索引的核心类型-聚簇索引与二级索引"}},[s._v("#")]),s._v(" 三、MySQL索引的核心类型：聚簇索引与二级索引")]),s._v(" "),a("p",[s._v("基于B+树，MySQL将索引分为两大类——聚簇索引（Clustered Index）和二级索引（Secondary Index，也叫辅助索引），两者的核心区别在于叶子节点存储的内容不同，这也是理解后续索引失效的关键。")]),s._v(" "),a("h3",{attrs:{id:"_3-1-聚簇索引-索引即数据-数据即索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-聚簇索引-索引即数据-数据即索引"}},[s._v("#")]),s._v(" 3.1 聚簇索引：索引即数据，数据即索引")]),s._v(" "),a("p",[s._v("聚簇索引是MySQL的核心索引，其叶子节点直接存储“完整的数据行”，而非数据的地址。MySQL中，"),a("strong",[s._v("主键索引默认是聚簇索引")]),s._v("；若表没有主键，则会选择唯一非空索引作为聚簇索引；若既没有主键也没有唯一非空索引，MySQL会自动生成一个隐藏的聚簇索引（基于行号的自增ID）。")]),s._v(" "),a("p",[s._v("聚簇索引的优势：")]),s._v(" "),a("ul",[a("li",[s._v("查询效率最高：通过聚簇索引查询时，找到叶子节点即可获取完整数据，无需额外操作；")]),s._v(" "),a("li",[s._v("范围查询高效：借助叶子节点的双向链表，范围查询（如id between 100 and 200）能快速遍历所有符合条件的数据行。")])]),s._v(" "),a("p",[s._v("聚簇索引的不足：")]),s._v(" "),a("ul",[a("li",[s._v("插入效率受影响：聚簇索引是有序的，插入新数据时需要找到对应的位置，若该位置的数据页已满，会触发“页分裂”（拆分数据页并重新排序），增加开销；")]),s._v(" "),a("li",[s._v("不适合频繁更新的主键：主键更新会导致数据行在磁盘上的物理位置移动，同时所有二级索引都会失效（后续会讲），需要重新构建。")])]),s._v(" "),a("h3",{attrs:{id:"_3-2-二级索引-叶子节点存储主键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-二级索引-叶子节点存储主键"}},[s._v("#")]),s._v(" 3.2 二级索引：叶子节点存储主键")]),s._v(" "),a("p",[s._v("二级索引是用户手动创建的索引（如"),a("code",[s._v("CREATE INDEX idx_name ON user(name)")]),s._v("），其叶子节点不存储完整数据行，而是存储“索引列的值 + 聚簇索引的关键字（即主键）”。")]),s._v(" "),a("p",[s._v("二级索引的查询流程（回表机制）：\n以查询"),a("code",[s._v("SELECT * FROM user WHERE name='张三'")]),s._v("（name列有二级索引）为例：")]),s._v(" "),a("ol",[a("li",[s._v("先通过二级索引（idx_name）的B+树查找，找到name='张三'对应的主键值（如id=10086）——这一步叫“索引查找”；")]),s._v(" "),a("li",[s._v("再通过聚簇索引（主键索引）的B+树查找id=10086，在叶子节点获取完整的数据行——这一步叫“回表”。")])]),s._v(" "),a("p",[s._v("补充：若查询的列都在二级索引中（如"),a("code",[s._v("SELECT id, name FROM user WHERE name='张三'")]),s._v("），则无需回表，直接从二级索引的叶子节点获取数据即可，这就是“覆盖索引”（Covering Index），是优化查询的重要手段。")]),s._v(" "),a("h3",{attrs:{id:"_3-3-联合索引-有序的多列索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-联合索引-有序的多列索引"}},[s._v("#")]),s._v(" 3.3 联合索引：有序的多列索引")]),s._v(" "),a("p",[s._v("联合索引是多个列组合而成的二级索引（如"),a("code",[s._v("CREATE INDEX idx_age_name ON user(age, name)")]),s._v("），其B+树的关键字按“第一列→第二列→...→第N列”的顺序排序。联合索引的核心遵循“最左匹配原则”——即查询时必须从第一列开始匹配，否则无法利用索引。")]),s._v(" "),a("p",[s._v("例如，联合索引（age, name）的有效查询场景：")]),s._v(" "),a("ul",[a("li",[s._v("age=25（匹配第一列，有效）；")]),s._v(" "),a("li",[s._v("age=25 and name='张三'（匹配第一列+第二列，有效）；")]),s._v(" "),a("li",[s._v("age between 20 and 30 and name='张三'（范围匹配第一列，再匹配第二列，有效）。")])]),s._v(" "),a("p",[s._v("无效场景：")]),s._v(" "),a("ul",[a("li",[s._v("name='张三'（未匹配第一列，无效）；")]),s._v(" "),a("li",[s._v("age>25 and name='张三'（范围匹配第一列后，第二列的索引失效，仅第一列有效）。")])]),s._v(" "),a("h2",{attrs:{id:"四、索引失效的本质-为何索引-失效"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、索引失效的本质-为何索引-失效"}},[s._v("#")]),s._v(" 四、索引失效的本质：为何索引“失效”？")]),s._v(" "),a("p",[s._v("很多开发者会遇到“建了索引但查询还是慢”的问题，这本质是“索引失效”——即MySQL的查询优化器判断“走索引的成本高于全表扫描”，因此放弃使用索引，转而进行全表扫描。")]),s._v(" "),a("p",[s._v("核心结论："),a("strong",[s._v("索引失效的本质，是查询语句的执行计划无法利用B+树的有序性，或优化器认为走索引的效率低于全表扫描")]),s._v("。具体来说，有两个核心原因：")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("破坏B+树的有序性")]),s._v("：B+树的查询依赖于关键字的有序性，若查询条件对索引列进行了“无序化操作”（如函数、运算、类型转换），则优化器无法通过B+树的有序结构快速定位数据，只能放弃索引；")]),s._v(" "),a("li",[a("strong",[s._v("走索引的成本过高")]),s._v("：即使查询条件适配索引，但如果符合条件的数据量过大（如占全表数据的30%以上），优化器会认为“走索引需要多次回表（二级索引）+ 磁盘I/O”，成本高于全表扫描，因此选择放弃索引。")])]),s._v(" "),a("p",[s._v("补充：MySQL的查询优化器是基于“统计信息”（如索引的选择性、数据分布）来判断是否走索引的，若统计信息过时（如数据大量插入/删除后未更新统计信息），也可能导致优化器做出错误判断，出现索引失效。")]),s._v(" "),a("h2",{attrs:{id:"五、常见索引失效场景与案例分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、常见索引失效场景与案例分析"}},[s._v("#")]),s._v(" 五、常见索引失效场景与案例分析")]),s._v(" "),a("p",[s._v("结合上述本质原因，我们梳理出8种最常见的索引失效场景，每个场景都给出具体案例、失效原因和优化方案，让大家能直接落地避坑。")]),s._v(" "),a("h3",{attrs:{id:"场景1-索引列上使用函数或运算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景1-索引列上使用函数或运算"}},[s._v("#")]),s._v(" 场景1：索引列上使用函数或运算")]),s._v(" "),a("p",[s._v("案例：user表有二级索引idx_create_time（create_time），查询“2024年1月1日之后创建的用户”：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("-- 失效SQL\nSELECT * FROM user WHERE DATE(create_time) > '2024-01-01';\n\n-- 有效SQL\nSELECT * FROM user WHERE create_time > STR_TO_DATE('2024-01-01', '%Y-%m-%d');\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("失效原因：在索引列create_time上使用了DATE()函数，破坏了B+树的有序性（索引列的原始值是有序的，但函数处理后的值无法保证有序），优化器无法通过索引快速定位数据，只能全表扫描。")]),s._v(" "),a("p",[s._v("优化思路：将函数操作从索引列上移到查询条件的右侧，让索引列保持原始的有序性，确保优化器能利用索引。")]),s._v(" "),a("h3",{attrs:{id:"场景2-模糊查询以-开头"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景2-模糊查询以-开头"}},[s._v("#")]),s._v(" 场景2：模糊查询以“%”开头")]),s._v(" "),a("p",[s._v("案例：user表有二级索引idx_name（name），查询“名字以‘三’结尾的用户”：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 失效SQL")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("LIKE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'%三'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 有效SQL（以%结尾，有效）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("LIKE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'张%'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 有效SQL（覆盖索引，即使以%开头也有效）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("LIKE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'%三'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("失效原因：模糊查询以“%”开头时，查询条件是“后缀匹配”，而B+树的索引是按前缀有序排列的，无法通过前缀快速定位后缀匹配的数据，因此索引失效。若以“%”结尾（前缀匹配），则能利用索引的有序性；若查询的列是覆盖索引（仅id和name），则无需回表，优化器会选择走索引（扫描所有叶子节点，但比全表扫描快）。")]),s._v(" "),a("p",[s._v("优化思路：避免以“%”开头的模糊查询；若必须使用，可考虑使用覆盖索引，或通过全文索引（FULLTEXT INDEX）替代（适用于字符串长度较长的场景）。")]),s._v(" "),a("h3",{attrs:{id:"场景3-联合索引不满足最左匹配原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景3-联合索引不满足最左匹配原则"}},[s._v("#")]),s._v(" 场景3：联合索引不满足最左匹配原则")]),s._v(" "),a("p",[s._v("案例：user表有联合索引idx_age_name（age, name），查询“名字为张三的用户”：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 失效SQL")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" name"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'张三'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 有效SQL（匹配最左列age）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 有效SQL（匹配最左列+第二列）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("AND")]),s._v(" name"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'张三'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 有效SQL（最左列范围匹配，第二列仍有效）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("AND")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("30")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("AND")]),s._v(" name"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'张三'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 失效SQL（最左列范围匹配后，第二列失效）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("AND")]),s._v(" name"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'张三'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("失效原因：联合索引的B+树是按“age→name”的顺序排序的，查询时必须从最左列（age）开始匹配，否则无法利用索引的有序性。若最左列使用范围查询（>、<、between），则范围后的列无法利用索引（因为范围查询后的结果是无序的，第二列的索引失去意义）。")]),s._v(" "),a("p",[s._v("优化思路：创建联合索引时，将查询频率最高的列放在最左；查询时确保从最左列开始匹配；若需要单独查询name，可单独创建idx_name索引（权衡索引数量与查询效率）。")]),s._v(" "),a("h3",{attrs:{id:"场景4-使用or连接非索引列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景4-使用or连接非索引列"}},[s._v("#")]),s._v(" 场景4：使用OR连接非索引列")]),s._v(" "),a("p",[s._v("案例：user表有索引idx_age（age），无idx_address（address），查询“年龄25或地址为北京的用户”：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 失效SQL")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("OR")]),s._v(" address"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'北京'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 有效SQL（两个列都有索引）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("OR")]),s._v(" address"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'北京'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 前提：address有索引")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 有效SQL（拆分为UNION）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UNION")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" address"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'北京'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("失效原因：OR连接的两个条件中，若有一个列没有索引，优化器无法通过索引快速定位所有符合条件的数据（需要同时扫描索引和全表），因此会选择全表扫描。若两个列都有索引，优化器会分别扫描两个索引，再合并结果；若拆分为UNION，可分别利用索引和全表扫描，效率可能更高。")]),s._v(" "),a("p",[s._v("优化思路：避免用OR连接非索引列；若必须使用，可给非索引列添加索引，或拆分为UNION查询。")]),s._v(" "),a("h3",{attrs:{id:"场景5-索引列与查询条件的数据类型不匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景5-索引列与查询条件的数据类型不匹配"}},[s._v("#")]),s._v(" 场景5：索引列与查询条件的数据类型不匹配")]),s._v(" "),a("p",[s._v("案例：user表有索引idx_phone（phone，varchar类型），查询“手机号为13800138000的用户”：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 失效SQL（查询条件是数字，索引列是字符串）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" phone"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("13800138000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 有效SQL（查询条件是字符串，与索引列类型一致）")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" phone"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'13800138000'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("失效原因：查询条件的数据类型（数字）与索引列类型（字符串）不匹配时，MySQL会自动进行类型转换（将字符串转为数字），这相当于在索引列上进行了函数操作，破坏了B+树的有序性，导致索引失效。")]),s._v(" "),a("p",[s._v("优化思路：确保查询条件的数据类型与索引列类型完全一致，避免自动类型转换。")]),s._v(" "),a("h3",{attrs:{id:"场景6-查询条件是is-null-is-not-null-视数据分布而定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景6-查询条件是is-null-is-not-null-视数据分布而定"}},[s._v("#")]),s._v(" 场景6：查询条件是IS NULL/IS NOT NULL（视数据分布而定）")]),s._v(" "),a("p",[s._v("案例：user表有索引idx_email（email），查询“邮箱为空/不为空的用户”：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 可能失效SQL")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" email "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("IS")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 可能失效SQL")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" email "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("IS")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("NOT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("失效原因：B+树的索引会存储NULL值（NULL按最小排序），理论上IS NULL/IS NOT NULL可以走索引，但实际是否失效取决于数据分布：若NULL值占比极低（如1%），优化器会走索引；若NULL值占比极高（如50%以上），走索引需要扫描大量叶子节点，成本高于全表扫描，优化器会选择全表扫描。")]),s._v(" "),a("p",[s._v("优化思路：尽量避免查询大量NULL值的数据；若必须查询，可通过统计信息判断是否走索引，或强制使用索引（"),a("code",[s._v("FORCE INDEX")]),s._v("，但不推荐，可能适得其反）。")]),s._v(" "),a("h3",{attrs:{id:"场景7-数据量过小-优化器选择全表扫描"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景7-数据量过小-优化器选择全表扫描"}},[s._v("#")]),s._v(" 场景7：数据量过小，优化器选择全表扫描")]),s._v(" "),a("p",[s._v("案例：user表有索引idx_age（age），但表中仅100条数据，查询“年龄25的用户”：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 可能失效SQL")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("失效原因：当表中数据量过小时，全表扫描的成本（遍历100条数据）可能低于走索引的成本（3次磁盘I/O+回表），因此优化器会主动放弃索引，选择全表扫描。这是优化器的“智能判断”，并非索引本身的问题。")]),s._v(" "),a("p",[s._v("优化思路：无需优化，数据量小时全表扫描效率更高；若需要测试索引是否有效，可通过"),a("code",[s._v("EXPLAIN")]),s._v("查看执行计划，或强制使用索引（"),a("code",[s._v("FORCE INDEX(idx_age)")]),s._v("）。")]),s._v(" "),a("h3",{attrs:{id:"场景8-统计信息过时-优化器判断失误"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景8-统计信息过时-优化器判断失误"}},[s._v("#")]),s._v(" 场景8：统计信息过时，优化器判断失误")]),s._v(" "),a("p",[s._v("案例：user表有索引idx_age（age），近期批量插入了100万条数据（age=25的占比从1%变为50%），查询“年龄25的用户”：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 可能失效SQL")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("失效原因：MySQL的优化器依赖“统计信息”（如索引的选择性、数据分布）来判断是否走索引。若数据大量插入/删除后，统计信息未及时更新，优化器会基于旧的统计信息（如age=25占比1%）判断走索引有效，但实际数据占比50%，走索引的成本高于全表扫描，导致索引失效。")]),s._v(" "),a("p",[s._v("优化思路：手动更新统计信息（"),a("code",[s._v("ANALYZE TABLE user;")]),s._v("），让优化器获取最新的数据分析结果；MySQL 8.0默认会自动更新统计信息，可通过"),a("code",[s._v("SHOW VARIABLES LIKE 'innodb_stats_auto_recalc';")]),s._v("查看配置。")]),s._v(" "),a("h2",{attrs:{id:"六、索引优化实战建议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、索引优化实战建议"}},[s._v("#")]),s._v(" 六、索引优化实战建议")]),s._v(" "),a("p",[s._v("结合前面的底层原理和失效场景，给出6条可直接落地的索引优化建议，帮助大家避坑并提升查询效率：")]),s._v(" "),a("h3",{attrs:{id:"_1-优先使用聚簇索引-主键索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-优先使用聚簇索引-主键索引"}},[s._v("#")]),s._v(" 1. 优先使用聚簇索引（主键索引）")]),s._v(" "),a("p",[s._v("聚簇索引的查询效率最高，尽量基于主键进行查询；设计主键时，选择自增ID（INT/BIGINT），避免使用字符串或频繁更新的字段（减少页分裂和二级索引失效的成本）。")]),s._v(" "),a("h3",{attrs:{id:"_2-合理设计联合索引-遵循-最左匹配-高频列在前"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-合理设计联合索引-遵循-最左匹配-高频列在前"}},[s._v("#")]),s._v(" 2. 合理设计联合索引：遵循“最左匹配+高频列在前”")]),s._v(" "),a("p",[s._v("创建联合索引时，将查询频率最高的列放在最左；避免创建冗余的联合索引（如已有(idx_age, name)，则无需再创建(idx_age)）；联合索引的列数不宜过多（一般3-4列即可，列数过多会增加索引维护成本）。")]),s._v(" "),a("h3",{attrs:{id:"_3-利用覆盖索引-避免回表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-利用覆盖索引-避免回表"}},[s._v("#")]),s._v(" 3. 利用覆盖索引，避免回表")]),s._v(" "),a("p",[s._v("查询时，尽量只查询需要的列，若查询的列都在索引中（覆盖索引），则无需回表，大幅提升效率。例如，查询"),a("code",[s._v("SELECT id, name FROM user WHERE name='张三'")]),s._v("（idx_name是二级索引，包含id和name），无需回表。")]),s._v(" "),a("h3",{attrs:{id:"_4-避免索引列上的函数-运算-类型转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-避免索引列上的函数-运算-类型转换"}},[s._v("#")]),s._v(" 4. 避免索引列上的函数/运算/类型转换")]),s._v(" "),a("p",[s._v("确保查询条件中的索引列是原始值，不进行任何函数操作（如DATE()、UPPER()）、运算（如age+1=26）或类型转换（字符串 vs 数字），避免破坏B+树的有序性。")]),s._v(" "),a("h3",{attrs:{id:"_5-控制索引数量-平衡查询与写入效率"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-控制索引数量-平衡查询与写入效率"}},[s._v("#")]),s._v(" 5. 控制索引数量，平衡查询与写入效率")]),s._v(" "),a("p",[s._v("索引能提升查询效率，但会降低插入/更新/删除的效率（每次写入都需要维护索引的B+树）。一般来说，一张表的索引数量不宜超过5个，优先保留高频查询的索引。")]),s._v(" "),a("h3",{attrs:{id:"_6-定期维护索引与统计信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-定期维护索引与统计信息"}},[s._v("#")]),s._v(" 6. 定期维护索引与统计信息")]),s._v(" "),a("p",[s._v("定期查看慢查询日志（slow_query_log），找出索引失效的查询并优化；定期更新统计信息（ANALYZE TABLE）；对于长期未使用的索引（通过"),a("code",[s._v("sys.schema_unused_indexes")]),s._v("查看），及时删除，减少维护成本。")]),s._v(" "),a("h2",{attrs:{id:"七、总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、总结"}},[s._v("#")]),s._v(" 七、总结")]),s._v(" "),a("p",[s._v("MySQL索引的底层是B+树，其设计精髓在于“非叶子节点存索引、叶子节点存数据+双向链表”，完美适配磁盘I/O特性，实现高效的单点查询和范围查询。索引失效的本质是“查询语句破坏了B+树的有序性，或优化器判断走索引成本高于全表扫描”。")]),s._v(" "),a("p",[s._v("要想用好索引，需记住三点核心：一是理解聚簇索引与二级索引的区别，二是避开常见的索引失效场景，三是结合业务场景合理设计索引（如联合索引的最左匹配、覆盖索引的利用）。只有从底层原理出发，才能真正掌握索引优化的精髓，而不是死记硬背失效场景。")])])}),[],!1,null,null,null);a.default=r.exports}}]);