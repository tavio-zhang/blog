(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{445:function(e,t,a){"use strict";a.r(t);var r=a(8),_=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("在Java并发编程中，线程是稀缺且昂贵的系统资源。直接创建和销毁线程会带来三个核心问题：")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("资源消耗大")]),e._v("：线程的创建/销毁涉及操作系统内核态与用户态的切换，频繁操作会占用大量CPU时间片，导致系统吞吐量下降。")]),e._v(" "),t("li",[t("strong",[e._v("稳定性风险")]),e._v("：无限制创建线程会耗尽内存资源（每个线程默认栈大小1MB），最终触发"),t("code",[e._v("OutOfMemoryError")]),e._v("。")]),e._v(" "),t("li",[t("strong",[e._v("管理成本高")]),e._v("：无法统一控制线程的生命周期、任务队列长度及并发数上限，易导致系统失控。")])]),e._v(" "),t("p",[e._v("线程池的核心价值在于"),t("strong",[e._v("线程复用")]),e._v("与"),t("strong",[e._v("统一管理")]),e._v('：它像一个"线程工厂"，提前创建并维护一批线程，任务提交时直接分配线程执行，避免重复创建销毁的开销，同时通过参数约束系统资源占用。')]),e._v(" "),t("h2",{attrs:{id:"一、threadpoolexecutor-线程池的核心实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、threadpoolexecutor-线程池的核心实现"}},[e._v("#")]),e._v(" 一、ThreadPoolExecutor：线程池的核心实现")]),e._v(" "),t("p",[t("code",[e._v("ThreadPoolExecutor")]),e._v("是Java线程池的核心实现类，其行为由七大核心参数共同决定。理解这些参数是掌握线程池的基础。")]),e._v(" "),t("h3",{attrs:{id:"_1-1-核心参数详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-核心参数详解"}},[e._v("#")]),e._v(" 1.1 核心参数详解")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public ThreadPoolExecutor(\n    int corePoolSize,                      // 核心线程数\n    int maximumPoolSize,                   // 最大线程数\n    long keepAliveTime,                    // 非核心线程空闲存活时间\n    TimeUnit unit,                         // 时间单位\n    BlockingQueue<Runnable> workQueue,     // 工作队列\n    ThreadFactory threadFactory,           // 线程工厂\n    RejectedExecutionHandler handler       // 拒绝策略\n)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br")])]),t("h4",{attrs:{id:"_1-核心线程数-corepoolsize"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-核心线程数-corepoolsize"}},[e._v("#")]),e._v(" （1）核心线程数（corePoolSize）")]),e._v(" "),t("ul",[t("li",[e._v('线程池的"常驻线程"数量，即使空闲也不会被销毁（除非通过'),t("code",[e._v("allowCoreThreadTimeOut(true)")]),e._v("开启核心线程超时销毁）。")]),e._v(" "),t("li",[e._v("任务提交时的处理逻辑：\n"),t("ul",[t("li",[e._v("若当前线程数 < corePoolSize：直接创建新线程（核心线程）执行任务。")]),e._v(" "),t("li",[e._v("若当前线程数 ≥ corePoolSize：任务进入工作队列等待。")])])])]),e._v(" "),t("h4",{attrs:{id:"_2-最大线程数-maximumpoolsize"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-最大线程数-maximumpoolsize"}},[e._v("#")]),e._v(" （2）最大线程数（maximumPoolSize）")]),e._v(" "),t("ul",[t("li",[e._v("线程池允许创建的最大线程总数（核心线程 + 非核心线程）。")]),e._v(" "),t("li",[e._v("约束逻辑：当核心线程满、工作队列也满时，线程池会创建非核心线程执行任务，直到线程数达到"),t("code",[e._v("maximumPoolSize")]),e._v("。")]),e._v(" "),t("li",[e._v("注意："),t("code",[e._v("corePoolSize ≤ maximumPoolSize")]),e._v('。若两者相等，则线程池为"固定大小"（无临时线程）。')])]),e._v(" "),t("h4",{attrs:{id:"_3-空闲存活时间-keepalivetime-unit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-空闲存活时间-keepalivetime-unit"}},[e._v("#")]),e._v(" （3）空闲存活时间（keepAliveTime + unit）")]),e._v(" "),t("ul",[t("li",[e._v("非核心线程空闲超过该时间后，会被销毁以释放资源。")]),e._v(" "),t("li",[e._v("特殊配置：通过"),t("code",[e._v("allowCoreThreadTimeOut(true)")]),e._v("可让核心线程也遵守该规则（适用于资源紧张场景，如临时任务高峰后释放资源）。")])]),e._v(" "),t("h4",{attrs:{id:"_4-工作队列-workqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-工作队列-workqueue"}},[e._v("#")]),e._v(" （4）工作队列（workQueue）")]),e._v(" "),t("ul",[t("li",[e._v("核心线程满后，新任务会先进入队列等待，而非直接创建非核心线程。")]),e._v(" "),t("li",[e._v("常用队列类型及适用场景：")])]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("队列类型")]),e._v(" "),t("th",[e._v("特点")]),e._v(" "),t("th",[e._v("适用场景")]),e._v(" "),t("th",[e._v("风险提示")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("ArrayBlockingQueue")]),e._v(" "),t("td",[e._v("有界队列，需指定初始容量")]),e._v(" "),t("td",[e._v("生产环境首选，可控制任务堆积上限")]),e._v(" "),t("td",[e._v("容量需合理设置（过小易触发拒绝）")])]),e._v(" "),t("tr",[t("td",[e._v("LinkedBlockingQueue")]),e._v(" "),t("td",[e._v("无界队列（默认容量Integer.MAX_VALUE）")]),e._v(" "),t("td",[e._v("不推荐！任务堆积易导致OOM")]),e._v(" "),t("td",[e._v("高并发下风险极高")])]),e._v(" "),t("tr",[t("td",[e._v("SynchronousQueue")]),e._v(" "),t("td",[e._v("同步队列，不存储任务（直接传递）")]),e._v(" "),t("td",[e._v("任务需快速处理，不允许排队的场景")]),e._v(" "),t("td",[e._v("依赖最大线程数控制并发")])]),e._v(" "),t("tr",[t("td",[e._v("PriorityBlockingQueue")]),e._v(" "),t("td",[e._v("优先级队列，按任务优先级排序")]),e._v(" "),t("td",[e._v("任务有明确优先级区分的场景（如紧急任务）")]),e._v(" "),t("td",[e._v("需自定义任务的"),t("code",[e._v("compareTo")]),e._v("方法")])])])]),e._v(" "),t("h4",{attrs:{id:"_5-线程工厂-threadfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-线程工厂-threadfactory"}},[e._v("#")]),e._v(" （5）线程工厂（ThreadFactory）")]),e._v(" "),t("ul",[t("li",[e._v("用于创建线程，可自定义线程名称、优先级、是否为守护线程等属性。")]),e._v(" "),t("li",[e._v("默认工厂："),t("code",[e._v("Executors.defaultThreadFactory()")]),e._v("，创建的线程为非守护线程，名称格式为"),t("code",[e._v("pool-{poolNum}-thread-{threadNum}")]),e._v("。")]),e._v(" "),t("li",[e._v("自定义示例（便于问题排查）：")])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('  ThreadFactory customThreadFactory = new ThreadFactory() {\n      private final AtomicInteger threadNum = new AtomicInteger(1);\n      @Override\n      public Thread newThread(Runnable r) {\n          Thread thread = new Thread(r, "order-pool-thread-" + threadNum.getAndIncrement());\n          thread.setDaemon(false); // 非守护线程（避免主线程退出后被强制终止）\n          thread.setPriority(Thread.NORM_PRIORITY); // 正常优先级\n          return thread;\n      }\n  };\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br")])]),t("h4",{attrs:{id:"_6-拒绝策略-rejectedexecutionhandler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-拒绝策略-rejectedexecutionhandler"}},[e._v("#")]),e._v(" （6）拒绝策略（RejectedExecutionHandler）")]),e._v(" "),t("ul",[t("li",[e._v("当线程池达到"),t("code",[e._v("maximumPoolSize")]),e._v("且工作队列已满时，新提交的任务会触发拒绝策略（线程池的最后一道防线）。")])]),e._v(" "),t("h3",{attrs:{id:"_1-2-线程池核心工作流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-线程池核心工作流程"}},[e._v("#")]),e._v(" 1.2 线程池核心工作流程")]),e._v(" "),t("p",[e._v("任务处理遵循"),t("strong",[e._v("核心线程 → 工作队列 → 非核心线程 → 拒绝策略")]),e._v("的顺序，步骤如下：")]),e._v(" "),t("ol",[t("li",[e._v("提交任务时，若当前线程数 < corePoolSize：创建核心线程执行任务。")]),e._v(" "),t("li",[e._v("若核心线程满（≥ corePoolSize）：任务进入工作队列等待。")]),e._v(" "),t("li",[e._v("若队列满且当前线程数 < maximumPoolSize：创建非核心线程执行任务。")]),e._v(" "),t("li",[e._v("若队列满且线程数 ≥ maximumPoolSize：执行拒绝策略。")])]),e._v(" "),t("p",[t("strong",[e._v("示例")]),e._v("：设"),t("code",[e._v("corePoolSize=2")]),e._v("，"),t("code",[e._v("maximumPoolSize=4")]),e._v("，"),t("code",[e._v("workQueue=ArrayBlockingQueue(2)")])]),e._v(" "),t("ul",[t("li",[e._v("任务1、2：创建核心线程执行。")]),e._v(" "),t("li",[e._v("任务3、4：进入队列等待。")]),e._v(" "),t("li",[e._v("任务5、6：创建非核心线程执行（总线程数达4）。")]),e._v(" "),t("li",[e._v("任务7及以后：触发拒绝策略。")])]),e._v(" "),t("h2",{attrs:{id:"二、拒绝策略-线程池的-安全阀"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、拒绝策略-线程池的-安全阀"}},[e._v("#")]),e._v(' 二、拒绝策略：线程池的"安全阀"')]),e._v(" "),t("p",[t("code",[e._v("ThreadPoolExecutor")]),e._v("内置4种拒绝策略，同时支持自定义策略，需根据业务场景选择：")]),e._v(" "),t("h3",{attrs:{id:"_2-1-内置策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-内置策略"}},[e._v("#")]),e._v(" 2.1 内置策略")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("AbortPolicy（默认）")]),e._v(" "),t("ul",[t("li",[e._v("直接抛出"),t("code",[e._v("RejectedExecutionException")]),e._v("，中断任务提交流程。")]),e._v(" "),t("li",[e._v("适用场景：核心业务任务（需明确感知任务提交失败，避免静默丢失）。")])])])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  new ThreadPoolExecutor.AbortPolicy()\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[e._v("CallerRunsPolicy")]),e._v(" "),t("ul",[t("li",[e._v("由提交任务的线程（调用者线程）直接执行任务，会阻塞调用者。")]),e._v(" "),t("li",[e._v("适用场景：并发量不大的场景或需要限流（通过阻塞调用者降低任务提交速度）。")])])])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  new ThreadPoolExecutor.CallerRunsPolicy()\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("ol",{attrs:{start:"3"}},[t("li",[t("strong",[e._v("DiscardPolicy")]),e._v(" "),t("ul",[t("li",[e._v("直接丢弃新任务，不抛异常（任务无声丢失）。")]),e._v(" "),t("li",[e._v("适用场景：非核心任务（如日志采集、统计上报，丢失不影响核心流程）。")])])])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  new ThreadPoolExecutor.DiscardPolicy()\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("ol",{attrs:{start:"4"}},[t("li",[t("strong",[e._v("DiscardOldestPolicy")]),e._v(" "),t("ul",[t("li",[e._v("丢弃队列中最旧的任务，尝试重新提交当前任务。")]),e._v(" "),t("li",[e._v("适用场景：任务有先后顺序，且旧任务可丢弃（如实时数据处理，旧数据时效性低）。")])])])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  new ThreadPoolExecutor.DiscardOldestPolicy()\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("h3",{attrs:{id:"_2-2-自定义策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-自定义策略"}},[e._v("#")]),e._v(" 2.2 自定义策略")]),e._v(" "),t("p",[e._v("实现"),t("code",[e._v("RejectedExecutionHandler")]),e._v("接口，可添加日志记录、任务持久化（如存入数据库/消息队列）等逻辑：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('RejectedExecutionHandler customHandler = (runnable, executor) -> {\n    // 记录被拒绝的任务信息\n    log.error("任务被拒绝，当前线程池状态：活跃线程数={}, 队列大小={}, 任务详情={}",\n            executor.getActiveCount(),\n            executor.getQueue().size(),\n            runnable.toString());\n    // 可选：将任务存入Redis，后续重试\n    redisTemplate.opsForList().leftPush("rejected_tasks", JSON.toJSONString(runnable));\n};\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br")])]),t("h2",{attrs:{id:"三、线程池的状态-生命周期管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、线程池的状态-生命周期管理"}},[e._v("#")]),e._v(" 三、线程池的状态：生命周期管理")]),e._v(" "),t("p",[t("code",[e._v("ThreadPoolExecutor")]),e._v("定义了5种状态，控制线程池的生命周期及任务处理行为：")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("状态")]),e._v(" "),t("th",[e._v("含义")]),e._v(" "),t("th",[e._v("触发方式")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("RUNNING")]),e._v(" "),t("td",[e._v("正常运行：接收新任务，处理队列中已有任务")]),e._v(" "),t("td",[e._v("线程池初始化后默认状态")])]),e._v(" "),t("tr",[t("td",[e._v("SHUTDOWN")]),e._v(" "),t("td",[e._v("不接收新任务，但继续处理队列中已有任务")]),e._v(" "),t("td",[e._v("调用"),t("code",[e._v("shutdown()")])])]),e._v(" "),t("tr",[t("td",[e._v("STOP")]),e._v(" "),t("td",[e._v("不接收新任务，中断正在执行的任务，清空队列")]),e._v(" "),t("td",[e._v("调用"),t("code",[e._v("shutdownNow()")])])]),e._v(" "),t("tr",[t("td",[e._v("TIDYING")]),e._v(" "),t("td",[e._v("所有任务执行完毕，线程数为0，即将进入终止状态")]),e._v(" "),t("td",[e._v("线程池从SHUTDOWN/STOP过渡到此状态")])]),e._v(" "),t("tr",[t("td",[e._v("TERMINATED")]),e._v(" "),t("td",[e._v("线程池彻底终止，执行完"),t("code",[e._v("terminated()")]),e._v("钩子方法（可自定义资源清理逻辑）")]),e._v(" "),t("td",[e._v("从TIDYING状态过渡，标志生命周期结束")])])])]),e._v(" "),t("p",[t("strong",[e._v("状态转换流程")]),e._v("："),t("br"),e._v(" "),t("code",[e._v("RUNNING → SHUTDOWN → TIDYING → TERMINATED")]),t("br"),e._v("\n或"),t("br"),e._v(" "),t("code",[e._v("RUNNING → STOP → TIDYING → TERMINATED")])]),e._v(" "),t("h2",{attrs:{id:"四、为什么不推荐使用executors工具类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、为什么不推荐使用executors工具类"}},[e._v("#")]),e._v(" 四、为什么不推荐使用Executors工具类？")]),e._v(" "),t("p",[t("code",[e._v("Executors")]),e._v("提供了线程池工厂方法（如"),t("code",[e._v("newFixedThreadPool")]),e._v("、"),t("code",[e._v("newCachedThreadPool")]),e._v("），但为了简化使用牺牲了可控性，存在潜在风险：")]),e._v(" "),t("h3",{attrs:{id:"_4-1-无界队列导致oom-newfixedthreadpool-newsinglethreadexecutor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-无界队列导致oom-newfixedthreadpool-newsinglethreadexecutor"}},[e._v("#")]),e._v(" 4.1 无界队列导致OOM（newFixedThreadPool / newSingleThreadExecutor）")]),e._v(" "),t("ul",[t("li",[e._v("两者均使用"),t("code",[e._v("LinkedBlockingQueue")]),e._v("（默认容量"),t("code",[e._v("Integer.MAX_VALUE")]),e._v("，约20亿）。")]),e._v(" "),t("li",[e._v("风险：当任务提交速度远大于处理速度时，任务会无限制堆积在队列中，耗尽堆内存触发OOM。")])]),e._v(" "),t("h3",{attrs:{id:"_4-2-无限制创建线程导致资源耗尽-newcachedthreadpool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-无限制创建线程导致资源耗尽-newcachedthreadpool"}},[e._v("#")]),e._v(" 4.2 无限制创建线程导致资源耗尽（newCachedThreadPool）")]),e._v(" "),t("ul",[t("li",[e._v("核心线程数=0，最大线程数=Integer.MAX_VALUE，空闲超时60秒。")]),e._v(" "),t("li",[e._v('风险：高并发下会无限制创建线程，导致CPU上下文切换频繁、内存耗尽，甚至触发操作系统"进程内存限制"。')])]),e._v(" "),t("p",[t("strong",[e._v("结论")]),e._v("：生产环境应直接使用"),t("code",[e._v("ThreadPoolExecutor")]),e._v("，通过显式参数控制资源上限。")]),e._v(" "),t("h2",{attrs:{id:"五、参数配置最佳实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、参数配置最佳实践"}},[e._v("#")]),e._v(" 五、参数配置最佳实践")]),e._v(" "),t("p",[e._v("合理配置线程池参数是发挥其性能的关键，需结合任务类型（CPU密集/IO密集）和系统资源评估：")]),e._v(" "),t("h3",{attrs:{id:"_5-1-核心线程数与最大线程数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-核心线程数与最大线程数"}},[e._v("#")]),e._v(" 5.1 核心线程数与最大线程数")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("CPU密集型任务")]),e._v("（如计算、排序、加密）："),t("br"),e._v("\n线程数 = CPU核心数 + 1（+1是为了避免CPU空闲，当某线程因页缺失等阻塞时，其他线程可利用CPU）。"),t("br"),e._v("\n示例：4核CPU → 5个线程。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("IO密集型任务")]),e._v("（如数据库查询、网络请求、文件IO）："),t("br"),e._v("\n线程数 = CPU核心数 / (1 - 阻塞系数)（阻塞系数通常为0.8~0.9，即任务80%~90%时间在等待IO）。"),t("br"),e._v("\n示例：4核CPU → 4 / (1 - 0.8) = 20个线程。")])])]),e._v(" "),t("h3",{attrs:{id:"_5-2-工作队列选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-工作队列选择"}},[e._v("#")]),e._v(" 5.2 工作队列选择")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("必须使用有界队列")]),e._v("（如"),t("code",[e._v("ArrayBlockingQueue")]),e._v("），避免无界队列导致的OOM。")]),e._v(" "),t("li",[e._v("队列容量需根据业务压测确定：过小易触发拒绝策略，过大则占用内存过多。建议初始值设为核心线程数的5~10倍，再通过监控调优。")])]),e._v(" "),t("h3",{attrs:{id:"_5-3-其他建议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-其他建议"}},[e._v("#")]),e._v(" 5.3 其他建议")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("线程工厂")]),e._v("：自定义线程名称（如"),t("code",[e._v("order-process-pool-thread-1")]),e._v("），便于日志排查和监控。")]),e._v(" "),t("li",[t("strong",[e._v("空闲时间")]),e._v("：非核心线程空闲时间建议设为30~60秒（平衡资源释放与任务响应速度）。")]),e._v(" "),t("li",[t("strong",[e._v("拒绝策略")]),e._v("：核心任务用"),t("code",[e._v("AbortPolicy")]),e._v("（快速失败），非核心任务用自定义策略（日志+持久化）。")])]),e._v(" "),t("h2",{attrs:{id:"六、总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、总结"}},[e._v("#")]),e._v(" 六、总结")]),e._v(" "),t("p",[e._v("线程池是Java并发编程的核心工具，其核心价值在于通过"),t("strong",[e._v("线程复用")]),e._v("减少资源消耗，通过"),t("strong",[e._v("参数约束")]),e._v("保证系统稳定。使用时需注意：")]),e._v(" "),t("ol",[t("li",[e._v("直接使用"),t("code",[e._v("ThreadPoolExecutor")]),e._v("，避免"),t("code",[e._v("Executors")]),e._v("工具类的隐藏风险。")]),e._v(" "),t("li",[e._v("根据任务类型（CPU/IO密集）合理配置核心参数，尤其是核心线程数、最大线程数和有界队列。")]),e._v(" "),t("li",[e._v("选择合适的拒绝策略，并通过监控及时发现线程池异常。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);