(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{440:function(a,s,t){"use strict";t.r(s);var n=t(8),e=Object(n.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"一、基础概念-进程与线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、基础概念-进程与线程"}},[a._v("#")]),a._v(" 一、基础概念：进程与线程")]),a._v(" "),s("p",[a._v("在理解多线程之前，我们需要先明确两个核心概念："),s("strong",[a._v("进程")]),a._v("与"),s("strong",[a._v("线程")]),a._v("，它们是操作系统中资源管理和任务执行的基本单位。")]),a._v(" "),s("h3",{attrs:{id:"_1-1-进程-process"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-进程-process"}},[a._v("#")]),a._v(" 1.1 进程（Process）")]),a._v(" "),s("p",[a._v("进程是操作系统为"),s("strong",[a._v("正在运行的程序")]),a._v("分配资源（如内存、CPU时间片、文件描述符等）的基本单位，也是程序的一次动态执行实例。")]),a._v(" "),s("ul",[s("li",[a._v("举例：打开浏览器、启动微信、运行Java程序，都会创建一个独立的进程。")]),a._v(" "),s("li",[a._v("特点：进程之间相互独立，拥有各自的内存空间和资源，进程间通信（IPC）需要通过特定机制（如管道、socket等）。")])]),a._v(" "),s("h3",{attrs:{id:"_1-2-线程-thread"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-线程-thread"}},[a._v("#")]),a._v(" 1.2 线程（Thread）")]),a._v(" "),s("p",[a._v("线程是进程内的"),s("strong",[a._v("执行实体")]),a._v("，是CPU调度和分配的最小单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源（如堆内存、方法区），但拥有独立的栈空间。")]),a._v(" "),s("ul",[s("li",[a._v('举例：浏览器进程中，"加载页面"、"播放视频"、"处理用户输入"分别由不同线程执行。')]),a._v(" "),s("li",[a._v("特点：线程间通信更高效（共享内存），但也需注意并发安全问题。")])]),a._v(" "),s("h3",{attrs:{id:"_1-3-进程与线程的核心区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-进程与线程的核心区别"}},[a._v("#")]),a._v(" 1.3 进程与线程的核心区别")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("维度")]),a._v(" "),s("th",[a._v("进程")]),a._v(" "),s("th",[a._v("线程")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[a._v("资源分配")]),a._v(" "),s("td",[a._v("操作系统分配资源的基本单位")]),a._v(" "),s("td",[a._v("不独立分配资源（共享进程资源）")])]),a._v(" "),s("tr",[s("td",[a._v("独立性")]),a._v(" "),s("td",[a._v("相互独立，一个崩溃不影响其他")]),a._v(" "),s("td",[a._v("同进程内线程共享资源，一个崩溃可能影响整个进程")])]),a._v(" "),s("tr",[s("td",[a._v("通信成本")]),a._v(" "),s("td",[a._v("高（需跨进程机制）")]),a._v(" "),s("td",[a._v("低（直接共享内存）")])]),a._v(" "),s("tr",[s("td",[a._v("切换开销")]),a._v(" "),s("td",[a._v("大（需切换资源上下文）")]),a._v(" "),s("td",[a._v("小（主要切换CPU上下文）")])])])]),a._v(" "),s("h2",{attrs:{id:"二、并发与并行-线程执行的两种模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、并发与并行-线程执行的两种模式"}},[a._v("#")]),a._v(" 二、并发与并行：线程执行的两种模式")]),a._v(" "),s("p",[a._v("线程的执行依赖CPU调度，根据CPU核心数不同，会呈现"),s("strong",[a._v("并发")]),a._v("或"),s("strong",[a._v("并行")]),a._v("两种模式，二者常被混淆但本质不同。")]),a._v(" "),s("h3",{attrs:{id:"_2-1-并发-concurrency"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-并发-concurrency"}},[a._v("#")]),a._v(" 2.1 并发（Concurrency）")]),a._v(" "),s("ul",[s("li",[a._v("定义：多个线程"),s("strong",[a._v("交替执行")]),a._v('，通过CPU时间片快速切换，使肉眼感觉"同时运行"。')]),a._v(" "),s("li",[a._v("场景：单核CPU处理多个线程时，CPU在不同线程间快速切换（如1秒内切换1000次），每个线程执行一小段时间。")]),a._v(" "),s("li",[a._v('核心："看起来同时"，本质是'),s("strong",[a._v("串行交替")]),a._v("。")])]),a._v(" "),s("h3",{attrs:{id:"_2-2-并行-parallelism"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-并行-parallelism"}},[a._v("#")]),a._v(" 2.2 并行（Parallelism）")]),a._v(" "),s("ul",[s("li",[a._v("定义：多个线程"),s("strong",[a._v("同时执行")]),a._v("，依赖多核CPU，每个核心独立运行一个线程。")]),a._v(" "),s("li",[a._v("场景：双核CPU中，核心1执行线程A，核心2执行线程B，二者真正同时运行。")]),a._v(" "),s("li",[a._v('核心："真正同时"，依赖硬件多核支持。')])]),a._v(" "),s("h3",{attrs:{id:"_2-3-举例说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-举例说明"}},[a._v("#")]),a._v(" 2.3 举例说明")]),a._v(" "),s("ul",[s("li",[a._v('并发：一个厨师同时处理"切菜"和"颠锅"（交替进行）。')]),a._v(" "),s("li",[a._v('并行：两个厨师分别同时"切菜"和"颠锅"。')])]),a._v(" "),s("h2",{attrs:{id:"三、线程的生命周期-从创建到终止"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、线程的生命周期-从创建到终止"}},[a._v("#")]),a._v(" 三、线程的生命周期：从创建到终止")]),a._v(" "),s("p",[a._v("Java线程的生命周期由"),s("code",[a._v("java.lang.Thread.State")]),a._v("枚举类定义，包含"),s("strong",[a._v("6种状态")]),a._v("，状态之间通过特定操作流转，理解生命周期是掌握线程控制的基础。")]),a._v(" "),s("h3",{attrs:{id:"_3-1-6种核心状态及触发条件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-6种核心状态及触发条件"}},[a._v("#")]),a._v(" 3.1 6种核心状态及触发条件")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("状态")]),a._v(" "),s("th",[a._v("含义描述")]),a._v(" "),s("th",[a._v("触发条件")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[s("strong",[a._v("NEW")])]),a._v(" "),s("td",[a._v("线程对象已创建，但未启动（未调用"),s("code",[a._v("start()")]),a._v("），JVM未分配实际线程资源。")]),a._v(" "),s("td",[s("code",[a._v("Thread t = new Thread()")]),a._v(" 但未执行 "),s("code",[a._v("t.start()")])])]),a._v(" "),s("tr",[s("td",[s("strong",[a._v("RUNNABLE")])]),a._v(" "),s("td",[a._v('线程已启动，处于"就绪"（等待CPU调度）或"运行中"（正在CPU上执行）状态。')]),a._v(" "),s("td",[s("code",[a._v("t.start()")]),a._v("调用后；或从阻塞/等待状态恢复（如"),s("code",[a._v("notify()")]),a._v("、"),s("code",[a._v("sleep()")]),a._v("结束）")])]),a._v(" "),s("tr",[s("td",[s("strong",[a._v("BLOCKED")])]),a._v(" "),s("td",[a._v("线程因竞争"),s("code",[a._v("synchronized")]),a._v("锁失败而暂停，等待获取锁。")]),a._v(" "),s("td",[a._v("线程尝试获取"),s("code",[a._v("synchronized")]),a._v("锁时，锁被其他线程持有")])]),a._v(" "),s("tr",[s("td",[s("strong",[a._v("WAITING")])]),a._v(" "),s("td",[a._v("线程无限期等待其他线程的显式通知（无超时时间），否则永久阻塞。")]),a._v(" "),s("td",[a._v("调用"),s("code",[a._v("Object.wait()")]),a._v("、"),s("code",[a._v("Thread.join()")]),a._v("（无参）、"),s("code",[a._v("LockSupport.park()")]),a._v("等")])]),a._v(" "),s("tr",[s("td",[s("strong",[a._v("TIMED_WAITING")])]),a._v(" "),s("td",[a._v("线程等待指定时间后自动唤醒，或被提前通知。")]),a._v(" "),s("td",[a._v("调用"),s("code",[a._v("Thread.sleep(long)")]),a._v("、"),s("code",[a._v("Object.wait(long)")]),a._v("、"),s("code",[a._v("Thread.join(long)")]),a._v("等")])]),a._v(" "),s("tr",[s("td",[s("strong",[a._v("TERMINATED")])]),a._v(" "),s("td",[a._v("线程执行完成（"),s("code",[a._v("run()")]),a._v("方法结束）或因异常终止，生命周期结束。")]),a._v(" "),s("td",[s("code",[a._v("run()")]),a._v("方法正常执行完毕；或线程执行中抛出未捕获异常")])])])]),a._v(" "),s("h3",{attrs:{id:"_3-2-状态转换关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-状态转换关系"}},[a._v("#")]),a._v(" 3.2 状态转换关系")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("NEW\n↓（调用 start ()，JVM 创建线程并加入就绪队列）\nRUNNABLE\n├─→（竞争 synchronized 锁失败）→ BLOCKED →（其他线程释放锁并获取成功）→ RUNNABLE\n├─→（调用 wait ()/join () 无超时）→ WAITING →（被 notify ()/notifyAll () 唤醒 或 被中断）→ RUNNABLE\n├─→（调用 sleep (ms)/wait (ms)/join (ms)）→ TIMED_WAITING →（时间到 或 被唤醒 / 中断）→ RUNNABLE\n└─→（run () 执行完 或 抛出未捕获异常）→ TERMINATED\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("h3",{attrs:{id:"_3-3-关键说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-关键说明"}},[a._v("#")]),a._v(" 3.3 关键说明")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("RUNNABLE 不等于运行中")]),a._v("："),s("code",[a._v("RUNNABLE")]),a._v('包含"就绪"（等待CPU时间片）和"运行中"（正在执行）两种状态，仅当CPU调度到该线程时，才进入实际运行状态。')]),a._v(" "),s("li",[s("strong",[a._v("BLOCKED 与 WAITING 的区别")]),a._v("："),s("code",[a._v("BLOCKED")]),a._v("是因竞争"),s("code",[a._v("synchronized")]),a._v("锁阻塞，而"),s("code",[a._v("WAITING")]),a._v("是主动进入等待状态（需显式唤醒）。")])]),a._v(" "),s("h2",{attrs:{id:"四、线程的创建方式-3种核心实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、线程的创建方式-3种核心实现"}},[a._v("#")]),a._v(" 四、线程的创建方式：3种核心实现")]),a._v(" "),s("p",[a._v("Java中创建线程有3种核心方式，各有适用场景，需根据是否需要返回值、是否需继承其他类等需求选择。")]),a._v(" "),s("h3",{attrs:{id:"_4-1-方式一-继承thread类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-方式一-继承thread类"}},[a._v("#")]),a._v(" 4.1 方式一：继承Thread类")]),a._v(" "),s("p",[s("strong",[a._v("步骤")]),a._v("：继承"),s("code",[a._v("Thread")]),a._v("类 → 重写"),s("code",[a._v("run()")]),a._v("方法（线程执行逻辑）→ 创建实例并调用"),s("code",[a._v("start()")]),a._v("启动线程。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('public class ThreadDemo1 {\n    public static void main(String[] args) {\n        // 创建线程实例\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        // 启动线程（JVM会调用run()）\n        t1.start();\n        t2.start();\n    }\n}\n\n// 继承Thread类，重写run()\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        // 线程执行逻辑：循环打印信息\n        for (int i = 0; i < 5; i++) {\n            // 获取当前线程名称（默认格式：Thread-0、Thread-1...）\n            System.out.println(Thread.currentThread().getName() + " : " + i);\n            // 模拟耗时操作，让线程切换更明显\n            try {\n                Thread.sleep(1000); // 休眠1秒（进入TIMED_WAITING状态）\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br")])]),s("p",[s("strong",[a._v("优缺点")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("优点：实现简单，直接调用"),s("code",[a._v("this.getName()")]),a._v("获取线程名。")]),a._v(" "),s("li",[a._v("缺点：Java单继承限制，继承"),s("code",[a._v("Thread")]),a._v("后无法再继承其他类；线程逻辑与线程对象耦合。")])]),a._v(" "),s("h3",{attrs:{id:"_4-2-方式二-实现runnable接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-方式二-实现runnable接口"}},[a._v("#")]),a._v(" 4.2 方式二：实现Runnable接口")]),a._v(" "),s("p",[s("strong",[a._v("步骤")]),a._v("：实现"),s("code",[a._v("Runnable")]),a._v("接口 → 重写"),s("code",[a._v("run()")]),a._v("方法 → 将"),s("code",[a._v("Runnable")]),a._v("实例传给"),s("code",[a._v("Thread")]),a._v("构造器 → 调用"),s("code",[a._v("start()")]),a._v("启动。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('public class ThreadDemo2 {\n    public static void main(String[] args) {\n        // 创建任务实例（线程执行逻辑）\n        MyRunnable task = new MyRunnable();\n\n        // 用Thread包装任务，可指定线程名称\n        Thread t1 = new Thread(task, "线程A");\n        Thread t2 = new Thread(task, "线程B");\n        // 启动线程\n        t1.start();\n        t2.start();\n    }\n}\n\n// 实现Runnable接口，重写run()\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName() + " : " + i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br")])]),s("p",[s("strong",[a._v("优缺点")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("优点：避免单继承限制，可多实现；任务逻辑与线程对象解耦，适合多线程共享同一个任务实例（如共享资源）。")]),a._v(" "),s("li",[a._v("缺点：无法直接获取返回值（需额外处理）。")])]),a._v(" "),s("h3",{attrs:{id:"_4-3-方式三-callable-futuretask-带返回值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-方式三-callable-futuretask-带返回值"}},[a._v("#")]),a._v(" 4.3 方式三：Callable + FutureTask（带返回值）")]),a._v(" "),s("p",[s("strong",[a._v("步骤")]),a._v("：实现"),s("code",[a._v("Callable")]),a._v("接口 → 重写"),s("code",[a._v("call()")]),a._v("方法（有返回值，可抛异常）→ 用"),s("code",[a._v("FutureTask")]),a._v("包装"),s("code",[a._v("Callable")]),a._v(" → 传给"),s("code",[a._v("Thread")]),a._v("启动 → 调用"),s("code",[a._v("FutureTask.get()")]),a._v("获取返回值。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('import java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\n\npublic class ThreadDemo3 {\n    public static void main(String[] args) throws Exception {\n        // 创建带返回值的任务\n        MyCallable task = new MyCallable();\n        // 用FutureTask包装Callable（兼具Runnable和Future特性）\n        FutureTask<String> futureTask = new FutureTask<>(task);\n\n        // 启动线程（FutureTask实现了Runnable，可作为Thread构造参数）\n        Thread t = new Thread(futureTask, "带返回值的线程");\n        t.start();\n\n        // 获取返回值（get()会阻塞，直到线程执行完成）\n        String result = futureTask.get();\n        System.out.println("线程执行结果：" + result);\n    }\n}\n\n// 实现Callable接口，指定返回值类型为String\nclass MyCallable implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(Thread.currentThread().getName() + " 执行中：" + i);\n            Thread.sleep(1000);\n        }\n        // 返回线程名称作为结果\n        return Thread.currentThread().getName() + " 执行完成";\n    }\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br")])]),s("p",[s("strong",[a._v("优缺点")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("优点：支持返回值；"),s("code",[a._v("call()")]),a._v("可抛出异常，便于错误处理；适合需要获取线程执行结果的场景（如异步计算）。")]),a._v(" "),s("li",[a._v("缺点：实现稍复杂；"),s("code",[a._v("get()")]),a._v("方法会阻塞当前线程，需注意性能影响。")])]),a._v(" "),s("h2",{attrs:{id:"五、线程创建的关键问题解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、线程创建的关键问题解析"}},[a._v("#")]),a._v(" 五、线程创建的关键问题解析")]),a._v(" "),s("h3",{attrs:{id:"_5-1-为什么不能直接调用run-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-为什么不能直接调用run-方法"}},[a._v("#")]),a._v(" 5.1 为什么不能直接调用"),s("code",[a._v("run()")]),a._v("方法？")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("start()")]),a._v("：是启动线程的正确方式，其作用是告诉JVM创建新线程、分配系统资源（如CPU时间片），并将线程加入就绪队列；线程被调度后，JVM会自动调用"),s("code",[a._v("run()")]),a._v("。")]),a._v(" "),s("li",[s("code",[a._v("run()")]),a._v("：只是普通方法，直接调用"),s("code",[a._v("run()")]),a._v("不会创建新线程，而是在当前线程（如主线程）中同步执行"),s("code",[a._v("run()")]),a._v("逻辑，失去多线程意义。")])]),a._v(" "),s("h3",{attrs:{id:"_5-2-为什么必须依赖thread类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-为什么必须依赖thread类"}},[a._v("#")]),a._v(" 5.2 为什么必须依赖"),s("code",[a._v("Thread")]),a._v("类？")]),a._v(" "),s("p",[a._v("无论通过"),s("code",[a._v("Runnable")]),a._v("还是"),s("code",[a._v("Callable")]),a._v("定义任务，最终都需要"),s("code",[a._v("Thread")]),a._v("类启动，核心原因是：")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("Thread")]),a._v("是Java对"),s("strong",[a._v("操作系统线程")]),a._v("的封装，通过"),s("code",[a._v("native")]),a._v("方法（如"),s("code",[a._v("start0()")]),a._v("）与JVM和操作系统交互，完成底层线程创建、资源分配等操作。")]),a._v(" "),s("li",[s("code",[a._v("run()")]),a._v("（"),s("code",[a._v("Runnable")]),a._v("）和"),s("code",[a._v("call()")]),a._v("（"),s("code",[a._v("Callable")]),a._v("）仅定义任务逻辑，不具备向操作系统申请线程资源的能力。")])]),a._v(" "),s("h2",{attrs:{id:"六、线程的常用属性与方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、线程的常用属性与方法"}},[a._v("#")]),a._v(" 六、线程的常用属性与方法")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("方法/属性")]),a._v(" "),s("th",[a._v("作用描述")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[s("code",[a._v("Thread.currentThread()")])]),a._v(" "),s("td",[a._v("获取当前正在执行的线程实例。")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("setName(String)")]),a._v(" / "),s("code",[a._v("getName()")])]),a._v(" "),s("td",[a._v("设置/获取线程名称（便于调试）。")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("setPriority(int)")])]),a._v(" "),s("td",[a._v("设置线程优先级（1-10，默认5），优先级高的线程更可能被CPU调度（非绝对）。")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("setDaemon(boolean)")])]),a._v(" "),s("td",[a._v("设置为守护线程（如GC线程），当所有非守护线程结束时，守护线程自动终止。")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("sleep(long ms)")])]),a._v(" "),s("td",[a._v("让当前线程休眠指定毫秒数（进入TIMED_WAITING状态，不释放锁）。")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("join()")])]),a._v(" "),s("td",[a._v("等待该线程执行完毕后，当前线程再继续执行（如"),s("code",[a._v("t.join()")]),a._v("：主线程等待t执行完）。")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("yield()")])]),a._v(" "),s("td",[a._v("提示CPU让出时间片，当前线程进入就绪状态，重新参与调度（不保证一定让出）。")])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);