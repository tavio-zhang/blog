(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{442:function(a,s,t){"use strict";t.r(s);var n=t(8),r=Object(n.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("在多线程编程中，线程对共享变量的读写操作可能因CPU缓存、编译器优化等导致数据不一致问题。"),s("strong",[a._v("JMM（Java Memory Model，Java内存模型）并非物理内存结构，而是JVM定义的一套内存访问规范")]),a._v("，其核心目标是"),s("strong",[a._v("屏蔽不同硬件和操作系统的内存差异")]),a._v("，保证Java程序在多线程环境下的内存可见性、原子性和有序性，让程序在不同平台上表现出一致的并发行为。")]),a._v(" "),s("h2",{attrs:{id:"一、jmm的核心模型-主内存与工作内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、jmm的核心模型-主内存与工作内存"}},[a._v("#")]),a._v(" 一、JMM的核心模型：主内存与工作内存")]),a._v(" "),s("p",[a._v("JMM通过抽象“主内存”和“工作内存”，规范了线程对共享变量的访问方式。")]),a._v(" "),s("h3",{attrs:{id:"_1-1-主内存-main-memory"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-主内存-main-memory"}},[a._v("#")]),a._v(" 1.1 主内存（Main Memory）")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("定义")]),a._v("：所有线程共享的内存区域，是JVM对物理内存的抽象（并非完全等同于物理内存，可能包含JVM堆、方法区等共享数据区域）。")]),a._v(" "),s("li",[s("strong",[a._v("存储内容")]),a._v("：所有共享变量（如实例变量、静态变量等，局部变量因线程私有不属此类）。")])]),a._v(" "),s("h3",{attrs:{id:"_1-2-工作内存-working-memory"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-工作内存-working-memory"}},[a._v("#")]),a._v(" 1.2 工作内存（Working Memory）")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("定义")]),a._v("：每个线程独有的内存区域，对应CPU的高速缓存、寄存器等硬件存储结构。")]),a._v(" "),s("li",[s("strong",[a._v("存储内容")]),a._v("：线程需要操作的共享变量的副本（线程不能直接读写主内存的共享变量，必须通过副本间接操作）。")])]),a._v(" "),s("h3",{attrs:{id:"_1-3-线程与内存的交互规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-线程与内存的交互规则"}},[a._v("#")]),a._v(" 1.3 线程与内存的交互规则")]),a._v(" "),s("p",[a._v("线程对共享变量的操作需遵循以下步骤（JMM定义的原子操作）：")]),a._v(" "),s("ol",[s("li",[s("strong",[a._v("读取（read）")]),a._v("：从主内存将共享变量的值读到工作内存。")]),a._v(" "),s("li",[s("strong",[a._v("加载（load）")]),a._v("：将read得到的值加载到工作内存的变量副本中。")]),a._v(" "),s("li",[s("strong",[a._v("使用（use）")]),a._v("：线程执行时，从工作内存的变量副本中读取值并使用（如计算）。")]),a._v(" "),s("li",[s("strong",[a._v("赋值（assign）")]),a._v("：线程修改变量后，将新值赋值给工作内存的变量副本。")]),a._v(" "),s("li",[s("strong",[a._v("存储（store）")]),a._v("：将工作内存中修改后的变量值传递到主内存。")]),a._v(" "),s("li",[s("strong",[a._v("写入（write）")]),a._v("：将store得到的值写入主内存的共享变量中。")])]),a._v(" "),s("p",[s("strong",[a._v("示例流程")]),a._v("：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("[主内存] → 共享变量a=0\n   ↓（线程1执行read→load）         ↓（线程2执行read→load）\n[线程1工作内存] → a=0副本        [线程2工作内存] → a=0副本\n   ↓（线程1执行use→assign：a=1）  ↓（线程2执行use：读取到a=0）\n[线程1工作内存] → a=1副本        [线程2工作内存] → a=0副本（可见性问题）\n   ↓（线程1执行store→write）\n[主内存] → a=1（更新后的值）\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("blockquote",[s("p",[a._v("注意：不同线程的工作内存相互隔离，变量值的传递必须通过主内存，这是多线程内存问题的根源。")])]),a._v(" "),s("h2",{attrs:{id:"二、jmm解决的三大核心问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、jmm解决的三大核心问题"}},[a._v("#")]),a._v(" 二、JMM解决的三大核心问题")]),a._v(" "),s("p",[a._v("多线程并发时，因主内存与工作内存的交互机制，可能出现"),s("strong",[a._v("可见性、原子性、有序性")]),a._v("问题，JMM通过关键字和底层机制解决这些问题。")]),a._v(" "),s("h3",{attrs:{id:"_2-1-可见性问题-线程间-看不到-变量更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-可见性问题-线程间-看不到-变量更新"}},[a._v("#")]),a._v(" 2.1 可见性问题：线程间“看不到”变量更新")]),a._v(" "),s("h4",{attrs:{id:"问题定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题定义"}},[a._v("#")]),a._v(" 问题定义")]),a._v(" "),s("p",[a._v("当线程A修改了共享变量并同步到主内存前，线程B读取的仍是工作内存中未更新的旧副本，导致数据不一致。")]),a._v(" "),s("h4",{attrs:{id:"问题示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题示例"}},[a._v("#")]),a._v(" 问题示例")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('private static boolean flag = false; // 主内存中的共享变量\n\npublic static void main(String[] args) throws InterruptedException {\n    // 线程1：1秒后将flag改为true\n    new Thread(() -> {\n        try { Thread.sleep(1000); } catch (InterruptedException e) {}\n        flag = true; // 修改工作内存副本，尚未同步到主内存\n        System.out.println("线程1：flag已设为true");\n    }).start();\n\n    // 线程2：循环判断flag，若为true则退出\n    new Thread(() -> {\n        while (!flag) { \n            // 始终读取工作内存中的旧副本（false），无法感知线程1的修改\n        }\n        System.out.println("线程2：检测到flag为true，退出循环");\n    }).start();\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br")])]),s("p",[s("strong",[a._v("现象")]),a._v("：线程2可能永远无法退出循环（因看不到flag的更新）。")]),a._v(" "),s("h4",{attrs:{id:"解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),s("p",[a._v("JMM通过强制刷新工作内存与主内存的同步，保证可见性：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("volatile关键字")]),a._v("：\n"),s("ul",[s("li",[a._v("写操作：线程修改volatile变量后，会立即通过"),s("strong",[a._v("写屏障")]),a._v("将工作内存的新值同步到主内存。")]),a._v(" "),s("li",[a._v("读操作：线程读取volatile变量前，会通过"),s("strong",[a._v("读屏障")]),a._v("从主内存刷新最新值到工作内存。")])])]),a._v(" "),s("li",[s("strong",[a._v("synchronized关键字")]),a._v("：\n"),s("ul",[s("li",[a._v("释放锁时：线程会将工作内存的变量值同步回主内存（写屏障作用）。")]),a._v(" "),s("li",[a._v("获取锁时：线程会清空工作内存，从主内存重新加载变量（读屏障作用）。")])])])]),a._v(" "),s("h3",{attrs:{id:"_2-2-原子性问题-操作被中断导致数据错误"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-原子性问题-操作被中断导致数据错误"}},[a._v("#")]),a._v(" 2.2 原子性问题：操作被中断导致数据错误")]),a._v(" "),s("h4",{attrs:{id:"问题定义-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题定义-2"}},[a._v("#")]),a._v(" 问题定义")]),a._v(" "),s("p",[a._v("一个操作或多个操作要么全部执行且执行过程不被中断，要么都不执行。若操作被多线程打断，会导致数据不一致（如"),s("code",[a._v("count++")]),a._v("实际是“读-改-写”三步操作，可能被其他线程插入执行）。")]),a._v(" "),s("h4",{attrs:{id:"问题示例-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题示例-2"}},[a._v("#")]),a._v(" 问题示例")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('private static int count = 0;\n\npublic static void main(String[] args) throws InterruptedException {\n    // 10000个线程同时执行count++\n    for (int i = 0; i < 10000; i++) {\n        new Thread(() -> {\n            try { Thread.sleep(1); } catch (InterruptedException e) {} // 放大竞争概率\n            count++; // 非原子操作：读取count→加1→写入count\n        }).start();\n    }\n    Thread.sleep(1000); // 等待所有线程执行完毕\n    System.out.println("最终count值：" + count); // 结果通常<10000\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br")])]),s("p",[s("strong",[a._v("现象")]),a._v("：最终结果小于10000，因多个线程同时读取旧值并修改，覆盖了彼此的结果。")]),a._v(" "),s("h4",{attrs:{id:"解决方案-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),s("p",[a._v("JMM通过限制并发执行范围或使用原子指令保证原子性：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("synchronized关键字")]),a._v("：通过互斥锁保证临界区（同步代码块）内的代码仅被一个线程执行，避免操作被中断。")]),a._v(" "),s("li",[s("strong",[a._v("原子类（如AtomicInteger）")]),a._v("：基于CPU的"),s("strong",[a._v("CAS（Compare-And-Swap）指令")]),a._v("实现原子操作，无需加锁。例如"),s("code",[a._v("AtomicInteger.incrementAndGet()")]),a._v("通过底层"),s("code",[a._v("Unsafe")]),a._v("类的"),s("code",[a._v("compareAndSwapInt")]),a._v("方法，原子性地完成“读-改-写”。")])]),a._v(" "),s("h3",{attrs:{id:"_2-3-有序性问题-指令重排序破坏逻辑"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-有序性问题-指令重排序破坏逻辑"}},[a._v("#")]),a._v(" 2.3 有序性问题：指令重排序破坏逻辑")]),a._v(" "),s("h4",{attrs:{id:"问题定义-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题定义-3"}},[a._v("#")]),a._v(" 问题定义")]),a._v(" "),s("p",[a._v("编译器或CPU为优化性能，会调整指令的执行顺序（重排序）。单线程下重排序不影响结果，但多线程下可能破坏代码逻辑。")]),a._v(" "),s("h4",{attrs:{id:"问题示例-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题示例-3"}},[a._v("#")]),a._v(" 问题示例")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('private static int a = 0;\nprivate static boolean b = false;\n\npublic static void main(String[] args) {\n    // 线程1：修改a和b\n    new Thread(() -> {\n        a = 10;    // 操作1\n        b = true;  // 操作2（可能被重排序到操作1前执行）\n    }).start();\n\n    // 线程2：依赖b的状态读取a\n    new Thread(() -> {\n        if (b) {   // 若b=true，预期a=10\n            System.out.println("a: " + a); // 可能输出a=0（因操作2先执行）\n        }\n    }).start();\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br")])]),s("p",[s("strong",[a._v("现象")]),a._v("：因重排序，线程1可能先执行"),s("code",[a._v("b=true")]),a._v("再执行"),s("code",[a._v("a=10")]),a._v("，此时线程2读取到"),s("code",[a._v("b=true")]),a._v("但"),s("code",[a._v("a=0")]),a._v("，违背逻辑预期。")]),a._v(" "),s("h4",{attrs:{id:"解决方案-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-3"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),s("p",[a._v("JMM通过禁止特定重排序保证有序性：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("volatile关键字")]),a._v("：通过内存屏障禁止volatile变量与其他变量的重排序（如"),s("code",[a._v("volatile")]),a._v("变量的写操作不能被重排序到之前的操作前，读操作不能被重排序到之后的操作后）。")]),a._v(" "),s("li",[s("strong",[a._v("synchronized关键字")]),a._v("：同步代码块内的指令执行顺序与代码逻辑一致（因互斥性，单线程执行无重排序问题）。")]),a._v(" "),s("li",[s("strong",[a._v("final关键字")]),a._v("：禁止final字段的初始化与构造函数外的操作重排序。例如，"),s("code",[a._v("final")]),a._v("变量在构造函数中初始化后，其他线程看到的一定是初始化后的值（不会看到未初始化的中间状态）。")])]),a._v(" "),s("h2",{attrs:{id:"三、内存屏障-jmm的底层实现机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、内存屏障-jmm的底层实现机制"}},[a._v("#")]),a._v(" 三、内存屏障：JMM的底层实现机制")]),a._v(" "),s("p",[a._v("JMM通过"),s("strong",[a._v("内存屏障（Memory Barrier）")]),a._v(" 强制约束指令重排序和内存可见性，是解决三大问题的底层保障。")]),a._v(" "),s("h3",{attrs:{id:"_3-1-内存屏障的分类与作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-内存屏障的分类与作用"}},[a._v("#")]),a._v(" 3.1 内存屏障的分类与作用")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("LoadLoad屏障")]),a._v("：禁止屏障后的读操作重排序到屏障前（确保先读完屏障前的变量，再读屏障后的变量）。")]),a._v(" "),s("li",[s("strong",[a._v("StoreStore屏障")]),a._v("：禁止屏障后的写操作重排序到屏障前（确保先写完屏障前的变量，再写屏障后的变量）。")]),a._v(" "),s("li",[s("strong",[a._v("LoadStore屏障")]),a._v("：禁止屏障后的写操作重排序到屏障前的读操作前（确保读完后再写）。")]),a._v(" "),s("li",[s("strong",[a._v("StoreLoad屏障")]),a._v("：禁止屏障后的读操作重排序到屏障前的写操作前（最严格，确保写完后再读，会刷新缓存）。")])]),a._v(" "),s("h3",{attrs:{id:"_3-2-java中内存屏障的应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-java中内存屏障的应用"}},[a._v("#")]),a._v(" 3.2 Java中内存屏障的应用")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("volatile关键字")]),a._v("：\n"),s("ul",[s("li",[a._v("写"),s("code",[a._v("volatile")]),a._v("变量后：插入"),s("strong",[a._v("StoreStore屏障")]),a._v("（保证之前的写操作已同步到主内存）和"),s("strong",[a._v("StoreLoad屏障")]),a._v("（保证写操作完成后再执行后续读操作）。")]),a._v(" "),s("li",[a._v("读"),s("code",[a._v("volatile")]),a._v("变量前：插入"),s("strong",[a._v("LoadLoad屏障")]),a._v("（保证先读主内存最新值）和"),s("strong",[a._v("LoadStore屏障")]),a._v("（保证读完后再执行后续写操作）。")])])]),a._v(" "),s("li",[s("strong",[a._v("synchronized关键字")]),a._v("：\n"),s("ul",[s("li",[a._v("获取锁时：插入"),s("strong",[a._v("LoadLoad屏障")]),a._v("和"),s("strong",[a._v("LoadStore屏障")]),a._v("（清空工作内存，从主内存加载最新值）。")]),a._v(" "),s("li",[a._v("释放锁时：插入"),s("strong",[a._v("StoreStore屏障")]),a._v("和"),s("strong",[a._v("StoreLoad屏障")]),a._v("（将工作内存的修改同步回主内存）。")])])])]),a._v(" "),s("h2",{attrs:{id:"四、总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、总结"}},[a._v("#")]),a._v(" 四、总结")]),a._v(" "),s("p",[a._v("JMM作为Java多线程内存交互的核心规范，通过抽象主内存与工作内存模型，解决了多线程并发的三大问题：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("可见性")]),a._v("：通过volatile、synchronized的内存同步机制保证。")]),a._v(" "),s("li",[s("strong",[a._v("原子性")]),a._v("：通过synchronized的互斥锁或原子类的CAS指令保证。")]),a._v(" "),s("li",[s("strong",[a._v("有序性")]),a._v("：通过volatile、synchronized、final的重排序约束保证。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);