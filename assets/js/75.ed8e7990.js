(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{428:function(v,_,e){"use strict";e.r(_);var t=e(8),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("Redis 作为高性能键值数据库，以单线程架构支撑数万级 QPS 的高并发场景，其核心奥秘在于"),_("strong",[v._v("事件驱动模型")]),v._v("与"),_("strong",[v._v("IO 多路复用技术")]),v._v("的深度协同。")]),v._v(" "),_("h2",{attrs:{id:"一、数据传输的基石-缓冲区机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、数据传输的基石-缓冲区机制"}},[v._v("#")]),v._v(" 一、数据传输的基石：缓冲区机制")]),v._v(" "),_("p",[v._v("在 Redis 与客户端的网络交互中，数据并非直接在应用程序与网卡间传输，而是通过"),_("strong",[v._v("内核缓冲区")]),v._v("（内核态）与"),_("strong",[v._v("应用缓冲区")]),v._v("（用户态）的协作完成。")]),v._v(" "),_("h3",{attrs:{id:"_1-1-内核缓冲区-操作系统的-io-中转站"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-内核缓冲区-操作系统的-io-中转站"}},[v._v("#")]),v._v(" 1.1 内核缓冲区：操作系统的 IO 中转站")]),v._v(" "),_("p",[v._v("内核缓冲区是操作系统为每个网络套接字（Socket）分配的内核态内存区域，是数据在“网卡与应用程序”之间的必经之路。")]),v._v(" "),_("h4",{attrs:{id:"核心特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#核心特性"}},[v._v("#")]),v._v(" 核心特性")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("归属与访问")]),v._v("：属于操作系统内核管理，用户进程（如 Redis）无法直接读写，必须通过 "),_("code",[v._v("read()")]),v._v("、"),_("code",[v._v("write()")]),v._v(" 等系统调用间接访问（需切换至内核态）。")]),v._v(" "),_("li",[_("strong",[v._v("大小控制")]),v._v("：由系统内核参数配置（如 Linux 的 "),_("code",[v._v("net.core.rmem_default")]),v._v(" 控制读缓冲区默认大小，"),_("code",[v._v("net.core.wmem_default")]),v._v(" 控制写缓冲区），通常为几 KB 到几十 KB。")]),v._v(" "),_("li",[_("strong",[v._v("双缓冲区设计")]),v._v("：每个 Socket 包含读缓冲区（recv buffer）和写缓冲区（send buffer），分别负责接收和发送数据。")])]),v._v(" "),_("h4",{attrs:{id:"核心作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#核心作用"}},[v._v("#")]),v._v(" 核心作用")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("解耦异步传输")]),v._v("："),_("br"),v._v("\n客户端发送的数据先由网卡接收并拷贝至内核读缓冲区，即使 Redis 未及时处理，数据也不会丢失；Redis 发送响应时，只需将数据写入内核写缓冲区，内核会异步将数据发送至网卡，无需 Redis 等待。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("优化系统调用")]),v._v("："),_("br"),v._v("\n内核缓冲区会暂存小批量数据（如 TCP 的 Nagle 算法合并小数据包），减少应用程序频繁调用 "),_("code",[v._v("read()")]),v._v("/"),_("code",[v._v("write()")]),v._v(" 的开销（每次系统调用需切换内核态，成本较高）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("平衡硬件速度差异")]),v._v("："),_("br"),v._v("\n网卡数据传输速度（GB 级/秒）远高于用户进程处理速度（MB 级/秒），缓冲区可暂存突发数据，避免“高速设备等待低速设备”的性能浪费。")])])]),v._v(" "),_("h3",{attrs:{id:"_1-2-应用缓冲区-redis-自主管理的用户态内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-应用缓冲区-redis-自主管理的用户态内存"}},[v._v("#")]),v._v(" 1.2 应用缓冲区：Redis 自主管理的用户态内存")]),v._v(" "),_("p",[v._v("应用缓冲区是 Redis 在用户态内存中为每个客户端连接分配的内存区域，由 Redis 直接管理，无需内核介入即可读写。")]),v._v(" "),_("h4",{attrs:{id:"分类与设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分类与设计"}},[v._v("#")]),v._v(" 分类与设计")]),v._v(" "),_("p",[v._v("Redis 为每个 "),_("code",[v._v("redisClient")]),v._v(" 结构体维护两类应用缓冲区：")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("缓冲区类型")]),v._v(" "),_("th",[v._v("存储内容")]),v._v(" "),_("th",[v._v("数据结构")]),v._v(" "),_("th",[v._v("大小特性")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("输入缓冲区（Input Buffer）")]),v._v(" "),_("td",[v._v("客户端发送的命令数据（如 "),_("code",[v._v("SET key value")]),v._v("）")]),v._v(" "),_("td",[_("code",[v._v("querybuf")]),v._v(" 字段（动态字符串）")]),v._v(" "),_("td",[v._v("初始 16KB，动态扩容，最大不超过 1GB（可通过 "),_("code",[v._v("client-query-buffer-limit")]),v._v(" 配置）")])]),v._v(" "),_("tr",[_("td",[v._v("输出缓冲区（Output Buffer）")]),v._v(" "),_("td",[v._v("待发送给客户端的响应数据（如 "),_("code",[v._v("OK")]),v._v("、value 值）")]),v._v(" "),_("td",[v._v("由 "),_("code",[v._v("buf")]),v._v("（固定 16KB 小缓冲区）和 "),_("code",[v._v("reply")]),v._v("（动态链表/字符串）组成")]),v._v(" "),_("td",[v._v("小响应存 "),_("code",[v._v("buf")]),v._v("，大响应（如批量查询结果）存 "),_("code",[v._v("reply")]),v._v("，可配置上限避免内存溢出")])])])]),v._v(" "),_("h4",{attrs:{id:"核心作用-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#核心作用-2"}},[v._v("#")]),v._v(" 核心作用")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("支撑命令解析")]),v._v("："),_("br"),v._v("\n输入缓冲区暂存完整的命令数据，Redis 可基于缓冲区逐字节解析 Redis 协议，避免“边读边解析”的复杂逻辑。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("缓存响应结果")]),v._v("："),_("br"),v._v("\n输出缓冲区暂存命令执行结果，等待内核写缓冲区空闲时批量发送，减少系统调用次数（例如，一次发送多个小响应，替代多次单独发送）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("避免阻塞单线程")]),v._v("："),_("br"),v._v("\nRedis 单线程处理命令时，输出缓冲区可暂存响应数据，无需等待客户端接收完成即可处理下一个命令，提升并发效率。")])])]),v._v(" "),_("h3",{attrs:{id:"_1-3-缓冲区交互-数据从客户端到-redis-的完整流转"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-缓冲区交互-数据从客户端到-redis-的完整流转"}},[v._v("#")]),v._v(" 1.3 缓冲区交互：数据从客户端到 Redis 的完整流转")]),v._v(" "),_("p",[v._v("以“客户端发送 "),_("code",[v._v("SET key value")]),v._v(" 命令并接收 "),_("code",[v._v("OK")]),v._v(" 响应”为例，数据在缓冲区之间的流转流程如下：")]),v._v(" "),_("h4",{attrs:{id:"阶段-1-命令接收-读数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#阶段-1-命令接收-读数据"}},[v._v("#")]),v._v(" 阶段 1：命令接收（读数据）")]),v._v(" "),_("ol",[_("li",[v._v("客户端调用 "),_("code",[v._v("send()")]),v._v(" 发送命令，数据从“客户端应用缓冲区”→“客户端内核写缓冲区”→ 网卡。")]),v._v(" "),_("li",[v._v("Redis 服务器网卡接收数据，内核将数据从网卡拷贝至“Redis 内核读缓冲区”。")]),v._v(" "),_("li",[v._v("IO 多路复用器（如 epoll）检测到该 Socket 读事件就绪，通知 Redis 主线程。")]),v._v(" "),_("li",[v._v("Redis 调用 "),_("code",[v._v("read()")]),v._v(" 系统调用，将数据从“内核读缓冲区”拷贝至“Redis 输入缓冲区”。")]),v._v(" "),_("li",[v._v("Redis 解析输入缓冲区中的命令，执行 "),_("code",[v._v("SET")]),v._v(" 操作，将响应 "),_("code",[v._v("OK")]),v._v(" 写入“输出缓冲区”。")])]),v._v(" "),_("h4",{attrs:{id:"阶段-2-响应发送-写数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#阶段-2-响应发送-写数据"}},[v._v("#")]),v._v(" 阶段 2：响应发送（写数据）")]),v._v(" "),_("ol",[_("li",[v._v("Redis 向 IO 多路复用器注册该客户端 Socket 的写事件。")]),v._v(" "),_("li",[v._v("内核写缓冲区空闲时（有空间存储新数据），IO 多路复用器通知写事件就绪。")]),v._v(" "),_("li",[v._v("Redis 调用 "),_("code",[v._v("write()")]),v._v(" 系统调用，将数据从“输出缓冲区”拷贝至“内核写缓冲区”。")]),v._v(" "),_("li",[v._v("内核异步将数据从“内核写缓冲区”拷贝至网卡，发送给客户端。")]),v._v(" "),_("li",[v._v("若响应数据未完全发送（如数据过大），保留未发送部分至下次写事件触发；若发送完成，取消写事件注册并清空输出缓冲区。")])]),v._v(" "),_("p",[_("strong",[v._v("核心要点")]),v._v("：数据传输需经过两次关键拷贝（内核缓冲区 ↔ 应用缓冲区），IO 多路复用技术仅监听内核缓冲区的就绪状态，避免 Redis 对未就绪 Socket 进行无效系统调用。")]),v._v(" "),_("h2",{attrs:{id:"二、事件驱动模型-redis-高并发的底层架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、事件驱动模型-redis-高并发的底层架构"}},[v._v("#")]),v._v(" 二、事件驱动模型：Redis 高并发的底层架构")]),v._v(" "),_("p",[v._v("Redis 是典型的"),_("strong",[v._v("事件驱动型程序")]),v._v("，其核心遵循 "),_("strong",[v._v("Reactor 模式")]),v._v("（反应器模式）：由一个主线程通过 IO 多路复用机制监听多个事件源，当事件就绪时触发对应回调函数处理。这种设计既避免了多线程上下文切换的开销，又保证了单线程下的有序执行。")]),v._v(" "),_("h3",{attrs:{id:"_2-1-事件的两种核心类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-事件的两种核心类型"}},[v._v("#")]),v._v(" 2.1 事件的两种核心类型")]),v._v(" "),_("p",[v._v("Redis 将所有待处理事件分为两类，统一由事件循环调度：")]),v._v(" "),_("h4",{attrs:{id:"_1-文件事件-file-event"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-文件事件-file-event"}},[v._v("#")]),v._v(" （1）文件事件（File Event）")]),v._v(" "),_("p",[v._v("与网络 IO 相关的事件，是处理客户端请求的核心，包括：")]),v._v(" "),_("ul",[_("li",[v._v("连接事件：客户端发起连接（"),_("code",[v._v("accept")]),v._v("）、断开连接。")]),v._v(" "),_("li",[v._v("读写事件：客户端发送命令（读）、Redis 发送响应（写）。")])]),v._v(" "),_("h4",{attrs:{id:"_2-时间事件-time-event"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-时间事件-time-event"}},[v._v("#")]),v._v(" （2）时间事件（Time Event）")]),v._v(" "),_("p",[v._v("与定时/周期性任务相关的事件，用于维护服务器状态，包括：")]),v._v(" "),_("ul",[_("li",[v._v("定时事件：仅执行一次（如 "),_("code",[v._v("UNLINK")]),v._v(" 命令异步删除大键）。")]),v._v(" "),_("li",[v._v("周期性事件：重复执行（如后台过期键清理、持久化检查）。")])]),v._v(" "),_("h3",{attrs:{id:"_2-2-reactor-模式的核心组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-reactor-模式的核心组件"}},[v._v("#")]),v._v(" 2.2 Reactor 模式的核心组件")]),v._v(" "),_("p",[v._v("Redis 通过 "),_("code",[v._v("ae.c")]),v._v(" 模块实现 Reactor 模式，核心组件如下：")]),v._v(" "),_("h4",{attrs:{id:"_1-事件循环-aeeventloop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-事件循环-aeeventloop"}},[v._v("#")]),v._v(" （1）事件循环（aeEventLoop）")]),v._v(" "),_("p",[v._v("Reactor 模式的“大脑”，负责管理所有注册的事件、监听事件就绪状态、触发回调函数。其核心结构定义如下：")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("typedef struct aeEventLoop {\n    int maxfd;                     // 已注册事件的最大文件描述符（FD）\n    int setsize;                   // 事件集合大小（支持的最大 FD 数量）\n    long long timeEventNextId;     // 下一个时间事件的唯一 ID\n    aeFileEvent *events;           // 注册的文件事件（FD 到事件的映射表）\n    aeFiredEvent *fired;           // 已触发的事件列表（IO 多路复用返回的就绪事件）\n    aeTimeEvent *timeEventHead;    // 时间事件链表（无序存储）\n    int stop;                      // 事件循环停止标志（0：运行，1：停止）\n    void *apidata;                 // 多路复用技术的私有数据（如 epoll 的句柄）\n    aeBeforeSleepProc *beforesleep;// 事件循环阻塞前的回调函数（如 serverCron 预热）\n} aeEventLoop;\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br"),_("span",{staticClass:"line-number"},[v._v("9")]),_("br"),_("span",{staticClass:"line-number"},[v._v("10")]),_("br"),_("span",{staticClass:"line-number"},[v._v("11")]),_("br")])]),_("h4",{attrs:{id:"_2-事件源-aefileevent-aetimeevent"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件源-aefileevent-aetimeevent"}},[v._v("#")]),v._v(" （2）事件源（aeFileEvent / aeTimeEvent）")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("文件事件（aeFileEvent）")]),v._v("：绑定特定 FD 和事件类型（读/写），包含事件就绪时的回调函数。"),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("typedef struct aeFileEvent {\n    int mask;                     // 事件类型掩码（AE_READABLE / AE_WRITABLE）\n    aeFileProc *rfileProc;        // 读事件回调函数（如 readQueryFromClient）\n    aeFileProc *wfileProc;        // 写事件回调函数（如 sendReplyToClient）\n    void *clientData;             // 私有数据（如 redisClient 指针）\n} aeFileEvent;\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br")])])]),v._v(" "),_("li",[_("strong",[v._v("时间事件（aeTimeEvent）")]),v._v("：包含事件执行时间、回调函数、是否周期性执行等信息。")])]),v._v(" "),_("h4",{attrs:{id:"_3-事件处理器-回调函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-事件处理器-回调函数"}},[v._v("#")]),v._v(" （3）事件处理器（回调函数）")]),v._v(" "),_("p",[v._v("针对不同事件的处理逻辑，例如：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("acceptTcpHandler")]),v._v("：处理新客户端连接。")]),v._v(" "),_("li",[_("code",[v._v("readQueryFromClient")]),v._v("：从客户端读取并解析命令。")]),v._v(" "),_("li",[_("code",[v._v("sendReplyToClient")]),v._v("：向客户端发送响应。")]),v._v(" "),_("li",[_("code",[v._v("serverCron")]),v._v("：执行周期性后台任务。")])]),v._v(" "),_("h2",{attrs:{id:"三、文件事件-网络-io-的高效处理机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、文件事件-网络-io-的高效处理机制"}},[v._v("#")]),v._v(" 三、文件事件：网络 IO 的高效处理机制")]),v._v(" "),_("p",[v._v("文件事件是 Redis 处理网络请求的核心，本质是对 Socket 操作的抽象。通过 IO 多路复用技术，Redis 单线程可同时监听数千个客户端连接的读写事件，实现高并发处理。")]),v._v(" "),_("h3",{attrs:{id:"_3-1-io-多路复用-单线程处理多连接的关键"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-io-多路复用-单线程处理多连接的关键"}},[v._v("#")]),v._v(" 3.1 IO 多路复用：单线程处理多连接的关键")]),v._v(" "),_("p",[v._v("IO 多路复用的核心思想是："),_("strong",[v._v("一个线程通过一次系统调用（如 "),_("code",[v._v("epoll_wait")]),v._v("）监听多个 FD，当某个 FD 就绪（可读/可写）时，系统调用返回并通知该 FD 就绪，再触发对应处理逻辑")]),v._v("。")]),v._v(" "),_("h4",{attrs:{id:"_3-1-1-三种-io-模型的对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-三种-io-模型的对比"}},[v._v("#")]),v._v(" 3.1.1 三种 IO 模型的对比")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("IO 模型")]),v._v(" "),_("th",[v._v("核心逻辑")]),v._v(" "),_("th",[v._v("阻塞点")]),v._v(" "),_("th",[v._v("并发能力")]),v._v(" "),_("th",[v._v("典型场景")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("阻塞 IO（BIO）")]),v._v(" "),_("td",[v._v("调用 "),_("code",[v._v("read()")]),v._v(" 后阻塞至数据拷贝完成")]),v._v(" "),_("td",[v._v("等待数据 + 数据拷贝")]),v._v(" "),_("td",[v._v("极低")]),v._v(" "),_("td",[v._v("简单本地文件读写")])]),v._v(" "),_("tr",[_("td",[v._v("非阻塞 IO（NIO）")]),v._v(" "),_("td",[v._v("调用 "),_("code",[v._v("read()")]),v._v(" 后立即返回，无数据则轮询重试")]),v._v(" "),_("td",[v._v("仅数据拷贝")]),v._v(" "),_("td",[v._v("一般")]),v._v(" "),_("td",[v._v("低延迟、小数据场景")])]),v._v(" "),_("tr",[_("td",[v._v("IO 多路复用")]),v._v(" "),_("td",[v._v("内核监听多 FD，仅通知就绪事件")]),v._v(" "),_("td",[v._v("无事件时阻塞在监听阶段")]),v._v(" "),_("td",[v._v("极高")]),v._v(" "),_("td",[v._v("高并发网络服务（Redis）")])])])]),v._v(" "),_("p",[_("strong",[v._v("为什么 Redis 不选非阻塞 IO？")]),_("br"),v._v("\n非阻塞 IO 需要应用程序主动轮询所有 FD 是否就绪（空轮询），即使无事件也会消耗 CPU；而 IO 多路复用由内核监听，无事件时线程阻塞，几乎不消耗 CPU。")]),v._v(" "),_("h4",{attrs:{id:"_3-1-2-redis-支持的-io-多路复用技术"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-redis-支持的-io-多路复用技术"}},[v._v("#")]),v._v(" 3.1.2 Redis 支持的 IO 多路复用技术")]),v._v(" "),_("p",[v._v("Redis 为跨平台适配，实现了多种 IO 多路复用方案，通过统一接口封装（优先选择高效方案）：")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("技术")]),v._v(" "),_("th",[v._v("适用系统")]),v._v(" "),_("th",[v._v("核心优势")]),v._v(" "),_("th",[v._v("Redis 优先级")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("epoll")]),v._v(" "),_("td",[v._v("Linux")]),v._v(" "),_("td",[v._v("事件驱动，支持水平触发（LT）/边缘触发（ET），FD 无上限，事件查询效率 O(1)")]),v._v(" "),_("td",[v._v("最高")])]),v._v(" "),_("tr",[_("td",[v._v("kqueue")]),v._v(" "),_("td",[v._v("Mac OS/FreeBSD")]),v._v(" "),_("td",[v._v("类似 epoll，支持 ET 模式，FD 无上限，适合高并发")]),v._v(" "),_("td",[v._v("次之")])]),v._v(" "),_("tr",[_("td",[v._v("select")]),v._v(" "),_("td",[v._v("所有系统")]),v._v(" "),_("td",[v._v("兼容性好，但 FD 上限 1024，事件查询 O(n)（遍历所有 FD），效率低")]),v._v(" "),_("td",[v._v("最低")])]),v._v(" "),_("tr",[_("td",[v._v("poll")]),v._v(" "),_("td",[v._v("大多数系统")]),v._v(" "),_("td",[v._v("突破 FD 上限，但仍需遍历所有 FD，效率低于 epoll/kqueue")]),v._v(" "),_("td",[v._v("较低")])])])]),v._v(" "),_("h4",{attrs:{id:"_3-1-3-epoll-为何是-linux-下的首选"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3-epoll-为何是-linux-下的首选"}},[v._v("#")]),v._v(" 3.1.3 epoll 为何是 Linux 下的首选？")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("无 FD 上限")]),v._v("："),_("br"),v._v(" "),_("code",[v._v("select")]),v._v(" 受限于 "),_("code",[v._v("FD_SETSIZE")]),v._v("（默认 1024），而 epoll 支持的 FD 数量由系统内存决定（通常可达百万级），适合 Redis 高并发场景。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("事件通知机制更高效")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("select")]),v._v(" 每次调用需将 FD 集合从用户态拷贝到内核态，并遍历所有 FD 检查就绪状态（O(n) 复杂度）。")]),v._v(" "),_("li",[v._v("epoll 用红黑树存储 FD，注册时拷贝一次，后续无需重复拷贝；事件就绪时通过回调直接通知（O(1) 复杂度）。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("灵活的触发模式")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("水平触发（LT，Redis 默认）：FD 有未读数据时持续通知，实现简单，避免漏处理。")]),v._v(" "),_("li",[v._v("边缘触发（ET）：仅在 FD 状态变化时通知一次，需一次性读完所有数据，效率更高但实现复杂（Redis 为稳定性选择 LT）。")])])])]),v._v(" "),_("h3",{attrs:{id:"_3-2-文件事件的完整处理流程-以客户端请求为例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-文件事件的完整处理流程-以客户端请求为例"}},[v._v("#")]),v._v(" 3.2 文件事件的完整处理流程（以客户端请求为例）")]),v._v(" "),_("p",[v._v("以“客户端发送 "),_("code",[v._v("SET key value")]),v._v(" 命令”为例，解析文件事件从连接建立到响应发送的全生命周期：")]),v._v(" "),_("h4",{attrs:{id:"步骤-1-监听连接事件-服务器启动阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#步骤-1-监听连接事件-服务器启动阶段"}},[v._v("#")]),v._v(" 步骤 1：监听连接事件（服务器启动阶段）")]),v._v(" "),_("ul",[_("li",[v._v("Redis 启动时创建监听套接字（绑定 6379 端口），向 epoll 注册"),_("strong",[v._v("读事件")]),v._v("（"),_("code",[v._v("AE_READABLE")]),v._v("），回调函数为 "),_("code",[v._v("acceptTcpHandler")]),v._v("（负责处理新连接）。")])]),v._v(" "),_("h4",{attrs:{id:"步骤-2-建立客户端连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#步骤-2-建立客户端连接"}},[v._v("#")]),v._v(" 步骤 2：建立客户端连接")]),v._v(" "),_("ul",[_("li",[v._v("客户端发起 TCP 三次握手，连接建立后，内核将监听 FD 标记为“读就绪”，epoll 将其加入“已触发事件列表”。")]),v._v(" "),_("li",[v._v("Redis 主线程调用 "),_("code",[v._v("acceptTcpHandler")]),v._v("，通过 "),_("code",[v._v("accept()")]),v._v(" 系统调用获取客户端 Socket，并创建 "),_("code",[v._v("redisClient")]),v._v(" 对象（初始化输入/输出缓冲区）。")]),v._v(" "),_("li",[v._v("向 epoll 注册该客户端 FD 的"),_("strong",[v._v("读事件")]),v._v("，回调函数为 "),_("code",[v._v("readQueryFromClient")]),v._v("（负责读取命令）。")])]),v._v(" "),_("h4",{attrs:{id:"步骤-3-读取并解析命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#步骤-3-读取并解析命令"}},[v._v("#")]),v._v(" 步骤 3：读取并解析命令")]),v._v(" "),_("ul",[_("li",[v._v("客户端发送 "),_("code",[v._v("SET key value")]),v._v(" 命令，内核将数据写入客户端 FD 的读缓冲区，epoll 检测到“读就绪”并通知 Redis。")]),v._v(" "),_("li",[v._v("Redis 调用 "),_("code",[v._v("readQueryFromClient")]),v._v("，通过 "),_("code",[v._v("read()")]),v._v(" 将数据从内核读缓冲区拷贝至 Redis 输入缓冲区。")]),v._v(" "),_("li",[v._v("解析输入缓冲区中的 Redis 协议，提取命令参数（"),_("code",[v._v("SET")]),v._v("、"),_("code",[v._v("key")]),v._v("、"),_("code",[v._v("value")]),v._v("），执行命令并将结果（"),_("code",[v._v("OK")]),v._v("）写入输出缓冲区。")])]),v._v(" "),_("h4",{attrs:{id:"步骤-4-发送响应结果"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#步骤-4-发送响应结果"}},[v._v("#")]),v._v(" 步骤 4：发送响应结果")]),v._v(" "),_("ul",[_("li",[v._v("Redis 向 epoll 注册该客户端 FD 的"),_("strong",[v._v("写事件")]),v._v("（"),_("code",[v._v("AE_WRITABLE")]),v._v("），回调函数为 "),_("code",[v._v("sendReplyToClient")]),v._v("（负责发送响应）。")]),v._v(" "),_("li",[v._v("内核写缓冲区空闲时（有空间存储数据），epoll 通知“写就绪”。")]),v._v(" "),_("li",[v._v("Redis 调用 "),_("code",[v._v("sendReplyToClient")]),v._v("，通过 "),_("code",[v._v("write()")]),v._v(" 将输出缓冲区中的 "),_("code",[v._v("OK")]),v._v(" 拷贝至内核写缓冲区，内核异步发送至客户端。")]),v._v(" "),_("li",[v._v("若响应未完全发送（如数据过大），保留未发送部分；若发送完成，取消写事件注册（避免无数据时的空触发）。")])]),v._v(" "),_("h3",{attrs:{id:"_3-3-事件优先级与优化策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-事件优先级与优化策略"}},[v._v("#")]),v._v(" 3.3 事件优先级与优化策略")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("读事件优先于写事件")]),v._v("："),_("br"),v._v("\n客户端请求（读）需及时处理，否则可能导致客户端超时；而响应（写）可短暂延迟，因此事件循环中先处理读事件，再处理写事件。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("按需注册写事件")]),v._v("："),_("br"),v._v("\n仅当输出缓冲区有数据需发送时，才向 epoll 注册写事件；发送完成后立即取消注册，避免套接字可写但无数据的“空轮询”（减少系统调用开销）。")])])]),v._v(" "),_("h2",{attrs:{id:"四、时间事件-后台任务的调度机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、时间事件-后台任务的调度机制"}},[v._v("#")]),v._v(" 四、时间事件：后台任务的调度机制")]),v._v(" "),_("p",[v._v("时间事件用于处理定时任务和周期性任务，是 Redis 维护服务器状态的核心机制，与文件事件共同构成事件循环的两大支柱。")]),v._v(" "),_("h3",{attrs:{id:"_4-1-时间事件的两种类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-时间事件的两种类型"}},[v._v("#")]),v._v(" 4.1 时间事件的两种类型")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("定时事件")]),v._v("：仅执行一次，如 "),_("code",[v._v("UNLINK")]),v._v(" 命令触发的大键异步删除（避免阻塞主线程）、临时任务调度。")]),v._v(" "),_("li",[_("strong",[v._v("周期性事件")]),v._v("：按固定间隔重复执行，核心是 "),_("code",[v._v("serverCron")]),v._v(" 函数（Redis 最关键的后台任务入口）。")])]),v._v(" "),_("h3",{attrs:{id:"_4-2-核心周期性任务-servercron-函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-核心周期性任务-servercron-函数"}},[v._v("#")]),v._v(" 4.2 核心周期性任务：serverCron 函数")]),v._v(" "),_("p",[_("code",[v._v("serverCron")]),v._v(" 由配置项 "),_("code",[v._v("hz")]),v._v(" 控制执行频率（默认每秒 10 次，可通过 "),_("code",[v._v("hz")]),v._v(" 配置调整，范围 1-500），主要负责以下工作：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("服务器状态维护")]),v._v("："),_("br"),v._v("\n更新当前时间、计算内存使用量、统计 CPU 利用率、更新 LRU 时钟（用于键淘汰）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("过期键清理")]),v._v("："),_("br"),v._v("\n遍历过期字典，随机抽取部分键检查是否过期并删除（结合惰性删除：访问键时才检查过期），平衡内存占用与性能。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("持久化管理")]),v._v("："),_("br"),v._v("\n检查是否满足 RDB 快照触发条件（如 "),_("code",[v._v("save 60 10000")]),v._v("：60 秒内有 10000 次写操作）或 AOF 重写条件（如当前 AOF 文件大小超过上次重写后 100%）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("客户端管理")]),v._v("："),_("br"),v._v("\n关闭长时间空闲（超过 "),_("code",[v._v("timeout")]),v._v(" 配置）的客户端连接，释放资源；清理输出缓冲区溢出的客户端（避免内存泄漏）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("集群与哨兵同步")]),v._v("："),_("br"),v._v("\n维护集群节点心跳、更新节点状态；哨兵模式下同步主从信息、检测主节点是否下线。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("性能优化")]),v._v("："),_("br"),v._v("\n执行内存碎片整理（"),_("code",[v._v("activedefrag")]),v._v(" 配置开启时）、更新命令执行次数统计、重置峰值内存记录等。")])])]),v._v(" "),_("h3",{attrs:{id:"_4-3-时间事件的实现逻辑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-时间事件的实现逻辑"}},[v._v("#")]),v._v(" 4.3 时间事件的实现逻辑")]),v._v(" "),_("p",[v._v("Redis 用"),_("strong",[v._v("无序链表")]),v._v("存储时间事件（而非堆等有序结构），事件循环中处理流程如下：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("遍历链表查找最早到期事件")]),v._v("："),_("br"),v._v("\n循环遍历时间事件链表，计算每个事件的到期时间（"),_("code",[v._v("when")]),v._v("）与当前时间的差值，找到最早到期的事件。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("计算 IO 多路复用的阻塞时间")]),v._v("："),_("br"),v._v("\n将最早到期事件的剩余时间作为 IO 多路复用（如 "),_("code",[v._v("epoll_wait")]),v._v("）的超时时间——若没有时间事件，超时时间为 -1（无限阻塞）；若有，则阻塞至事件到期或文件事件就绪。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("处理已到期的时间事件")]),v._v("："),_("br"),v._v("\n处理完文件事件后，再次遍历链表，执行所有 "),_("code",[v._v("when")]),v._v(" 小于当前时间的时间事件；若为周期性事件，更新其 "),_("code",[v._v("when")]),v._v(" 为下次到期时间。")])])]),v._v(" "),_("p",[_("strong",[v._v("为什么用无序链表？")]),_("br"),v._v("\nRedis 中时间事件数量极少（通常仅 "),_("code",[v._v("serverCron")]),v._v(" 一个周期性事件），遍历开销可忽略（O(1) 复杂度），无需复杂的有序数据结构。")]),v._v(" "),_("h2",{attrs:{id:"五、事件循环-redis-主线程的运行逻辑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、事件循环-redis-主线程的运行逻辑"}},[v._v("#")]),v._v(" 五、事件循环：Redis 主线程的运行逻辑")]),v._v(" "),_("p",[v._v("Redis 启动后，主线程进入 "),_("code",[v._v("aeMain")]),v._v(" 事件循环，不断循环处理文件事件和时间事件，核心流程如下：")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("void aeMain(aeEventLoop *eventLoop) {\n    eventLoop->stop = 0;\n    while (!eventLoop->stop) {\n        // 1. 执行 beforeSleep 回调（如 serverCron 预热）\n        if (eventLoop->beforesleep != NULL)\n            eventLoop->beforesleep(eventLoop);\n        // 2. 监听文件事件，阻塞时间为最早到期时间事件的剩余时间\n        aeProcessEvents(eventLoop, AE_ALL_EVENTS);\n    }\n}\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br"),_("span",{staticClass:"line-number"},[v._v("9")]),_("br"),_("span",{staticClass:"line-number"},[v._v("10")]),_("br")])]),_("h3",{attrs:{id:"详细步骤解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#详细步骤解析"}},[v._v("#")]),v._v(" 详细步骤解析")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("执行 beforeSleep 回调")]),v._v("："),_("br"),v._v("\n事件循环阻塞前，调用 "),_("code",[v._v("beforesleep")]),v._v(" 函数（默认绑定 "),_("code",[v._v("beforeSleep")]),v._v(" 方法），执行如更新服务器统计信息、处理后台任务队列等操作。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("监听并处理文件事件")]),v._v("："),_("br"),v._v("\n调用 "),_("code",[v._v("aeProcessEvents")]),v._v(" 函数，通过 IO 多路复用接口（如 "),_("code",[v._v("epoll_wait")]),v._v("）监听文件事件，阻塞时间由“最早到期时间事件的剩余时间”决定。当文件事件就绪时，按“读事件优先于写事件”的顺序触发回调函数处理。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("处理时间事件")]),v._v("："),_("br"),v._v("\n文件事件处理完成后，遍历时间事件链表，执行所有已到期的事件（定时事件执行后删除，周期性事件更新下次到期时间）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("循环或退出")]),v._v("："),_("br"),v._v("\n若未触发停止标志（"),_("code",[v._v("stop=0")]),v._v("），重复步骤 1-3；若触发（如 "),_("code",[v._v("SHUTDOWN")]),v._v(" 命令），退出事件循环，关闭服务器。")])])]),v._v(" "),_("h2",{attrs:{id:"总结-redis-高性能的设计哲学"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结-redis-高性能的设计哲学"}},[v._v("#")]),v._v(" 总结：Redis 高性能的设计哲学")]),v._v(" "),_("p",[v._v("Redis 以“单线程 + 事件驱动”为核心，通过三大机制实现高性能：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("IO 多路复用")]),v._v("：借助 epoll 等技术，单线程高效监听数千个客户端连接，避免无效系统调用和空轮询。")]),v._v(" "),_("li",[_("strong",[v._v("双缓冲区协作")]),v._v("：内核缓冲区与应用缓冲区分工明确，减少系统调用次数，平衡硬件速度差异。")]),v._v(" "),_("li",[_("strong",[v._v("事件驱动调度")]),v._v("：Reactor 模式统一调度文件事件（网络请求）和时间事件（后台任务），保证单线程下的有序并发。")])]),v._v(" "),_("p",[v._v("这种设计既规避了多线程的并发竞争问题，又突破了单线程的 IO 瓶颈，使 Redis 在高并发场景下仍能保持毫秒级响应，成为缓存、会话存储等场景的首选数据库。")])])}),[],!1,null,null,null);_.default=s.exports}}]);