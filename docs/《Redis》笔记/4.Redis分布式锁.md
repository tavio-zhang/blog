---
title: Redis分布式锁
date: 2023-04-15 21:47:23
permalink: /pages/88227a/
categories:
  - 《Redis》笔记
tags:
  - Redis分布式锁
author: 
  name: Tavio
  link: https://github.com/tavio-zhang
---

在分布式系统中，多个独立服务或进程往往需要共享资源（如库存、订单、分布式任务等）。由于分布式环境的异步性和网络不可靠性，单纯的本地锁（如Java的`synchronized`、`ReentrantLock`）无法跨节点生效，此时需要**分布式锁**来保证跨进程、跨机器的并发安全。Redis凭借高性能、低延迟、支持原子操作等特性，成为实现分布式锁的主流选择。

## 一、分布式锁的核心特征

一个可靠的分布式锁是分布式系统并发安全的基础，其必须满足以下核心条件，否则可能导致业务数据不一致、死锁等严重问题：

| 特征 | 含义 | 重要性 |
|------|------|--------|
| 互斥性 | 同一时刻只能有一个线程持有锁，确保共享资源不会被并发修改 | 核心条件，直接决定并发安全 |
| 安全性 | 锁只能被持有者释放，防止其他线程误删不属于自己的锁 | 避免锁被恶意释放导致互斥失效 |
| 可用性 | 锁服务需高可用，避免单点故障导致整个锁机制崩溃 | 保证分布式系统的稳定性 |
| 原子性 | 锁的获取、释放操作必须是原子化的，避免中间状态（如“获取锁但未设置过期时间”） | 防止因操作拆分导致的逻辑漏洞 |
| 过期自动释放 | 当持有锁的线程崩溃时，锁能自动过期释放，避免永久死锁 | 解决线程异常导致的资源独占问题 |
| 可重入性（可选） | 同一线程可多次获取同一把锁（如递归调用、嵌套业务） | 提升锁的灵活性，适应复杂业务场景 |
| 公平性（可选） | 按请求顺序分配锁，避免线程长期饥饿 | 特定场景下需保证（如任务调度） |

## 二、Redis分布式锁的基础实现

Redis分布式锁的核心是通过原子命令实现“获取锁”和“释放锁”的原子操作。

### 2.1 早期实现的缺陷：SETNX + EXPIRE

在Redis 2.6之前，开发者通常使用`SETNX`（Set If Not Exists）命令获取锁，再用`EXPIRE`设置过期时间，代码逻辑如下：

```
# 步骤1：获取锁（若key不存在则设置，返回1表示成功，0表示失败）
SETNX lock:key unique-value
# 步骤2：设置过期时间（避免死锁）
EXPIRE lock:key 30
```

**缺陷分析**：  
`SETNX`和`EXPIRE`是两个独立命令，若线程在执行完`SETNX`后、`EXPIRE`前崩溃（如节点宕机），会导致锁没有过期时间，永久被持有，引发死锁。因此，这种方案因非原子性被淘汰。

### 2.2 优化实现：SET命令的原子性方案（Redis 2.6+）

Redis 2.6版本为`SET`命令增加了`NX`（Not Exists）和`EX`（Expire）等扩展参数，支持“不存在则设置+过期时间”的原子操作，彻底解决了早期方案的非原子性问题。

#### 核心命令
```
# 获取锁：原子性操作
# key=锁名称（如lock:stock:1001，标识商品1001的库存锁）
# value=唯一标识（如UUID，用于释放锁时校验持有者）
# NX=仅当key不存在时设置（保证互斥性）
# EX=设置过期时间（秒），避免死锁
SET lock:key [unique-value] NX EX 30

# 释放锁：需先校验持有者，再删除（通过Lua脚本保证原子性）
if redis.call("GET", "lock:key") == "unique-value" then
    return redis.call("DEL", "lock:key")  # 持有者正确，释放锁
else
    return 0  # 持有者错误，不做操作
end
```

#### Java代码实现
```
public class RedisLock {
    private final RedisTemplate<String, String> redisTemplate;

    public RedisLock(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    // 获取锁：返回唯一标识（用于释放锁），null表示获取失败
    public String tryLock(String lockKey, long expireSeconds) {
        // 生成唯一标识（避免多线程/机器的value冲突）
        String uniqueValue = UUID.randomUUID().toString();
        // 执行SET命令：原子性获取锁并设置过期时间
        Boolean success = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, uniqueValue, expireSeconds, TimeUnit.SECONDS);
        return success != null && success ? uniqueValue : null;
    }

    // 释放锁：返回true表示释放成功
    public boolean releaseLock(String lockKey, String uniqueValue) {
        // Lua脚本：先校验value，再删除（原子操作）
        String luaScript = """
                if redis.call('get', KEYS[1]) == ARGV[1] then
                    return redis.call('del', KEYS[1])
                else
                    return 0
                end
                """;
        // 执行Lua脚本
        Long result = redisTemplate.execute(
                new DefaultRedisScript<>(luaScript, Long.class),
                Collections.singletonList(lockKey),
                uniqueValue
        );
        return result != null && result > 0;
    }
}
```

#### 关键参数说明
- `NX`：保证只有当锁不存在时才能获取成功，是实现互斥性的核心。
- `EX`：强制设置过期时间，即使线程崩溃，锁也会在过期后自动释放，避免死锁。
- `unique-value`：每个线程/请求的唯一标识（如UUID+线程ID），用于释放锁时校验“当前线程是否为锁的持有者”，防止误删其他线程的锁（例如：线程A的锁过期后，线程B获取到锁，此时线程A执行完任务，若没有校验直接删除，会误删线程B的锁）。

## 三、基础实现的核心缺陷

基础实现满足了互斥性、安全性、原子性和过期释放，但在复杂分布式场景下仍存在以下关键问题：

### 3.1 锁超时问题：任务执行时间 > 锁过期时间

**场景示例**：  
- 线程A获取锁，设置过期时间30秒，但业务逻辑执行了40秒（如网络延迟、任务复杂）。
- 30秒后锁自动释放，线程B此时获取到锁，开始执行任务。
- 线程A执行完任务（第40秒），通过释放锁逻辑删除了线程B持有的锁。
- 最终导致线程B的锁被误删，可能有更多线程获取到锁，引发并发安全问题（如库存超卖）。

**本质原因**：锁的过期时间是固定的，无法动态适应业务执行时间的波动。

### 3.2 不可重入问题：同一线程无法多次获取同一把锁

**场景示例**：  
- 线程A获取锁后，在业务逻辑中需要递归调用或嵌套调用另一个需要同一把锁的方法。
- 此时线程A再次请求获取锁时，会因“锁已存在”被拒绝，导致死锁（自己等自己释放锁）。

**本质原因**：基础实现未记录“锁的持有者”和“重入次数”，无法识别同一线程的重复请求。

### 3.3 主从切换/集群脑裂问题：锁数据丢失

**场景示例**：  
- Redis采用主从架构（主节点M+从节点S），锁数据存储在主节点M。
- 线程A在M上获取锁成功，但数据尚未同步到S时，M突然宕机。
- 哨兵将S升级为新主节点，此时新主节点S中没有线程A的锁数据。
- 线程B可以在新主节点S上获取到同一把锁，导致多个线程同时持有锁。

**本质原因**：主从复制是异步的，主节点宕机可能导致锁数据未同步到从节点，引发锁丢失。

## 四、Redis分布式锁的优化

针对基础实现的缺陷，Redis提出了三类优化方案，分别解决锁超时、可重入性和高可用问题。

### 4.1 优化1：锁续约（看门狗机制）——解决锁超时问题

**核心思路**：线程获取锁后，启动一个后台“看门狗”线程，定期延长锁的过期时间，确保锁的有效期始终覆盖业务执行时间，直到任务完成。

#### 实现逻辑
1. 线程获取锁时，设置初始过期时间（如30秒）。
2. 启动看门狗线程（守护线程，与业务线程同生命周期），每隔“过期时间/3”（如10秒）执行一次`EXPIRE lock:key 30`，延长锁的过期时间。
3. 业务任务执行完成后，手动释放锁，并停止看门狗线程。
4. 若线程崩溃，看门狗线程也会终止，锁会在初始过期时间后自动释放。

#### 主流框架实现：Redisson的看门狗
Redisson是Redis的Java客户端框架，内置了完善的看门狗机制，无需手动实现：
```
public class RedissonLockExample {
    private final RedissonClient redissonClient;

    public RedissonLockExample(RedissonClient redissonClient) {
        this.redissonClient = redissonClient;
    }

    public void doBusiness(String lockKey) {
        // 获取锁对象
        RLock lock = redissonClient.getLock(lockKey);
        try {
            // 尝试获取锁：最多等待5秒，10秒后自动过期（看门狗会动态续约）
            boolean locked = lock.tryLock(5, 10, TimeUnit.SECONDS);
            if (locked) {
                // 执行业务逻辑（即使执行时间超过10秒，看门狗会自动续约）
                System.out.println("获取锁成功，执行业务...");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            // 释放锁（仅当当前线程持有锁时）
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

**Redisson看门狗细节**：  
- 默认初始过期时间为30秒，续约间隔为10秒（30/3）。
- 若业务线程正常执行，看门狗会无限续约；若线程崩溃，看门狗终止，锁在30秒后释放。

### 4.2 优化2：可重入锁设计——解决重入问题

**核心思路**：通过Redis的Hash结构存储锁的“持有者标识”和“重入次数”，实现同一线程多次获取锁的支持。

#### 数据结构设计
使用Hash类型存储锁信息，结构如下：

| Key | Hash key | Hash Value |
| - | - | - |
| lock:test | 节点ID:线程ID | 1（首次加锁）/2（重入1次） |

* 节点ID：Redisson客户端的唯一标识，避免多机器线程ID冲突
* 重入次数：记录同一线程获取锁的次数，解锁时递减，减至0才删除锁

#### 核心逻辑
- **获取锁**：
  1. 若锁不存在，创建Hash结构，设置重入次数为1，同时设置过期时间。
  2. 若锁已存在且持有者是当前线程，重入次数+1，并延长过期时间。
  3. 若锁已存在且持有者是其他线程，获取失败。

- **释放锁**：
  1. 若持有者是当前线程，重入次数-1。
  2. 若重入次数减为0，删除锁（释放资源）。
  3. 若重入次数>0，仅延长过期时间（仍持有锁）。

#### Redisson可重入锁的Lua实现（核心逻辑）
获取锁的Lua脚本（简化版）：
```
-- KEYS[1] = lock:key
-- ARGV[1] = 持有者标识（node:thread）
-- ARGV[2] = 过期时间（毫秒）
if redis.call('exists', KEYS[1]) == 0 then
    -- 锁不存在，创建并设置重入次数1
    redis.call('hset', KEYS[1], ARGV[1], 1)
    redis.call('pexpire', KEYS[1], ARGV[2])
    return 1  -- 获取成功
end
if redis.call('hexists', KEYS[1], ARGV[1]) == 1 then
    -- 锁存在且持有者是当前线程，重入次数+1
    redis.call('hincrby', KEYS[1], ARGV[1], 1)
    redis.call('pexpire', KEYS[1], ARGV[2])
    return 1  -- 获取成功
end
return 0  -- 其他线程持有锁，获取失败
```

释放锁的Lua脚本（简化版）：
```
-- KEYS[1] = lock:key
-- ARGV[1] = 持有者标识（node:thread）
if redis.call('hexists', KEYS[1], ARGV[1]) == 0 then
    return 0  -- 不是持有者，无法释放
end
-- 重入次数-1
local count = redis.call('hincrby', KEYS[1], ARGV[1], -1)
if count > 0 then
    -- 重入次数仍>0，延长过期时间
    redis.call('pexpire', KEYS[1], ARGV[2])
    return 1
else
    -- 重入次数=0，删除锁
    redis.call('del', KEYS[1])
    return 1
end
```

### 4.3 优化3：Redlock算法——解决主从切换/集群脑裂问题

基础实现和可重入锁依赖单节点或主从架构，存在单点故障风险。Redis提出的**Redlock算法**，通过多个独立Redis节点（无主从关系）实现高可用分布式锁。

#### 核心思想
- 部署N个独立的Redis节点（推荐N=3，奇数，保证多数派），节点间无数据同步。
- 获取锁时，需在**多数节点（N/2 + 1）** 上成功获取锁，且总耗时不超过锁的过期时间，才算获取成功。
- 释放锁时，向所有节点发送删除命令（无论是否成功获取过锁）。

#### 执行步骤（以N=3为例）
1. **客户端获取当前时间戳T1**（毫秒级，用于计算耗时）。
2. **依次向3个节点发送获取锁命令**：  
   对每个节点执行`SET lock:key unique-value NX EX 30`（过期时间30秒），超时时间设为5-50毫秒（避免单个节点阻塞过久）。
3. **收集结果并校验**：  
   - 统计成功获取锁的节点数量（设为K）。  
   - 计算总耗时：T2 - T1（T2为所有节点响应完成的时间戳）。  
   - 若K ≥ 2（多数派）且总耗时 < 30秒（锁过期时间），则锁获取成功，**实际有效期 = 30秒 - 总耗时**。
4. **获取失败处理**：  
   若K < 2或总耗时 ≥ 30秒，立即向所有节点发送释放锁命令，避免锁残留，然后等待随机时间（如100-300毫秒）后重试。
5. **释放锁**：  
   向所有3个节点发送释放锁的Lua脚本（无论该节点是否成功获取过锁），确保所有节点的锁都被清除。

#### Redlock的优缺点
| 优点 | 缺点 |
|------|------|
| 无单点故障：多个节点独立，少数节点故障不影响整体 | 部署成本高：需维护N个独立Redis节点 |
| 解决主从异步复制导致的锁丢失问题 | 性能略低：需访问多个节点，耗时增加 |
| 满足分布式系统的安全性（理论上） | 实现复杂：需处理节点超时、网络分区、重试策略等 |

#### 适用场景
Redlock适合对数据一致性要求极高的核心业务（如金融交易、库存扣减），非核心业务建议使用主从+哨兵架构（性价比更高）。

## 五、Redis分布式锁的实战最佳实践

### 5.1 锁的粒度设计：细粒度优先

**原则**：锁的粒度越细，并发度越高（减少锁竞争）。  
- 反例：使用`lock:stock`作为锁名称，所有商品的库存操作共享一把锁，并发时会严重阻塞。  
- 正例：使用`lock:stock:{productId}`（如`lock:stock:1001`），每个商品独立一把锁，不同商品的操作互不影响。

**进阶**：结合业务场景进一步细化，如`lock:order:{userId}`（用户维度的订单锁）、`lock:payment:{orderId}`（订单维度的支付锁）。

### 5.2 过期时间设置：动态适配业务

- **不能太短**：需大于业务执行的最大耗时（如业务最长执行20秒，过期时间至少设为30秒），避免锁提前释放。  
- **不能太长**：若线程崩溃，锁需等待过期才能释放，影响可用性（结合看门狗机制可动态调整）。  
- **推荐值**：10-30秒，配合看门狗自动续约（如Redisson的默认配置）。

### 5.3 避免死锁的关键措施

1. **强制设置过期时间**：即使看门狗失效，锁也能自动释放（兜底机制）。  
2. **释放锁放在finally块**：确保业务成功执行或异常时都能释放锁，示例：
```
   RLock lock = redissonClient.getLock(lockKey);
   try {
       lock.lock(30, TimeUnit.SECONDS);
       // 执行业务
   } finally {
       if (lock.isHeldByCurrentThread()) {
           lock.unlock();  // 确保释放
       }
   }
```
3. **避免锁嵌套层级过多**：如需获取多把锁，按固定顺序获取（如按锁名称字典序），防止循环等待（如线程A持有锁1等锁2，线程B持有锁2等锁1）。

### 5.4 Redis部署方案选择

| 场景 | 部署方案 | 优势 | 适用业务 |
|------|----------|------|----------|
| 简单场景 | 单节点Redis | 部署简单，性能高 | 非核心业务（如缓存更新），可容忍极低概率的锁失效 |
| 一般场景 | 主从+哨兵 | 高可用（自动故障转移），兼顾性能 | 大部分业务（如普通订单、用户信息更新） |
| 核心场景 | Redlock集群（3节点） | 无单点故障，锁安全性极高 | 金融交易、库存扣减等核心业务，不容忍锁失效 |

## 六、总结

Redis分布式锁是解决分布式系统并发安全的重要工具，其设计需兼顾互斥性、安全性、可用性和性能。基础实现依赖`SET NX EX`命令和Lua脚本，可满足简单场景；针对锁超时、可重入性和高可用问题，可通过看门狗机制、Hash结构重入设计和Redlock算法优化。

在实战中，需根据业务场景选择合适的锁粒度、过期时间和部署方案，同时通过非阻塞获取、失败重试等策略提升并发性能。Redisson等成熟框架已封装了上述优化，建议优先使用框架而非重复造轮子，以减少潜在风险。