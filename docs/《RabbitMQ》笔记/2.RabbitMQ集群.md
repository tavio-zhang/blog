---
title: RabbitMQ集群
date: 2023-07-02 19:10:11
permalink: /pages/5d4dae/
categories:
  - 《RabbitMQ》笔记
tags:
  - RabbitMQ集群
author: 
  name: Tavio
  link: https://github.com/tavio-zhang
---

RabbitMQ作为主流的消息中间件，核心作用是实现消息的可靠中转。在单点架构中，一旦节点宕机，会直接导致消息服务不可用，同时存在存储容量上限、连接数瓶颈等问题。为解决这些局限，RabbitMQ集群通过多节点协同，实现了**高可用性**（避免单点故障）、**负载均衡**（分散连接压力）和**扩展性**（按需增减节点），成为生产环境的必备方案。

## 一、集群核心概念解析

### 1.1 数据分类：集群同步的基础

RabbitMQ集群中存在两类关键数据，其存储和同步逻辑直接影响集群可靠性：

- **元数据（Metadata）**  
  集群的基础配置信息，包括：  
  - 队列配置：名称、是否持久化、自动删除策略、绑定的交换机/路由键  
  - 交换机配置：类型（Direct/Topic/Fanout）、是否持久化、绑定关系  
  - 用户权限、vhost配置等集群级别的管理信息  
  元数据是集群正常运行的“骨架”，所有节点必须保持一致。

- **消息数据（Message Data）**  
  队列中实际流转的消息内容及状态，包括：  
  - 消息体（Payload）、消息属性（优先级、过期时间、路由键等）  
  - 消息状态（未消费、已消费、待确认）  
  - 消费进度（消费者的ack状态、预取计数等）  
  消息数据的存储策略由队列类型（普通队列/镜像队列）和节点类型（磁盘/内存节点）共同决定。

### 1.2 节点类型：性能与可靠性的平衡

RabbitMQ集群节点分为**磁盘节点**和**内存节点**，二者分工明确，协同支撑集群能力：

#### 1.2.1 磁盘节点：可靠性核心

- **核心作用**：保障数据不丢失，是集群的“基石”。  
- **存储逻辑**：  
  - 元数据：实时持久化到磁盘（`mnesia`数据库文件），同时缓存到内存（加速查询）。  
  - 消息数据：  
    - 持久化消息：先写入**预写日志（WAL）** 确保不丢失，再异步整理到队列数据文件（`.msg`），最终落地磁盘。  
    - 非持久化消息：仅存储在内存（与内存节点一致），但仍会同步到其他磁盘节点。  
- **部署要求**：集群中至少需要1个磁盘节点（生产环境推荐2个，避免单磁盘节点宕机导致元数据无法同步）。

#### 1.2.2 内存节点：性能加速器

- **核心作用**：提升集群处理效率，分担连接压力。  
- **存储逻辑**：  
  - 元数据：仅存储在内存（查询速度比磁盘节点快10-100倍），依赖磁盘节点同步恢复（节点启动时从磁盘节点拉取元数据）。  
  - 消息数据：  
    - 持久化消息：临时存储在内存+容器临时磁盘（未挂载数据卷），最终需同步到磁盘节点才能保证不丢失。  
    - 非持久化消息：仅存于内存，节点重启后丢失。  
- **注意事项**：  
  - 内存节点≠“消息不写磁盘”：持久化消息的可靠性依赖磁盘节点，内存节点仅做临时缓存。  
  - 不推荐作为镜像队列主节点：元数据仅存内存，宕机后恢复可能导致不一致（建议通过`ha-promote-order=disc`优先选磁盘节点为主）。

### 1.3 镜像队列：解决队列单点故障

RabbitMQ集群节点默认是平等关系（无主从），但普通队列仅存储在创建它的节点上（其他节点仅同步元数据），存在单点风险。**镜像队列**通过“1主多从”架构解决此问题：

- **核心特性**：  
  - 队列元数据和消息数据同步到集群中多个节点（主节点+从节点）。  
  - 主节点负责处理所有消息操作（收发、确认、状态变更），并实时同步到从节点。  
  - 从节点实时同步主节点数据，主节点宕机时自动参与新主选举。

- **同步范围**：通过策略指定（见“实战配置”部分），支持：  
  - 同步到所有节点（`ha-mode=all`）  
  - 同步到指定数量节点（`ha-mode=exactly`，推荐与磁盘节点数量匹配）  
  - 同步到指定节点（`ha-mode=node`）

- **选举机制**：主节点宕机后，从节点按优先级选举新主：  
  1. 优先选择磁盘节点（通过`ha-promote-order=disc`配置）；  
  2. 若均为内存节点，按节点启动时间（最早启动的优先）。

## 二、集群工作原理：消息全生命周期

### 2.1 消息生产流程

1. **连接建立**：生产者通过负载均衡器（HAProxy/Nginx）连接集群任意节点，建立TCP连接和AMQP通道。  
2. **消息路由**：  
   - 若连接主节点：直接接收消息，验证路由有效性（匹配交换机+路由键）。  
   - 若连接从节点：从节点通过本地元数据查询队列主节点，将消息转发给主节点（自身仅维持连接，分担压力）。  
3. **主节点处理**：  
   - 验证通过后，将消息缓存到内存。  
   - 若为持久化消息，触发持久化流程（写入预写日志）。  

### 2.2 消息持久化与同步

1. **主节点持久化**：  
   - 持久化消息先写入预写日志（WAL），确保主节点宕机时数据不丢失。  
   - 异步将消息整理到队列数据文件（`.msg`），完成磁盘持久化。  
2. **镜像同步**：  
   - 主节点向所有从节点发送同步请求。  
   - 磁盘从节点：缓存到内存→写入自身数据卷→返回确认。  
   - 内存从节点：缓存到内存→写入容器临时磁盘→返回确认。  
3. **生产者确认**：主节点收到所有从节点确认后，通过`publisher-confirm`机制向生产者返回成功回调。  

### 2.3 消息消费流程

1. **订阅队列**：消费者通过负载均衡连接集群任意节点，建立连接和通道，订阅目标队列。  
2. **消息获取**：  
   - 若连接主节点：主节点从本地队列取数据，推送给消费者（或消费者拉取）。  
   - 若连接从节点：从节点向主节点请求消息，主节点将消息发送给从节点，再由从节点转发给消费者（分担主节点连接压力）。  
3. **消费确认**：  
   - 消费者处理完成后发送`basicAck`确认（连接从节点时，确认标识由从节点转发给主节点）。  
   - 主节点更新消息状态为“已消费”，并同步状态到所有从节点，所有节点删除对应消息。  

## 三、集群类型对比：普通集群vs镜像集群

| 维度                | 普通集群                          | 镜像集群                          |
|---------------------|-----------------------------------|-----------------------------------|
| 数据同步范围        | 仅元数据同步，消息数据仅存创建节点 | 元数据+消息数据同步到多节点       |
| 单点故障风险        | 队列所在节点宕机则队列不可用      | 主节点宕机后从节点自动切换，无感知 |
| 性能                | 消息仅存单节点，写入/读取效率高   | 多节点同步开销，性能略低          |
| 适用场景            | 非核心业务，允许短暂不可用        | 核心业务，需高可用性              |
| 存储成本            | 低（单节点存储）                  | 高（多节点冗余存储）              |

## 四、集群部署与实战配置

### 4.1 集群搭建前提

- **Erlang Cookie一致**：RabbitMQ基于Erlang集群，所有节点需使用相同的Cookie（`/var/lib/rabbitmq/.erlang.cookie`），否则无法通信。  
- **网络互通**：节点间需开放端口（4369：Erlang分布式端口，5672：AMQP端口，25672：节点间通信端口）。  

### 4.2 Java客户端连接集群

通过负载均衡器（如HAProxy）统一入口，客户端只需连接负载均衡地址，无需关心具体节点：

```
// Spring AMQP配置示例
@Configuration
public class RabbitMQConfig {
    @Bean
    public ConnectionFactory connectionFactory() {
        CachingConnectionFactory factory = new CachingConnectionFactory();
        // 负载均衡器地址（替代直接连接单个节点）
        factory.setAddresses("192.168.1.100:5672"); 
        factory.setUsername("admin");
        factory.setPassword("admin");
        factory.setVirtualHost("/");
        // 启用生产者确认机制
        factory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED);
        return factory;
    }
}
```

### 4.3 镜像队列策略配置

通过`rabbitmqctl`创建策略，自动匹配符合规则的队列并转为镜像队列：

```
# 进入磁盘节点容器
docker exec -it rabbitmq-disk1 bash

# 创建镜像队列策略（推荐配置）
rabbitmqctl set_policy \
  --apply-to queues \        # 仅应用于队列
  ha-disk-2 \                # 策略名称（2个磁盘节点同步）
  "^ha\." \                  # 队列匹配规则（以ha.开头的队列）
  '{"ha-mode":"exactly",     # 同步到指定数量节点
    "ha-params":2,           # 同步到2个节点（与磁盘节点数量一致）
    "ha-promote-order":"disc", # 优先磁盘节点为主
    "ha-sync-mode":"automatic"}' # 自动同步
```

#### 关键参数详解：

- `ha-mode`：镜像范围  
  - `all`：同步到所有节点（不推荐，内存节点重启易丢失数据）。  
  - `exactly`：同步到`ha-params`指定数量的节点（推荐，值=磁盘节点数）。  
  - `node`：同步到指定节点（如`["rabbit@disk1", "rabbit@disk2"]`）。  

- `ha-sync-mode`：同步方式  
  - `automatic`：队列创建或新增节点时自动同步所有消息（适合小队列）。  
  - `manual`：需手动执行`sync_queue 队列名`（适合大队列，避免同步阻塞）。  

## 五、最佳实践与注意事项

1. **节点规划**：2个磁盘节点（保证元数据可靠性）+ N个内存节点（分担连接压力，N根据并发量调整）。  
2. **队列命名**：通过统一前缀（如`ha.`）匹配镜像策略，避免漏配。  
3. **消息持久化**：核心消息务必开启持久化（`deliveryMode=2`），配合磁盘节点确保不丢失。  
4. **避免误区**：  
   - 内存节点并非“更安全”：其消息可靠性依赖磁盘节点同步，不可单独部署。  
   - 镜像队列不替代持久化：同步仅解决节点故障，持久化解决磁盘损坏。  

通过合理设计节点类型、配置镜像策略，RabbitMQ集群可在可靠性与性能间取得平衡，为分布式系统提供稳定的消息中转能力。