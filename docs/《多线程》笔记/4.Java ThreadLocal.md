---
title: Java ThreadLocal
date: 2022-04-13 19:09:12
permalink: /pages/f64919/
categories:
  - 《多线程》笔记
tags:
  - Java ThreadLocal
author: 
  name: Tavio
  link: https://github.com/tavio-zhang
---

在多线程编程中，共享变量的线程安全问题始终是核心挑战：  
- 加锁（如 `synchronized` 或 `Lock`）虽能保证安全，但会导致线程阻塞，牺牲性能；  
- 若通过方法参数传递变量，多层调用时会造成代码冗余，可读性下降。  

**ThreadLocal 是 JDK 提供的线程隔离工具**，其核心能力是让每个线程持有变量的独立副本，从而彻底避免多线程对共享变量的竞态访问。简单来说：  
- 线程 A 操作的变量副本仅属于 A，线程 B 操作的副本仅属于 B；  
- 线程间的变量修改互不干扰，无需加锁即可保证线程安全。  

## 一、ThreadLocal 的核心原理
ThreadLocal 实现线程隔离的核心设计是：**让每个线程持有专属的 `ThreadLocalMap`，以 ThreadLocal 实例为 key 存储变量副本**。  

可以理解为：  
- 每个线程（`Thread`）都有一个“储物柜”（`ThreadLocalMap`）；  
- ThreadLocal 是“钥匙”，通过钥匙可在当前线程的储物柜中存取“物品”（变量副本）；  
- 不同线程的储物柜相互独立，因此变量副本自然隔离。  

## 二、内部结构详解
ThreadLocal 的隔离能力依赖于 `Thread`、`ThreadLocalMap`、`Entry` 三者的协作，其关系如下：  
```
Thread (线程)
├─ threadLocals: ThreadLocalMap (普通变量储物柜，默认null)
│  └─ Entry[] (数组，存储键值对)
│     └─ Entry: 
│        ├─ key: WeakReference<ThreadLocal<?>> (ThreadLocal的弱引用)
│        └─ value: Object (线程本地变量副本)
└─ inheritableThreadLocals: ThreadLocalMap (可继承变量储物柜，默认null)
```

### 2.1 Thread 类的关键属性
每个 `Thread` 实例内置两个 `ThreadLocalMap` 类型的属性，用于存储线程本地变量：  
```
public class Thread implements Runnable {
    // 存储普通 ThreadLocal 变量副本（核心）
    ThreadLocal.ThreadLocalMap threadLocals = null;
    // 存储 InheritableThreadLocal 变量副本（支持子线程继承父线程变量）
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
}
```
- 这两个属性默认值为 `null`，**仅在首次调用 ThreadLocal 的 `set()` 或 `get()` 方法时才会初始化**；  
- 线程销毁时，这两个 `ThreadLocalMap` 会被回收，避免全局 Map 导致的内存浪费。  

### 2.2 ThreadLocalMap：线程专属的 Map
`ThreadLocalMap` 是 ThreadLocal 的静态内部类，是专为线程本地存储设计的轻量级 Map，与 HashMap 相比有显著差异：  

| 特性                | ThreadLocalMap                | HashMap                        |
|---------------------|-------------------------------|--------------------------------|
| 底层结构            | 数组（`Entry[]`）             | 数组 + 链表/红黑树             |
| 哈希冲突解决        | 线性探测法（依次向后找空位）  | 链表法（冲突元素链成链表）     |
| 扩容机制            | 初始容量 16，阈值为 2/3，扩容翻倍 | 初始容量 16，负载因子 0.75，扩容翻倍 |

**线性探测法的细节**：  
当计算的数组索引位置已被占用时，会依次检查下一个索引，直到找到空位。这种设计更适合线程本地存储的低冲突场景（一个线程通常不会有太多 ThreadLocal 变量）。  

### 2.3 Entry：弱引用 Key 与强引用 Value
`Entry` 是 `ThreadLocalMap` 的存储单元，其设计直接影响内存安全性：  
- **Key**：对 ThreadLocal 实例的弱引用（`WeakReference<ThreadLocal<?>>`）；  
- **Value**：对变量副本的强引用（`Object`）。  

**为什么 Key 用弱引用？**  
若 Key 是强引用，即使 ThreadLocal 外部强引用被释放（如 `local = null`），Key 仍会强引用 ThreadLocal，导致其无法被 GC 回收，造成 ThreadLocal 实例本身的内存泄漏。弱引用可保证 ThreadLocal 实例在无外部强引用时被及时回收。  

## 三、核心方法工作流程
ThreadLocal 本身不存储变量，仅通过 `set()`、`get()`、`remove()` 方法操作当前线程的 `ThreadLocalMap`，具体流程如下：  

### 3.1 set(T value)：设置变量副本
```
public void set(T value) {
    // 1. 获取当前线程
    Thread t = Thread.currentThread();
    // 2. 获取线程的 ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        // 3. 若 Map 存在，以当前 ThreadLocal 为 key 存入 value
        map.set(this, value);
    } else {
        // 4. 若 Map 不存在，初始化 Map 并存入 value
        createMap(t, value);
    }
}
```

### 3.2 get()：获取变量副本
```
public T get() {
    // 1. 获取当前线程
    Thread t = Thread.currentThread();
    // 2. 获取线程的 ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        // 3. 若 Map 存在，以当前 ThreadLocal 为 key 查找 Entry
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    // 4. 若 Map 不存在或 key 未找到，初始化 value 并返回
    return setInitialValue();
}
```

### 3.3 remove()：移除变量副本
```
public void remove() {
    // 1. 获取当前线程的 ThreadLocalMap
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null) {
        // 2. 移除当前 ThreadLocal 对应的 Entry
        m.remove(this);
    }
}
```

## 四、内存泄漏风险与避免
ThreadLocal 的内存泄漏并非单一原因导致，而是 **Entry 引用设计、线程生命周期、未手动清理** 三者叠加的结果。  

### 4.1 内存泄漏的产生过程
1. **正常状态**：  
   若 ThreadLocal 有外部强引用（如 `static ThreadLocal local = new ThreadLocal()`），Entry 的 Key（弱引用）指向 ThreadLocal，且 ThreadLocal 被外部强引用持有，GC 不会回收 Key。Value 可正常访问，无泄漏风险。  

2. **风险状态**：  
   若外部强引用被释放（如 `local = null`，或 ThreadLocal 是局部变量），Entry 的 Key 仅为弱引用，GC 会回收 Key（Key 变为 `null`）。但 Value 仍被 `Thread -> ThreadLocalMap -> Entry -> Value` 的强引用链关联，若线程长期存活（如线程池中的核心线程），Value 无法被回收，最终导致内存泄漏。  

3. **被动清理机制的局限性**：  
   `ThreadLocalMap` 会在 `get()`/`set()`/`remove()` 时扫描并清理 Key 为 `null` 的 Entry，但该机制是被动触发的。若线程长期存活且不再调用这些方法，清理逻辑永远不会执行，脏 Entry 会持续占用内存。  

### 4.2 如何避免内存泄漏？
- **主动调用 `remove()` 方法**：在业务代码结束后（如请求处理完成、任务执行结束），手动调用 `threadLocal.remove()`，移除 Entry 以切断 Value 的强引用链。  
- **避免使用长生命周期线程**：若必须使用（如线程池），务必在任务结束时清理 ThreadLocal 变量。  
- **慎用局部 ThreadLocal 变量**：局部变量在方法结束后会被回收，可能导致 Key 提前变为 `null`，增加泄漏风险。  

## 五、InheritableThreadLocal：支持线程继承的扩展
`InheritableThreadLocal` 是 ThreadLocal 的子类，用于解决“子线程需要访问父线程本地变量”的场景（如日志追踪中的 `traceId` 传递）。  

### 核心特性：
- 变量存储在 `Thread` 的 `inheritableThreadLocals` 中，而非 `threadLocals`；  
- 子线程创建时，会自动复制父线程 `inheritableThreadLocals` 中的变量副本（浅拷贝）。  

### 注意事项：
- 若变量是可变对象（如集合），子线程修改会影响父线程（因浅拷贝共享对象引用）；  
- 线程池场景下，子线程复用可能导致变量继承异常，需结合业务手动重置。  

## 六、ThreadLocal  vs 同步机制
| 场景                | ThreadLocal                  | 同步机制（synchronized/Lock） |
|---------------------|------------------------------|--------------------------------|
| 核心思想            | 线程隔离（每个线程有独立副本） | 互斥访问（同一时间仅一个线程操作） |
| 性能                | 无锁，性能高                  | 可能阻塞，性能较低              |
| 内存开销            | 线程数 × 变量副本数           | 无额外内存开销                  |
| 适用场景            | 变量需线程私有（如用户会话）   | 需共享变量且保证一致性（如计数器） |

## 七、实践建议
1. **优先声明为 `static`**：减少 ThreadLocal 实例数量，降低内存开销（一个 ThreadLocal 可被多个线程共享作为 key）。  
2. **务必手动 `remove()`**：尤其是线程池环境，避免线程复用导致的变量污染和内存泄漏。  
3. **避免存储大对象**：每个线程持有副本会增加内存消耗，大对象可能导致 OOM。  
4. **慎用 `InheritableThreadLocal`**：明确父子线程变量传递需求时使用，避免浅拷贝带来的副作用。  

## 总结
ThreadLocal 是解决线程隔离问题的高效工具，其核心通过线程专属的 `ThreadLocalMap` 实现变量副本存储。