---
title: Java CompletableFuture
date: 2024-11-13 09:49:51
permalink: /pages/13f871/
categories:
  - 《多线程》笔记
tags:
  - Java CompletableFuture
author: 
  name: Tavio
  link: https://github.com/tavio-zhang
---

异步编程是提升系统性能与响应速度的核心手段。JDK 8引入的`CompletableFuture`彻底改变了传统异步编程的模式，它不仅解决了`Future`接口的固有缺陷，更提供了强大的任务编排能力，让复杂异步流程的实现变得简洁而高效。

### 为什么需要CompletableFuture？

在JDK 8之前，`Future`接口是处理异步任务的主要方式，但它在面对复杂业务场景时暴露了明显局限性：

- **阻塞式结果获取**：`get()`方法会强制阻塞当前线程，直到任务完成，无法实现真正的异步回调，严重影响并发性能。
- **任务依赖管理复杂**：多个异步任务的串行/并行依赖需要手动控制（如A完成后执行B），代码耦合度高且易出错。
- **异常处理缺失**：仅能在`get()`时捕获异常，无法在任务执行过程中异步处理，灵活性极差。
- **任务组合能力弱**：多个并行任务的结果合并需要编写大量模板代码，逻辑繁琐。

`CompletableFuture`针对这些痛点设计，核心优势包括：

- **非阻塞回调机制**：通过`thenAccept`、`thenApply`等API实现结果的异步消费，避免线程阻塞。
- **灵活的任务编排**：支持串行、并行、竞速、批量等多种任务组合方式，轻松实现复杂流程。
- **完善的异常处理**：提供`exceptionally`、`handle`等API，支持异常的异步捕获与处理。
- **自定义线程池**：可摆脱默认`ForkJoinPool`的资源竞争问题，更贴合生产环境需求。
- **链式编程支持**：与Stream API风格一致，代码可读性与可维护性大幅提升。

## 快速入门

`CompletableFuture`提供了两类静态方法创建异步任务，核心区别在于是否需要返回值。

### 1. 核心创建方法

| 方法         | 特点                          | 适用场景                                  |
|--------------|-------------------------------|-------------------------------------------|
| `supplyAsync` | 有返回值，返回`CompletableFuture<T>` | 查询数据库、调用远程接口等需要结果的任务  |
| `runAsync`   | 无返回值，返回`CompletableFuture<Void>` | 日志记录、缓存更新等无需结果的任务        |

#### 示例1：默认线程池创建任务

默认情况下，`supplyAsync`和`runAsync`会使用JVM共享的`ForkJoinPool.commonPool()`，适用于简单场景：

```
public static void main(String[] args) throws Exception {
    // 有返回值任务
    CompletableFuture<String> resultFuture = CompletableFuture.supplyAsync(() -> {
        try {
            // 模拟耗时操作（如查询数据库）
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "查询结果";
    });

    // 无返回值任务
    CompletableFuture<Void> voidFuture = CompletableFuture.runAsync(() -> {
        try {
            // 模拟耗时操作（如日志记录）
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("日志记录完成");
    });

    // 阻塞获取结果（仅示例用，生产环境不推荐）
    System.out.println(resultFuture.get()); // 输出：查询结果
    voidFuture.get(); // 等待任务完成
}
```

#### 示例2：自定义线程池创建任务

生产环境中，**必须使用自定义线程池**（避免共享线程池的资源竞争）。线程池配置建议：

- 核心线程数：根据CPU核心数或业务场景设置（如`Runtime.getRuntime().availableProcessors() + 1`）
- 队列选择：使用有界队列（如`ArrayBlockingQueue`）避免内存溢出
- 拒绝策略：结合业务设置（如`CallerRunsPolicy`在高负载时降级）

```
// 自定义线程池（生产环境推荐）
private static final ThreadPoolExecutor CUSTOM_EXECUTOR = new ThreadPoolExecutor(
        2, // 核心线程数
        4, // 最大线程数
        60, TimeUnit.SECONDS, // 空闲线程存活时间
        new ArrayBlockingQueue<>(10), // 有界队列
        new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略：让提交任务的线程执行
);

public static void main(String[] args) throws Exception {
    // 使用自定义线程池执行有返回值任务
    CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "自定义线程池执行结果";
    }, CUSTOM_EXECUTOR);

    // 非阻塞处理结果（推荐）
    future.thenAccept(result -> System.out.println("异步处理：" + result));

    // 主线程继续执行其他逻辑
    System.out.println("主线程无需等待");

    // 关闭线程池（实际应用中应在程序退出时关闭）
    CUSTOM_EXECUTOR.shutdown();
}
```

### 2. 结果获取方式对比

| 方式              | 特点                                  | 适用场景                          | 推荐度 |
|-------------------|---------------------------------------|-----------------------------------|--------|
| `get()`           | 阻塞当前线程，抛出受检异常（需捕获）  | 必须同步获取结果的场景            | 不推荐 |
| `join()`          | 阻塞当前线程，抛出非受检异常（无需捕获） | 必须同步获取结果且简化异常处理    | 不推荐 |
| `thenAccept()`    | 异步消费结果，非阻塞，无返回值        | 仅需处理结果无需后续计算          | 推荐   |
| `whenComplete()`  | 异步处理结果+异常，非阻塞，不改变结果  | 需要处理结果且记录日志/释放资源   | 推荐   |

**注意**：尽量避免使用`get()`和`join()`，它们会阻塞线程，违背异步编程初衷。优先使用非阻塞的回调方法。

## 任务编排核心技巧

`CompletableFuture`的精髓在于灵活的任务编排，通过API可将多个异步任务组合成复杂流程，无需手动管理依赖关系。

### 1. 串行编排（A完成后执行B）

适用于任务存在依赖关系的场景（如B需要A的结果作为输入）。

| API           | 特点                                  | 示例场景                          |
|---------------|---------------------------------------|-----------------------------------|
| `thenApply`   | 接收前序结果，返回新结果（有返回值）  | A查询商品原价，B计算折扣价        |
| `thenAccept`  | 接收前序结果，消费结果（无返回值）    | A查询价格后，B打印价格            |
| `thenRun`     | 不依赖前序结果，执行后续操作          | A完成后，B记录操作日志            |

**示例**：

```
// 任务1：查询商品原价
CompletableFuture<Double> priceFuture = CompletableFuture.supplyAsync(() -> {
    System.out.println("查询原价（线程：" + Thread.currentThread().getName() + "）");
    return 99.99;
}, CUSTOM_EXECUTOR);

// 任务2：基于原价计算折扣价（依赖任务1结果）
CompletableFuture<Double> discountFuture = priceFuture.thenApply(price -> {
    System.out.println("计算折扣（线程：" + Thread.currentThread().getName() + "）");
    return price * 0.8; // 8折
});

// 任务3：消费折扣价结果（依赖任务2结果）
discountFuture.thenAccept(finalPrice -> {
    System.out.println("最终价格：" + finalPrice + "（线程：" + Thread.currentThread().getName() + "）");
});

// 任务4：不依赖前序结果，执行收尾操作
priceFuture.thenRun(() -> {
    System.out.println("价格查询流程结束（线程：" + Thread.currentThread().getName() + "）");
});
```

**说明**：默认情况下，后续任务会复用前序任务的线程（若前序已完成则使用当前线程），也可通过`thenApplyAsync`等方法强制使用异步线程池。

### 2. 并行合并（A和B都完成后合并结果）

适用于需要并行执行多个独立任务，最终合并结果的场景（如查询商品信息+查询库存，合并后展示）。

| API              | 特点                                  |
|------------------|---------------------------------------|
| `thenCombine`    | 合并两个任务结果，返回新结果（有返回值） |
| `thenAcceptBoth` | 消费两个任务结果，无返回值            |

**示例**：

```
// 任务1：查询商品名称
CompletableFuture<String> nameFuture = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); }
    return "iPhone 15";
}, CUSTOM_EXECUTOR);

// 任务2：查询商品库存
CompletableFuture<Integer> stockFuture = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(800); } catch (InterruptedException e) { e.printStackTrace(); }
    return 100;
}, CUSTOM_EXECUTOR);

// 合并结果：商品名称 + 库存
nameFuture.thenCombine(stockFuture, (name, stock) -> {
    return "商品：" + name + "，库存：" + stock;
}).thenAccept(combinedResult -> {
    System.out.println("合并结果：" + combinedResult); // 输出：商品：iPhone 15，库存：100
});
```

### 3. 竞速编排（A或B任意一个完成后处理）

适用于多渠道获取数据，取最快结果的场景（如从多个CDN获取资源，选响应最快的）。

| API               | 特点                                  |
|-------------------|---------------------------------------|
| `applyToEither`   | 任意任务完成后，处理结果并返回新值    |
| `acceptEither`    | 任意任务完成后，消费其结果            |

**示例**：

```
// 渠道1：淘宝查询价格（耗时800ms）
CompletableFuture<Double> taobaoFuture = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(800); } catch (InterruptedException e) { e.printStackTrace(); }
    return 8999.0;
}, CUSTOM_EXECUTOR);

// 渠道2：京东查询价格（耗时500ms）
CompletableFuture<Double> jdFuture = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); }
    return 8990.0;
}, CUSTOM_EXECUTOR);

// 取最快返回的价格
taobaoFuture.acceptEither(jdFuture, price -> {
    System.out.println("最快价格：" + price); // 输出：8990.0（京东更快）
});
```

### 4. 批量编排（多个任务统一处理）

适用于批量执行异步任务，等待全部完成或任意一个完成后统一处理的场景。

| API       | 特点                                  | 适用场景                          |
|-----------|---------------------------------------|-----------------------------------|
| `allOf`   | 等待所有任务完成，返回`CompletableFuture<Void>` | 批量任务全部完成后汇总结果        |
| `anyOf`   | 等待任意一个任务完成，返回第一个结果  | 多任务取第一个完成的结果          |

**示例：allOf（等待全部完成）**

```
// 批量任务：查询3个商品的价格
CompletableFuture<Double> p1 = CompletableFuture.supplyAsync(() -> 1000.0, CUSTOM_EXECUTOR);
CompletableFuture<Double> p2 = CompletableFuture.supplyAsync(() -> 2000.0, CUSTOM_EXECUTOR);
CompletableFuture<Double> p3 = CompletableFuture.supplyAsync(() -> 3000.0, CUSTOM_EXECUTOR);

// 等待所有任务完成（返回Void，需手动获取子任务结果）
CompletableFuture<Void> allDone = CompletableFuture.allOf(p1, p2, p3);

// 所有任务完成后汇总总价
allDone.thenRun(() -> {
    try {
        double total = p1.get() + p2.get() + p3.get();
        System.out.println("商品总价：" + total); // 输出：6000.0
    } catch (Exception e) {
        e.printStackTrace();
    }
});
```

**示例：anyOf（等待任意一个完成）**

```
// 3个任务分别模拟不同响应时间
CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }
    return "任务1完成";
}, CUSTOM_EXECUTOR);

CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); }
    return "任务2完成";
}, CUSTOM_EXECUTOR);

CompletableFuture<String> task3 = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); }
    return "任务3完成";
}, CUSTOM_EXECUTOR);

// 等待第一个完成的任务
CompletableFuture<Object> firstDone = CompletableFuture.anyOf(task1, task2, task3);
firstDone.thenAccept(result -> {
    System.out.println("第一个完成的任务：" + result); // 输出：任务2完成
});
```

## 异常处理机制

异步任务的异常处理至关重要，`CompletableFuture`提供了三类核心API覆盖不同场景。

### 1. `exceptionally`：异常兜底（返回默认值）

适用于任务失败时需要返回兜底结果的场景（如查询失败返回默认价格）。

```
CompletableFuture<Double> priceFuture = CompletableFuture.supplyAsync(() -> {
    // 模拟任务异常（除以0）
    int error = 10 / 0;
    return 8999.0;
}, CUSTOM_EXECUTOR);

// 异常时返回默认值0.0
priceFuture.exceptionally(e -> {
    System.err.println("异常原因：" + e.getMessage()); // 输出：/ by zero
    return 0.0; // 兜底值
}).thenAccept(price -> {
    System.out.println("最终价格：" + price); // 输出：0.0
});
```

### 2. `handle`：统一处理结果与异常

适用于无论任务成功/失败都需要处理的场景（如成功计算折扣，失败返回默认值）。

```
CompletableFuture<Double> priceFuture = CompletableFuture.supplyAsync(() -> {
    // 模拟任务异常
    int error = 10 / 0;
    return 8999.0;
}, CUSTOM_EXECUTOR);

// handle接收两个参数：result（成功时非null）、e（失败时非null）
priceFuture.handle((result, e) -> {
    if (e != null) {
        System.err.println("任务失败：" + e.getMessage());
        return 0.0; // 异常兜底
    }
    return result * 0.9; // 成功时计算9折
}).thenAccept(finalPrice -> {
    System.out.println("最终价格：" + finalPrice); // 输出：0.0
});
```

### 3. `whenComplete`：收尾操作（不改变结果）

适用于任务完成后需要记录日志、释放资源等收尾操作，不影响原有结果流转。

```
CompletableFuture<Double> priceFuture = CompletableFuture.supplyAsync(() -> {
    return 8999.0; // 正常返回结果
}, CUSTOM_EXECUTOR);

// 无论成功/失败都执行收尾操作
priceFuture.whenComplete((result, e) -> {
    if (e == null) {
        System.out.println("任务成功，结果：" + result); // 输出：任务成功，结果：8999.0
    } else {
        System.err.println("任务失败：" + e.getMessage());
    }
}).thenApply(price -> price * 0.9) // 继续处理结果（不受whenComplete影响）
  .thenAccept(discountPrice -> {
      System.out.println("折扣价：" + discountPrice); // 输出：8099.1
  });
```

### 异常处理最佳实践

- **异常传递**：前序任务的异常会传递到后续任务，若中间未处理，最终会在`get()`/`join()`时抛出。
- **避免异常吞噬**：务必为每个关键任务添加异常处理（至少在链路末尾添加），防止异常被静默忽略。
- **多层处理**：复杂链路中可在不同阶段添加异常处理（如局部异常局部处理，全局异常统一兜底）。

## 实战场景示例：电商下单流程

假设一个简化的电商下单流程：

1. 查询商品信息（名称、原价）
2. 检查库存是否充足
3. 计算折扣后价格（依赖商品原价）
4. 生成订单（依赖商品信息、库存、最终价格）

```
// 1. 查询商品信息（名称+原价）
CompletableFuture<Product> productFuture = CompletableFuture.supplyAsync(() -> {
    System.out.println("查询商品信息");
    return new Product("iPhone 15", 8999.0);
}, CUSTOM_EXECUTOR);

// 2. 检查库存
CompletableFuture<Integer> stockFuture = CompletableFuture.supplyAsync(() -> {
    System.out.println("检查库存");
    return 100; // 库存100
}, CUSTOM_EXECUTOR);

// 3. 计算折扣价（依赖商品原价）
CompletableFuture<Double> discountFuture = productFuture.thenApply(product -> {
    System.out.println("计算折扣价（8折）");
    return product.getPrice() * 0.8;
});

// 4. 合并结果生成订单（依赖商品信息、库存、折扣价）
CompletableFuture<Order> orderFuture = productFuture.thenCombine(stockFuture, (product, stock) -> {
    return new OrderTemp(product, stock); // 临时对象存储中间结果
}).thenCombine(discountFuture, (temp, discountPrice) -> {
    System.out.println("生成订单");
    return new Order(
        temp.product.getName(),
        temp.stock,
        discountPrice,
        System.currentTimeMillis()
    );
});

// 处理最终订单结果
orderFuture.whenComplete((order, e) -> {
    if (e == null) {
        System.out.println("下单成功：" + order);
    } else {
        System.err.println("下单失败：" + e.getMessage());
    }
});

// 辅助类
class Product {
    private String name;
    private Double price;
    // 构造器、getter省略
}

class OrderTemp {
    Product product;
    Integer stock;
    // 构造器省略
}

class Order {
    private String productName;
    private Integer stock;
    private Double finalPrice;
    private Long createTime;
    // 构造器、toString省略
}
```

## 注意事项与最佳实践

1. **线程池管理**：
   - 生产环境必须使用自定义线程池，避免使用默认`ForkJoinPool`。
   - 线程池参数需根据业务压测调整，核心线程数不宜过大（避免上下文切换开销）。
   - 任务完成后及时关闭线程池（或通过Spring等框架管理生命周期）。

2. **避免过度异步**：
   - 简单同步任务无需强行异步化（异步有线程调度开销）。
   - 异步链路不宜过长，否则会增加调试难度。

3. **结果获取规范**：
   - 禁止在异步链路中使用`get()`/`join()`（会阻塞线程），除非确保任务已完成（如`allOf`之后）。
   - 必须使用`get()`时，建议设置超时时间（`get(1, TimeUnit.SECONDS)`），避免永久阻塞。

4. **异常处理完整性**：
   - 所有异步链路必须添加异常处理，防止异常被吞噬导致问题排查困难。
   - 复杂链路建议在关键节点添加`whenComplete`记录日志，便于追踪流程。

## 总结

`CompletableFuture`通过强大的异步编排与异常处理能力，彻底解决了传统`Future`的局限性，是Java异步编程的首选方案。

在实际开发中，需注意线程池的合理配置、避免阻塞调用、确保异常处理完整，才能充分发挥`CompletableFuture`的优势。