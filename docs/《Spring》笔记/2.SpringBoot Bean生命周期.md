---
title: Spring Boot Bean 生命周期
date: 2024-06-19 21:33:02
permalink: /pages/1c21ce/
categories:
  - 《Spring》笔记
tags:
  - Spring Boot Bean 生命周期
author: 
  name: Tavio
  link: https://github.com/tavio-zhang
---
# SpringBoot Bean生命周期全解析
在SpringBoot应用中，Bean作为核心组件，其生命周期贯穿于应用启动、运行至关闭的全过程。理解Bean的生命周期，不仅能帮助我们更合理地管理Bean的创建与销毁，还能精准定位与Bean相关的问题（如依赖注入失效、初始化逻辑执行异常等）。

## 一、Bean生命周期核心概述
SpringBoot中Bean的生命周期，本质上是Spring容器对Bean从“创建”到“销毁”的全流程管理，核心可分为**4大阶段**：
1. 初始化阶段：从Bean定义加载到Bean实例化、属性赋值；
2. 初始化后阶段：Bean初始化逻辑执行、AOP增强等；
3. 运行阶段：Bean处于可用状态，响应业务调用；
4. 销毁阶段：应用关闭时，Bean的资源清理与销毁逻辑执行。

整个生命周期的核心驱动是Spring容器（ApplicationContext），容器通过BeanDefinitionRegistry、BeanFactory、BeanPostProcessor等核心组件协同工作，完成Bean的全生命周期管理。需要注意的是，SpringBoot在Spring的基础上提供了自动配置机制，会默认注册大量内置Bean（如DataSource、DispatcherServlet等），这些内置Bean的生命周期遵循相同的规则。

## 二、Bean生命周期完整流程拆解（附核心方法与案例）
下面将按“Bean定义加载 → 实例化前 → 实例化 → 属性赋值 → 初始化前 → 初始化 → 初始化后 → 运行 → 销毁前 → 销毁”的顺序，逐阶段解析Bean生命周期的核心细节。

### 阶段1：Bean定义加载（容器启动时）
Bean生命周期的起点并非Bean的实例化，而是**Bean定义的加载与注册**。SpringBoot启动时，会通过以下步骤完成Bean定义的加载：
- 1. 扫描指定包路径（默认是主启动类所在包及其子包），通过@Component、@Service、@Controller、@Repository等注解识别Bean候选类；
- 2. 解析候选类的信息（如类名、属性、方法、依赖关系等），封装为BeanDefinition对象（Bean定义的核心载体，包含Bean的所有元数据）；
- 3. 将BeanDefinition注册到BeanDefinitionRegistry（Bean定义注册表）中，供后续BeanFactory创建Bean实例时使用。

核心组件：
- BeanDefinition：存储Bean的元数据，如Bean的类型、作用域（singleton/prototype）、初始化方法、销毁方法等；
- ClassPathBeanDefinitionScanner：SpringBoot默认的Bean定义扫描器，负责扫描并解析注解标注的类。

应用场景：若需自定义Bean扫描规则，可通过@SpringBootApplication的scanBasePackages属性指定扫描包，或实现BeanDefinitionRegistryPostProcessor接口动态注册BeanDefinition。

### 阶段2：实例化前（InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation）
当容器需要创建Bean时，会先触发**实例化前回调**，这是Bean实例化（创建对象）前的最后一个扩展点。

核心逻辑：
- 容器会遍历所有注册的InstantiationAwareBeanPostProcessor接口实现类，调用其postProcessBeforeInstantiation方法；
- 该方法的返回值为Object类型：若返回非null值，说明用户手动创建了Bean实例，容器会跳过后续的实例化、属性赋值等流程，直接使用该返回值作为Bean实例；若返回null，容器则继续执行默认的实例化流程。

案例：自定义InstantiationAwareBeanPostProcessor，实现Bean实例的手动创建
```java
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;
import org.springframework.stereotype.Component;

@Component
public class CustomInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {

    @Override
    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
        // 对指定Bean（如UserService）进行手动实例化
        if ("userService".equals(beanName)) {
            System.out.println("实例化前：手动创建UserService实例");
            return new UserService(); // 手动创建实例，跳过容器默认实例化
        }
        return null; // 其他Bean走默认流程
    }
}
```

### 阶段3：实例化（Bean的对象创建）
若实例化前的回调未返回自定义实例，容器会执行**默认的Bean实例化流程**，即通过反射创建Bean的对象实例。

核心逻辑：
- 容器根据BeanDefinition中的信息，获取Bean的构造方法（默认选择无参构造方法，若存在有参构造方法且未指定，可能触发NoSuchMethodException）；
- 通过Constructor.newInstance()方法反射创建Bean实例（此时Bean的属性尚未赋值，仅完成对象的创建）。

关键注意点：
- 单例Bean（默认作用域）：实例化后会被缓存到容器的单例池（singletonObjects）中，后续获取该Bean时直接从缓存中获取；
- 原型Bean（prototype）：每次获取Bean时都会重新执行实例化流程，不会缓存，且容器不负责原型Bean的销毁。

常见问题：若Bean类中没有无参构造方法，且未通过@Autowired指定有参构造方法的依赖注入，会导致实例化失败，抛出BeanCreationException。

### 阶段4：属性赋值（Populate Bean）
Bean实例化后，容器会对Bean的属性进行赋值（即依赖注入的核心阶段），将配置的属性值或依赖的其他Bean注入到当前Bean中。

核心逻辑：
1. 触发InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法，判断是否需要对Bean进行属性赋值（返回false则跳过属性赋值）；
2. 触发InstantiationAwareBeanPostProcessor的postProcessProperties方法，对属性值进行预处理（如类型转换、数据校验等）；
3. 容器根据BeanDefinition中的属性信息，通过反射将属性值注入到Bean实例中（支持@Value注解赋值、@Autowired/@Resource依赖注入等）。

案例：通过@Autowired实现依赖注入，属性赋值阶段的执行逻辑
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    // 属性赋值阶段，容器会将UserDao实例注入到该属性中
    @Autowired
    private UserDao userDao;

    public void queryUser() {
        userDao.query();
    }
}
```

扩展点：若需自定义属性赋值逻辑，可实现InstantiationAwareBeanPostProcessor接口，重写postProcessProperties方法（例如对敏感属性进行加密解密）。

### 阶段5：初始化前（BeanPostProcessor.postProcessBeforeInitialization）
属性赋值完成后，容器会触发**初始化前回调**，这是Bean初始化逻辑执行前的扩展点。

核心逻辑：
- 容器遍历所有注册的BeanPostProcessor接口实现类，调用其postProcessBeforeInitialization方法；
- 该方法接收两个参数：当前Bean实例（已完成属性赋值）和Bean名称，返回值为处理后的Bean实例（可对Bean进行增强或替换）；
- 典型应用：Spring的AOP功能中，对Bean的代理增强（如@Transactional注解的事务代理）就是在该阶段完成的。

案例：自定义BeanPostProcessor，在初始化前对Bean进行增强
```java
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.stereotype.Component;

@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if ("userService".equals(beanName)) {
            System.out.println("初始化前：对UserService进行增强处理");
            // 可在此处对Bean进行动态代理增强
        }
        return bean; // 返回增强后的Bean实例
    }
}
```

### 阶段6：初始化（Initialization）
初始化前回调完成后，容器会执行Bean的**初始化逻辑**，这是Bean生命周期中开发者可自定义的核心阶段之一，用于执行Bean的初始化操作（如资源初始化、数据加载等）。

初始化逻辑的执行顺序（核心重点）：
1. 执行Bean的@PostConstruct注解标注的方法（JSR-250规范，由CommonAnnotationBeanPostProcessor触发）；
2. 执行Bean实现的InitializingBean接口的afterPropertiesSet方法（Spring内置接口，直接由容器调用）；
3. 执行BeanDefinition中指定的初始化方法（如通过@Bean(initMethod = "init")或XML配置的init-method指定）。

案例：三种初始化方式的实际应用
```java
import org.springframework.beans.factory.InitializingBean;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;

@Service
public class UserService implements InitializingBean {

    @Autowired
    private UserDao userDao;

    // 1. @PostConstruct注解标注的初始化方法
    @PostConstruct
    public void postConstructInit() {
        System.out.println("初始化1：执行@PostConstruct标注的方法");
        // 初始化逻辑：如初始化缓存、加载基础数据等
    }

    // 2. InitializingBean接口的afterPropertiesSet方法
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("初始化2：执行InitializingBean的afterPropertiesSet方法");
        // 初始化逻辑：如校验依赖是否注入完成
        if (userDao == null) {
            throw new RuntimeException("UserDao依赖注入失败");
        }
    }

    // 3. 自定义初始化方法（通过@Bean指定initMethod）
    public void customInit() {
        System.out.println("初始化3：执行自定义的initMethod方法");
    }
}
```

对应的@Bean配置（若未使用@Component注解，可通过@Bean指定初始化方法）：
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class BeanConfig {

    @Bean(initMethod = "customInit")
    public UserService userService() {
        return new UserService();
    }
}
```

执行结果顺序：postConstructInit → afterPropertiesSet → customInit。

### 阶段7：初始化后（BeanPostProcessor.postProcessAfterInitialization）
Bean的初始化逻辑执行完成后，容器会触发**初始化后回调**，这是Bean创建完成前的最后一个扩展点。

核心逻辑：
- 容器再次遍历所有BeanPostProcessor实现类，调用其postProcessAfterInitialization方法；
- 该方法的返回值为最终的Bean实例，若在此处对Bean进行代理增强（如AOP的最终代理对象生成），则返回代理对象，后续容器缓存和使用的都是该代理对象。

关键区别：初始化前（postProcessBeforeInitialization）的增强是对原始Bean实例的增强，而初始化后（postProcessAfterInitialization）的增强是对完成初始化的Bean实例的增强，AOP的事务代理、日志代理等通常在此阶段完成。

### 阶段8：运行阶段（Bean可用）
经过上述所有阶段后，Bean实例已完全创建完成，被缓存到容器的单例池中（单例Bean），此时Bean处于可用状态，可响应业务层的调用。

核心特点：
- 单例Bean：整个应用生命周期内，容器只会创建一次实例，后续每次获取（如通过@Autowired注入、ApplicationContext.getBean()）都是从单例池获取同一个实例；
- 原型Bean：每次获取都会重新执行“实例化 → 属性赋值 → 初始化”流程，创建新的实例，使用完成后由JVM垃圾回收机制回收（容器不管理原型Bean的销毁）。

### 阶段9：销毁前（DestructionAwareBeanPostProcessor.postProcessBeforeDestruction）
当SpringBoot应用关闭时（如执行shutdown命令、停止Tomcat），容器会触发Bean的销毁流程，首先执行**销毁前回调**。

核心逻辑：
- 容器遍历所有注册的DestructionAwareBeanPostProcessor实现类，调用其postProcessBeforeDestruction方法；
- 该方法用于在Bean销毁前执行预处理逻辑（如资源释放前的校验、日志记录等）。

注意：DestructionAwareBeanPostProcessor是BeanPostProcessor的子接口，专门用于Bean销毁阶段的扩展。

### 阶段10：销毁阶段（Destruction）
销毁前回调完成后，容器会执行Bean的**销毁逻辑**，用于释放Bean占用的资源（如数据库连接、文件流、线程池等）。

销毁逻辑的执行顺序（核心重点）：
1. 执行Bean的@PreDestroy注解标注的方法（JSR-250规范，由CommonAnnotationBeanPostProcessor触发）；
2. 执行Bean实现的DisposableBean接口的destroy方法（Spring内置接口，由容器直接调用）；
3. 执行BeanDefinition中指定的销毁方法（如通过@Bean(destroyMethod = "destroy")或XML配置的destroy-method指定）。

案例：三种销毁方式的实际应用
```java
import org.springframework.beans.factory.DisposableBean;
import org.springframework.stereotype.Service;

import javax.annotation.PreDestroy;

@Service
public class UserService implements DisposableBean {

    // 1. @PreDestroy注解标注的销毁方法
    @PreDestroy
    public void preDestroy() {
        System.out.println("销毁1：执行@PreDestroy标注的方法");
        // 销毁逻辑：如关闭数据库连接
    }

    // 2. DisposableBean接口的destroy方法
    @Override
    public void destroy() throws Exception {
        System.out.println("销毁2：执行DisposableBean的destroy方法");
        // 销毁逻辑：如释放文件流
    }

    // 3. 自定义销毁方法（通过@Bean指定destroyMethod）
    public void customDestroy() {
        System.out.println("销毁3：执行自定义的destroyMethod方法");
        // 销毁逻辑：如关闭线程池
    }
}
```

对应的@Bean配置：
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class BeanConfig {

    @Bean(destroyMethod = "customDestroy")
    public UserService userService() {
        return new UserService();
    }
}
```

执行结果顺序：preDestroy → destroy → customDestroy。

## 三、Bean生命周期核心扩展接口总结
Spring提供了多个扩展接口，用于干预Bean生命周期的不同阶段，开发者可通过实现这些接口自定义Bean的创建与销毁逻辑。以下是核心扩展接口的汇总：

| 扩展接口 | 核心方法 | 作用阶段 | 核心作用 |
|----------|----------|----------|----------|
| InstantiationAwareBeanPostProcessor | postProcessBeforeInstantiation、postProcessAfterInstantiation、postProcessProperties | 实例化前、实例化后、属性赋值阶段 | 自定义Bean实例化、属性赋值预处理 |
| BeanPostProcessor | postProcessBeforeInitialization、postProcessAfterInitialization | 初始化前、初始化后 | Bean实例增强（如AOP代理） |
| InitializingBean | afterPropertiesSet | 初始化阶段 | Bean初始化逻辑（属性赋值后执行） |
| DisposableBean | destroy | 销毁阶段 | Bean销毁逻辑（应用关闭时执行） |
| DestructionAwareBeanPostProcessor | postProcessBeforeDestruction | 销毁前 | Bean销毁前预处理 |
| BeanDefinitionRegistryPostProcessor | postProcessBeanDefinitionRegistry | Bean定义加载阶段 | 动态注册BeanDefinition |

## 四、SpringBoot与Spring Bean生命周期的差异
SpringBoot在Spring的基础上，对Bean生命周期的管理新增了以下特性，简化了开发者的配置：
1. 自动配置机制：SpringBoot通过@EnableAutoConfiguration注解，自动扫描并注册大量内置Bean（如DataSource、RedisTemplate等），这些Bean的生命周期无需开发者手动配置，遵循默认规则；
2. 简化的Bean注册方式：除了传统的注解（@Component、@Bean），SpringBoot还支持通过Spring FactoriesLoader机制，自动加载META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中配置的Bean；
3. 嵌入式容器相关Bean：SpringBoot的嵌入式Tomcat/Jetty/Undertow容器，其核心Bean（如TomcatServletWebServerFactory）的生命周期与应用生命周期绑定，应用启动时自动初始化容器，关闭时自动销毁容器。

## 五、常见问题与注意事项
### 1. 依赖注入失败（NullPointerException）
原因：可能是在Bean的初始化方法（如@PostConstruct、afterPropertiesSet）中过早使用了依赖的Bean，而此时依赖的Bean尚未完成初始化；或Bean未被容器扫描（如未加@Component注解、扫描包路径错误）。
解决方案：确保依赖的Bean已被正确注册，若存在循环依赖，可通过@Lazy注解延迟加载，或调整初始化逻辑的执行顺序。

### 2. 初始化方法未执行
原因：Bean未被容器管理（如未加注解、手动new创建的对象）；或初始化方法的访问修饰符不是public（如private）；或@Bean注解未指定initMethod。
解决方案：确保Bean被容器扫描管理，初始化方法修饰符为public，@Bean配置时正确指定initMethod。

### 3. 销毁方法未执行
原因：应用未正常关闭（如强行kill进程，容器未触发销毁流程）；或Bean是原型作用域（容器不管理原型Bean的销毁）；或销毁方法修饰符不是public。
解决方案：通过优雅停机方式关闭应用（如执行shutdown命令），单例Bean的销毁方法修饰符为public。

### 4. 循环依赖问题
原因：两个或多个Bean相互依赖（如A依赖B，B依赖A），导致容器无法正常完成属性赋值。
解决方案：Spring默认支持单例Bean的循环依赖（通过三级缓存机制），若循环依赖的Bean是原型作用域，需通过@Lazy注解延迟加载，或重构代码解除循环依赖。

## 六、总结
SpringBoot Bean的生命周期是一个“从定义到销毁”的完整流程，核心可概括为“加载定义 → 实例化 → 属性赋值 → 初始化 → 运行 → 销毁”，每个阶段都提供了扩展接口供开发者自定义逻辑。