---
title: MyBatis Mapper动态代理
date: 2024-02-17 09:14:25
permalink: /pages/783435/
categories:
  - 《MyBatis》笔记
tags:
  - MyBatis Mapper动态代理
author: 
  name: Tavio
  link: https://github.com/tavio-zhang
---

在使用MyBatis进行开发时，我们都有一个习以为常的操作：定义一个Mapper接口（比如`UserMapper`），在接口中声明SQL相关的方法（比如`List<User> selectUserById(Long id)`），再通过XML文件或注解编写对应的SQL语句。整个过程中，我们从未为`UserMapper`接口编写过任何实现类，但却能通过`sqlSession.getMapper(UserMapper.class)`获取接口实例，进而调用方法执行SQL并得到结果。

这一“违背常理”的现象，背后的核心支撑正是**Java动态代理**技术。MyBatis通过动态代理机制，在程序运行时为Mapper接口动态生成代理对象，将接口方法调用与SQL执行逻辑巧妙关联。

## 一、先铺垫：Java动态代理的核心原理
要理解MyBatis的Mapper动态代理，首先需要掌握Java动态代理的基础——因为MyBatis的Mapper代理本质上是对JDK动态代理（默认）的封装与扩展。Java动态代理的核心作用是：在程序运行时，动态生成目标接口的代理对象，通过代理对象拦截目标接口的方法调用，执行自定义的增强逻辑（比如日志记录、权限校验、或者像MyBatis这样的SQL执行逻辑）。

### 1.1 JDK动态代理的核心要素
JDK动态代理依赖`java.lang.reflect`包下的两个核心类/接口，缺一不可：
- **InvocationHandler接口**：这是代理逻辑的核心接口，需要我们实现其`invoke(Object proxy, Method method, Object[] args)`方法。当代理对象的方法被调用时，JVM会自动将调用转发到该方法中，其中：
  - `proxy`：生成的代理对象本身；
  - `method`：被调用的接口方法对象（包含方法名、参数类型、返回值类型等信息）；
  - `args`：方法调用时传入的参数数组。
- **Proxy类**：用于生成代理对象的工具类，核心方法是`newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)`，该方法会在运行时动态生成一个实现了`interfaces`数组中所有接口的代理类实例，其中：
  - `loader`：类加载器，用于加载生成的代理类；
  - `interfaces`：需要代理的目标接口数组（JDK动态代理只能代理接口，不能代理类）；
  - `h`：实现了InvocationHandler接口的对象，即代理逻辑的载体。

### 1.2 JDK动态代理简单示例
为了快速理解，我们编写一个简单的JDK动态代理示例，模拟“无实现类执行方法”的效果：
```java
// 1. 定义目标接口（类似MyBatis的Mapper接口）
public interface UserDao {
    String selectUserName(Long id);
}

// 2. 实现InvocationHandler，编写代理逻辑（类似MyBatis的SQL执行逻辑）
public class UserDaoInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 这里可以编写自定义逻辑，比如执行SQL、返回模拟数据
        System.out.println("拦截到" + method.getName() + "方法，参数：" + Arrays.toString(args));
        // 模拟查询结果返回
        return "用户" + args[0] + ": 张三";
    }
}

// 3. 生成代理对象并调用方法
public class DynamicProxyTest {
    public static void main(String[] args) {
        // 创建InvocationHandler实例（代理逻辑载体）
        InvocationHandler handler = new UserDaoInvocationHandler();
        
        // 生成代理对象（实现了UserDao接口）
        UserDao userDaoProxy = (UserDao) Proxy.newProxyInstance(
                UserDao.class.getClassLoader(), // 类加载器
                new Class[]{UserDao.class},      // 目标接口
                handler                         // 代理逻辑
        );
        
        // 调用代理对象的方法（无实现类却能执行）
        String userName = userDaoProxy.selectUserName(1L);
        System.out.println("执行结果：" + userName);
    }
}

// 输出结果：
// 拦截到selectUserName方法，参数：[1]
// 执行结果：用户1: 张三
```

从示例中可以清晰看到：我们没有为`UserDao`接口编写任何实现类，但通过动态代理生成的`userDaoProxy`对象，却能正常调用`selectUserName`方法并得到结果。核心原因就是：**方法调用被转发到了InvocationHandler的invoke方法中，由invoke方法执行具体逻辑**。

而MyBatis的Mapper动态代理，正是基于这个逻辑实现的——Mapper接口对应示例中的`UserDao`，MyBatis自定义的InvocationHandler（`MapperProxy`）对应示例中的`UserDaoInvocationHandler`，SQL执行逻辑就封装在`MapperProxy`的invoke方法中。

## 二、MyBatis Mapper动态代理的核心实现
MyBatis对JDK动态代理进行了封装，通过一系列组件协同，将Mapper接口方法调用与SQL执行流程无缝衔接。核心组件包括：`MapperProxyFactory`（代理工厂，负责生成Mapper代理对象）、`MapperProxy`（InvocationHandler实现，封装代理逻辑）、`MapperMethod`（封装Mapper接口方法信息与SQL执行逻辑）。

### 2.1 核心流程总览
MyBatis Mapper动态代理的核心流程可概括为3步：
1. **Mapper接口注册**：MyBatis启动时，会扫描指定包下的Mapper接口（通过`@MapperScan`注解或XML配置），为每个Mapper接口创建一个`MapperProxyFactory`（代理工厂），并将其注册到`Configuration`（MyBatis的核心配置类）中。
2. **代理对象生成**：当我们调用`sqlSession.getMapper(Mapper.class)`时，MyBatis会从`Configuration`中获取对应Mapper接口的`MapperProxyFactory`，通过代理工厂的`newInstance(sqlSession)`方法生成代理对象（`MapperProxy`实例）。
3. **方法调用与SQL执行**：当调用代理对象的接口方法时，JVM会将调用转发到`MapperProxy`的`invoke`方法；在invoke方法中，MyBatis会创建`MapperMethod`对象，封装方法信息与SQL执行逻辑，最终通过`SqlSession`执行SQL并返回结果。

### 2.2 Step1：Mapper接口注册（启动时）
MyBatis启动阶段的核心任务之一，就是将Mapper接口“纳入管理”，为后续生成代理对象做准备。这一过程的核心触发点是`@MapperScan`注解（Spring整合MyBatis时）或XML中的`<mappers>`配置。

以Spring整合MyBatis为例，`@MapperScan`注解的作用是：指定需要扫描的Mapper接口包路径（如`com.example.mapper`），Spring会扫描该路径下的所有接口，通过`MapperScannerConfigurer`（MyBatis提供的Bean）将每个接口注册到MyBatis的`Configuration`中，具体操作是：
- 为每个Mapper接口创建一个`MapperProxyFactory`（代理工厂），并将其存入`Configuration`的`mapperRegistry`（Mapper注册表）中。
- `MapperProxyFactory`持有对应的Mapper接口类型（`mapperInterface`），后续通过该工厂生成代理对象时，会明确代理的目标接口。

核心源码片段（MyBatis的`MapperRegistry`类）：
```java
public class MapperRegistry {
    private final Configuration config;
    // 存储Mapper接口与对应的代理工厂
    private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<>();

    // 注册Mapper接口
    public <T> void addMapper(Class<T> type) {
        // 只注册接口，不注册类
        if (type.isInterface()) {
            if (!hasMapper(type)) {
                knownMappers.put(type, new MapperProxyFactory<>(type));
                // 解析Mapper接口中的注解SQL或XML中的SQL
                MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
                parser.parse();
            }
        }
    }

    // 获取Mapper接口对应的代理工厂
    public <T> MapperProxyFactory<T> getMapperFactory(Class<T> type) {
        return (MapperProxyFactory<T>) knownMappers.get(type);
    }
}
```

### 2.3 Step2：代理对象生成（getMapper时）
当我们在代码中调用`sqlSession.getMapper(UserMapper.class)`时，就会触发代理对象的生成。这一过程的核心逻辑在`MapperProxyFactory`的`newInstance`方法中。

核心流程拆解：
1. 从`Configuration`的`mapperRegistry`中，根据`UserMapper.class`获取对应的`MapperProxyFactory`。
2. 调用`MapperProxyFactory.newInstance(sqlSession)`，创建`MapperProxy`（实现了InvocationHandler接口）实例。
3. 通过`Proxy.newProxyInstance`生成代理对象，代理对象实现了`UserMapper`接口，且关联了`MapperProxy`（代理逻辑）。

核心源码片段（MyBatis的`MapperProxyFactory`类）：
```java
public class MapperProxyFactory<T> {
    // 目标Mapper接口类型（如UserMapper.class）
    private final Class<T> mapperInterface;

    public MapperProxyFactory(Class<T> mapperInterface) {
        this.mapperInterface = mapperInterface;
    }

    // 生成代理对象
    public T newInstance(SqlSession sqlSession) {
        // 创建InvocationHandler实例（MapperProxy），关联SqlSession
        final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface);
        // 调用Proxy.newProxyInstance生成代理对象
        return newInstance(mapperProxy);
    }

    private T newInstance(MapperProxy<T> mapperProxy) {
        return (T) Proxy.newProxyInstance(
                mapperInterface.getClassLoader(),  // 类加载器
                new Class[]{mapperInterface},       // 目标Mapper接口
                mapperProxy                         // 代理逻辑（InvocationHandler）
        );
    }
}
```

这里有一个关键细节：`MapperProxy`持有了`SqlSession`实例——而`SqlSession`是MyBatis中执行SQL的核心入口（提供了`selectOne`、`selectList`、`insert`等方法），这为后续执行SQL埋下了伏笔。

### 2.4 Step3：方法调用与SQL执行（调用接口方法时）
当我们通过代理对象调用`userMapper.selectUserById(1L)`时，由于代理对象是通过JDK动态代理生成的，JVM会自动将该方法调用转发到`MapperProxy`的`invoke`方法中。这一步是MyBatis动态代理的核心，也是“无实现类执行SQL”的关键。

#### 2.4.1 MapperProxy的invoke方法：拦截方法调用
`MapperProxy`是MyBatis自定义的InvocationHandler实现，其`invoke`方法的核心逻辑是：拦截Mapper接口的方法调用，将其转化为SQL执行请求。

核心源码片段（MyBatis的`MapperProxy`类）：
```java
public class MapperProxy<T> implements InvocationHandler, Serializable {
    private final SqlSession sqlSession;
    private final Class<T> mapperInterface;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 1. 过滤Object类的方法（如toString、hashCode），直接执行，不处理
        if (Object.class.equals(method.getDeclaringClass())) {
            return method.invoke(this, args);
        }
        // 2. 对接口方法进行处理：将方法调用转化为MapperMethod执行
        return cachedMapperMethod(method).execute(sqlSession, args);
    }

    // 缓存MapperMethod（避免重复创建，提升性能）
    private MapperMethod cachedMapperMethod(Method method) {
        return MapperMethodInvoker.of(method).apply(mapperInterface, sqlSession.getConfiguration());
    }
}
```

从源码中可以看到，invoke方法做了两件关键事：
- 过滤Object类的方法：比如`toString()`、`hashCode()`等，这些方法不属于Mapper接口的业务方法，直接调用默认实现即可。
- 处理Mapper接口方法：通过`cachedMapperMethod(method)`创建（或从缓存获取）`MapperMethod`对象，调用其`execute(sqlSession, args)`方法执行具体逻辑——这里的`MapperMethod`，就是MyBatis封装“方法信息”与“SQL执行逻辑”的核心载体。

#### 2.4.2 MapperMethod：封装方法与SQL的关联逻辑
`MapperMethod`的核心作用是：将Mapper接口的方法信息（方法名、参数、返回值）与对应的SQL语句（从XML或注解中解析而来）进行关联，并提供统一的`execute`方法执行SQL。

其内部包含两个关键属性：
- `SqlCommand`：封装SQL相关信息，包括SQL类型（SELECT/INSERT/UPDATE/DELETE）、SQL语句对应的`statementId`（全局唯一标识，格式为“Mapper接口全类名.方法名”，如`com.example.mapper.UserMapper.selectUserById`）。
- `MethodSignature`：封装方法的签名信息，包括方法的参数类型、返回值类型（如是否为集合、是否为基本类型等）。

#### 2.4.3 execute方法：执行SQL的核心逻辑
`MapperMethod`的`execute`方法，会根据SQL类型（SELECT/INSERT等）和方法返回值类型，调用`SqlSession`对应的方法执行SQL，最终将SQL执行结果转化为方法的返回值。

核心源码片段（MyBatis的`MapperMethod`类）：
```java
public class MapperMethod {
    private final SqlCommand command;
    private final MethodSignature method;

    public Object execute(SqlSession sqlSession, Object[] args) {
        Object result;
        // 根据SQL类型分发执行
        switch (command.getType()) {
            case INSERT: {
                // 处理INSERT语句，调用sqlSession.insert
                Object param = method.convertArgsToSqlCommandParam(args);
                result = rowCountResult(sqlSession.insert(command.getName(), param));
                break;
            }
            case UPDATE: {
                // 处理UPDATE语句，调用sqlSession.update
                Object param = method.convertArgsToSqlCommandParam(args);
                result = rowCountResult(sqlSession.update(command.getName(), param));
                break;
            }
            case DELETE: {
                // 处理DELETE语句，调用sqlSession.delete
                Object param = method.convertArgsToSqlCommandParam(args);
                result = rowCountResult(sqlSession.delete(command.getName(), param));
                break;
            }
            case SELECT:
                // 根据方法返回值类型，调用sqlSession对应的查询方法
                if (method.returnsVoid() && method.hasResultHandler()) {
                    executeWithResultHandler(sqlSession, args);
                    result = null;
                } else if (method.returnsMany()) {
                    // 返回集合，调用sqlSession.selectList
                    result = executeForMany(sqlSession, args);
                } else if (method.returnsMap()) {
                    // 返回Map，调用sqlSession.selectMap
                    result = executeForMap(sqlSession, args);
                } else if (method.returnsCursor()) {
                    result = executeForCursor(sqlSession, args);
                } else {
                    // 返回单个对象，调用sqlSession.selectOne
                    Object param = method.convertArgsToSqlCommandParam(args);
                    result = sqlSession.selectOne(command.getName(), param);
                }
                break;
            case FLUSH:
                result = sqlSession.flushStatements();
                break;
            default:
                throw new BindingException("Unknown execution method for: " + command.getName());
        }
        // 处理返回值为null的情况（如接口方法返回基本类型时，避免空指针）
        if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {
            throw new BindingException("Mapper method '" + command.getName() 
                    + "' attempted to return null from a method with a primitive return type (" + method.getReturnType() + ").");
        }
        return result;
    }
}
```

从源码中可以清晰看到：`MapperMethod`通过`command.getName()`获取到全局唯一的`statementId`（如`com.example.mapper.UserMapper.selectUserById`），然后调用`SqlSession`的对应方法（`selectOne`、`selectList`等）执行SQL。而`SqlSession`则会根据`statementId`从`Configuration`中找到对应的`MappedStatement`（封装了完整的SQL语句、参数映射、结果映射等信息），最终通过Executor（执行器）执行SQL并返回结果。

## 三、全链路梳理：从接口调用到SQL执行的完整流程
结合前面的拆解，我们将MyBatis Mapper接口调用SQL的全链路梳理为以下8个步骤，形成完整的逻辑闭环：
1. 开发人员定义`UserMapper`接口，并通过XML或注解编写`selectUserById`方法对应的SQL。
2. 项目启动时，MyBatis通过`@MapperScan`扫描到`UserMapper`接口，为其创建`MapperProxyFactory`并注册到`Configuration`中。
3. 开发人员通过`sqlSession.getMapper(UserMapper.class)`获取代理对象，底层由`MapperProxyFactory`通过JDK动态代理生成`MapperProxy`实例（代理对象）。
4. 调用代理对象的`selectUserById(1L)`方法，JVM将调用转发到`MapperProxy`的`invoke`方法。
5. `invoke`方法创建（或从缓存获取）`MapperMethod`对象，封装`selectUserById`方法的信息与对应的SQL信息。
6. `MapperMethod`的`execute`方法被调用，根据SQL类型（SELECT）和返回值类型（假设为单个User对象），调用`sqlSession.selectOne(statementId, 1L)`。
7. `SqlSession`根据`statementId`（如`com.example.mapper.UserMapper.selectUserById`）从`Configuration`中找到对应的`MappedStatement`，通过Executor（执行器）执行SQL，获取数据库返回的结果集。
8. MyBatis将结果集映射为User对象，沿调用链路返回给开发人员。

## 四、实践验证：如何确认代理对象的存在？
理论讲完后，我们可以通过简单的代码验证MyBatis生成的Mapper对象确实是动态代理对象：
```java
// 1. 获取SqlSession
SqlSession sqlSession = sqlSessionFactory.openSession();

// 2. 获取UserMapper对象
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

// 3. 打印对象类型
System.out.println("UserMapper对象类型：" + userMapper.getClass().getName());
// 输出结果：com.sun.proxy.$Proxy18（$Proxy开头，说明是JDK动态代理生成的对象）

// 4. 验证是否为代理对象
System.out.println("是否为代理对象：" + Proxy.isProxyClass(userMapper.getClass()));
// 输出结果：true

// 5. 获取代理对象的InvocationHandler
InvocationHandler invocationHandler = Proxy.getInvocationHandler(userMapper);
System.out.println("InvocationHandler类型：" + invocationHandler.getClass().getName());
// 输出结果：org.apache.ibatis.binding.MapperProxy（正是MyBatis的MapperProxy）
```

通过输出结果可以明确：我们获取到的`UserMapper`对象，是JDK动态代理生成的代理对象，其关联的InvocationHandler正是MyBatis的`MapperProxy`——这与我们前面的理论拆解完全一致。

## 五、常见问题与注意事项
理解了MyBatis Mapper动态代理的原理后，我们可以更清晰地解释开发中遇到的一些常见问题：

### 5.1 为什么Mapper接口不能有默认方法？
Java 8及以上支持接口定义默认方法（`default`修饰），但MyBatis的Mapper接口不能有默认方法。原因是：默认方法属于接口的实现方法，而JDK动态代理生成的代理对象，只会拦截接口中的抽象方法；当调用默认方法时，不会触发`MapperProxy`的`invoke`方法，导致MyBatis无法将其转化为SQL执行，进而抛出异常。

### 5.2 为什么Mapper接口不能被实例化？
因为Mapper接口是接口，不是类，无法通过`new`关键字实例化。我们获取到的“实例”，本质上是JDK动态代理生成的代理对象，该对象实现了Mapper接口，但并非接口的直接实现类。

### 5.3 为什么方法名要和XML中的id一致？
因为MyBatis通过“Mapper接口全类名.方法名”生成`statementId`，而XML中的`<select>`等标签的`id`属性，正是`statementId`的后半部分（方法名）。如果两者不一致，MyBatis将无法通过`statementId`找到对应的SQL语句，会抛出`BindingException`异常（如“Invalid bound statement (not found)”）。

### 5.4 可以使用CGLIB代理替代JDK动态代理吗？
可以。JDK动态代理只能代理接口，而CGLIB可以代理类（通过继承目标类生成子类）。MyBatis默认使用JDK动态代理，但如果需要使用CGLIB，只需在MyBatis配置中开启`proxy-target-class="true"`（Spring整合MyBatis时，可通过`@MapperScan(proxyTargetClass = true)`开启）。不过在实际开发中，由于Mapper本身就是接口，使用JDK动态代理已足够，无需额外切换。

## 六、总结
MyBatis Mapper接口“无实现类却能执行SQL”的核心，是对Java JDK动态代理技术的巧妙封装，其本质可以概括为：

**MyBatis在运行时为Mapper接口动态生成代理对象，将接口方法调用拦截并转发到自定义的InvocationHandler（MapperProxy）中；在InvocationHandler中，通过MapperMethod封装方法与SQL的关联逻辑，最终借助SqlSession执行SQL并返回结果。**

这一设计的优势在于：极大地简化了开发流程（无需编写接口实现类），同时实现了接口与SQL执行逻辑的解耦（SQL可通过XML或注解灵活配置）。