---
title: ClickHouse核心引擎家族
date: 2022-06-20 22:04:21
permalink: /pages/547ec1/
categories:
  - 《ClickHouse》笔记
tags:
  - ClickHouse核心引擎家族
author: 
  name: Tavio
  link: https://github.com/tavio-zhang
---

在 ClickHouse 的生态中，MergeTree 家族引擎是绝对的核心支柱，撑起了 90% 以上的生产级 OLAP 场景。与传统数据库“一种引擎走天下”的设计不同，MergeTree 家族通过“基础引擎 + 场景化衍生”的架构，为不同数据处理需求提供了精准优化的解决方案。

## 一、先搞懂：MergeTree 家族的核心设计理念

MergeTree 家族引擎专为高数据摄取率和海量数据存储分析设计，其核心优势源于三大底层设计，所有衍生引擎都继承并强化了这些特性：

- **列式存储**：每列独立存储，查询时仅读取所需列，大幅降低 I/O 开销，尤其适配 OLAP 场景的聚合分析需求；
- **异步合并机制**：数据写入时先生成小数据块（Part），后台进程异步将小 Part 合并为大 Part，优化存储结构和查询性能；
- **灵活的索引与分区**：支持稀疏主键索引（每 8192 行一个索引标记）和自定义分区键，实现快速数据定位和分区裁剪，提升查询效率。

核心定位：以“追加写”为基础，通过后台异步优化实现高性能读写，不支持实时事务和高频单行更新，所有衍生引擎均围绕“解决特定场景下的数据分析痛点”展开。

## 二、MergeTree 全家桶核心成员详解

MergeTree 家族以 `MergeTree` 为基础，衍生出 `ReplacingMergeTree`、`SummingMergeTree` 等多个子引擎，同时提供 `Replicated*` 系列副本引擎保障高可用。下面逐一拆解各成员的核心能力。

### 1. 基础核心：MergeTree —— 所有场景的基石

作为家族的“根引擎”，MergeTree 是 ClickHouse 最通用、最基础的引擎，提供了海量数据存储分析的核心能力，也是所有衍生引擎的实现基础。

#### 核心特性

- 支持自定义排序键（ORDER BY）：数据按排序键物理排序，优化压缩效率和查询跳过逻辑；
- 支持分区键（PARTITION BY）：常用日期字段分区（如 toYYYYMM(date)），实现快速分区删除和查询裁剪；
- 支持 TTL 规则：可设置数据生命周期，自动删除过期数据或迁移至低成本存储；
- 支持稀疏索引和二级跳过索引：快速定位数据块，减少无效 I/O；
- 批量写入优化：适配高吞吐追加写，不支持高频单行更新/删除。

#### 创建语法示例

```sql
CREATE TABLE user_behavior_log (
  user_id UInt32,
  event_date Date,
  action_type String,
  duration UInt32,
  device_id String
) ENGINE = MergeTree()
ORDER BY (event_date, user_id)  -- 排序键：优先按日期，再按用户ID
PARTITION BY toYYYYMM(event_date)  -- 按月分区
TTL event_date + INTERVAL 90 DAY DELETE;  -- 数据保留90天，过期自动删除
```

#### 适用场景

无特殊处理需求的通用 OLAP 场景，例如：

- 用户行为日志分析、业务监控数据存储；
- 自助报表分析、多维度钻取查询；
- 数据量较大、写入吞吐高，且无需去重或聚合的场景。

#### 注意事项

不支持实时去重和更新，若数据存在重复，需在查询时通过 `DISTINCT` 或聚合函数处理；不提供高可用保障，生产环境需结合副本引擎使用。

### 2. 去重更新：ReplacingMergeTree —— 解决重复数据问题

继承 MergeTree 基础能力，核心扩展“自动去重”功能，通过后台合并过程删除主键相同的重复行，保留最新版本数据。

#### 核心特性

- 按排序键去重：仅对同一分区内排序键相同的行去重，分区间或分片间重复数据不处理；
- 保留最新数据：合并时保留写入时间最晚（或指定版本列最大）的行；
- 去重异步性：去重仅在后台合并时触发，未合并的 Part 中仍可能存在重复数据。

#### 创建语法示例

```sql
CREATE TABLE user_profile (
  user_id UInt32,
  user_name String,
  phone String,
  update_time DateTime DEFAULT now(),  -- 版本列：标记数据更新时间
  status UInt8
) ENGINE = ReplacingMergeTree(update_time)  -- 指定update_time为版本列，保留最新值
ORDER BY user_id  -- 按user_id去重
PARTITION BY toYYYYMM(update_time);
```

#### 适用场景

- 数据存在重复写入的场景（如上游系统重试机制导致的重复）；
- 需要“最终一致性”更新的场景（如用户资料更新，只需保留最新状态）；
- 不要求实时去重，可接受异步合并后去重的场景。

#### 注意事项

- 查询时需配合 `argMax` 函数确保获取最新数据，例如 `SELECT user_id, argMax(user_name, update_time) FROM user_profile GROUP BY user_id`；
- 非聚合列（如用户昵称）在去重时可能保留任意值，需通过版本列严格控制；
- 不支持真正的“删除”操作，可通过写入相同排序键、标记状态为无效的方式实现逻辑删除。

### 3. 预聚合：SummingMergeTree —— 提升聚合查询性能

核心能力是在后台合并时，自动对排序键相同的行进行聚合求和，将多行合并为一行，大幅减少存储量并提升聚合查询速度。

#### 核心特性

- 自动求和聚合：仅对数值类型列求和，非数值列保留第一行数据；
- 按排序键聚合：同一分区内排序键相同的行才会被聚合；
- 聚合异步性：聚合仅在合并时触发，未合并 Part 需查询时实时聚合。

#### 创建语法示例

```sql
CREATE TABLE order_stat (
  merchant_id UInt32,
  order_date Date,
  order_amount Float64,  -- 数值列：求和目标
  order_count UInt32,    -- 数值列：求和目标
  region String
) ENGINE = SummingMergeTree()
ORDER BY (merchant_id, order_date)  -- 按商家+日期聚合
PARTITION BY toYYYYMM(order_date);
```

#### 适用场景

- 需要按固定维度聚合统计的场景（如商家每日订单金额、用户每日行为次数）；
- 聚合查询频繁，且只需关注总数/总和，无需保留明细的场景；
- 数据写入后不会再更新，或更新频率极低的场景（如历史订单统计）。

#### 注意事项

非数值列无法聚合，需确保排序键设计覆盖所有聚合维度；若需查询实时数据，需配合 `SUM` 函数和 `GROUP BY` 语句，避免未合并数据导致的结果偏差。

### 4. 复杂聚合：AggregatingMergeTree —— 自定义聚合逻辑

相比 SummingMergeTree 仅支持求和，AggregatingMergeTree 支持自定义聚合函数（如计数、去重计数、平均值等），通过存储聚合函数的中间状态，实现更灵活的预聚合能力。

#### 核心特性

- 支持多种聚合函数：需使用 `AggregateFunction` 数据类型存储中间状态；
- 自定义聚合逻辑：可通过 `uniq`（去重计数）、`avg`（平均值）等函数实现复杂统计；
- 常用于物化视图：配合物化视图实现增量数据的实时聚合。

#### 创建语法示例

```sql
-- 基础表：存储原始行为数据
CREATE TABLE user_view_log (
  user_id UInt32,
  page_id UInt32,
  view_time DateTime,
  stay_duration UInt32
) ENGINE = MergeTree()
ORDER BY (page_id, toDate(view_time))
PARTITION BY toYYYYMM(view_time);

-- 物化视图：基于AggregatingMergeTree实现页面访问统计
CREATE MATERIALIZED VIEW page_view_stat 
ENGINE = AggregatingMergeTree()
ORDER BY (page_id, view_date)
PARTITION BY toYYYYMM(view_date)
AS SELECT
  page_id,
  toDate(view_time) AS view_date,
  countState() AS total_view,  -- 总访问次数（聚合中间状态）
  uniqState(user_id) AS unique_user,  -- 独立访客数（去重计数）
  avgState(stay_duration) AS avg_stay  -- 平均停留时长
FROM user_view_log
GROUP BY page_id, toDate(view_time);
```

#### 适用场景

- 需要复杂聚合统计的场景（如独立访客数 UV、平均访问时长）；
- 增量数据聚合：通过物化视图实时同步原始数据并完成聚合；
- 大数据量下的聚合查询优化：减少查询时的实时计算压力。

#### 注意事项

查询时需使用对应的 `xxxMerge` 函数解析中间状态（如 `countMerge(total_view)`）；聚合函数的中间状态无法直接查看，需通过物化视图或查询函数解析；不支持聚合后的数据更新，若原始数据有误，需重建物化视图。

### 5. 状态折叠：CollapsingMergeTree & VersionedCollapsingMergeTree —— 处理状态变更

专为“状态变更型数据”设计，通过 `sign` 列（1 表示新增/激活，-1 表示删除/失效）标记数据状态，后台合并时自动“折叠”（删除）状态互补的行，保留最新有效状态。

#### 核心差异

- **CollapsingMergeTree**：需严格保证数据写入顺序，状态变更行必须紧跟原始行，否则无法正确折叠；
- **VersionedCollapsingMergeTree**：在 CollapsingMergeTree 基础上增加版本列，支持乱序写入，多线程插入更友好，是更推荐的版本。

#### 创建语法示例（VersionedCollapsingMergeTree）

```sql
CREATE TABLE order_status_log (
  order_id UInt64,
  status String,  -- 订单状态：待支付、已支付、已取消
  update_time DateTime,
  sign Int8,  -- 状态标记：1=新增/更新，-1=删除/失效
  version UInt32  -- 版本列：确保乱序写入时正确折叠
) ENGINE = VersionedCollapsingMergeTree(sign, version)
ORDER BY order_id
PARTITION BY toYYYYMM(update_time);
```

#### 适用场景

- 需要记录状态变更历史并保留最新状态的场景（如订单状态变更、用户会员等级变更）；
- 消费 CDC 数据（如 Debezium 同步的数据库变更日志）；
- 需要清理过期状态数据，减少存储量的场景。

#### 注意事项

必须严格维护 `sign` 列和版本列的一致性；查询时需配合 `FINAL` 关键字确保状态完全折叠（但会降低查询性能）；不支持部分字段的状态更新，需整体替换行数据。

### 6. 稀疏更新：CoalescingMergeTree —— 填充缺失值

MergeTree 家族的新增成员（ClickHouse 25.6+），核心能力是在后台合并时自动保留每列的最新非空值，适用于处理稀疏更新数据（如 IoT 设备的碎片化状态上报）。

#### 核心特性

- 填充缺失值：合并时对同一排序键的行，每列保留最新的非空值；
- 避免全量覆盖：无需像 ReplacingMergeTree 那样覆盖整行，仅补充非空字段；
- 适配高吞吐稀疏更新：如 IoT 设备的碎片化状态上报（电池电量、位置、温度等字段分批上报）。

#### 创建语法示例

```sql
CREATE TABLE electric_vehicle_state (
  vin String,  -- 车辆识别码
  last_update DateTime64 DEFAULT now64(),  -- 最后更新时间
  battery_level Nullable(UInt8),  -- 电池电量（可能为空）
  lat Nullable(Float64),  -- 纬度（可能为空）
  lon Nullable(Float64),  -- 经度（可能为空）
  firmware_version Nullable(String)  -- 固件版本（可能为空）
) ENGINE = CoalescingMergeTree()
ORDER BY vin
PARTITION BY toYYYYMM(last_update);
```

#### 适用场景

- IoT 设备状态监控：设备分系统、分时段上报碎片化数据；
- 稀疏更新场景：仅需补充部分字段的最新值，无需全量更新；
- 需要保留完整实体状态的场景（如车辆实时状态汇总）。

#### 注意事项

需配合 `argMax` 函数查询最新状态；仅支持 ClickHouse 25.6 及以上版本；不支持删除操作，需通过写入空值+最新时间戳实现字段失效。

### 7. 高可用保障：Replicated*MergeTree —— 副本引擎

上述所有引擎均有对应的 `Replicated*` 副本版本（如 ReplicatedMergeTree、ReplicatedReplacingMergeTree），核心是在基础引擎能力上增加数据复制功能，实现高可用、故障转移和负载均衡。

#### 核心特性

- 数据多副本同步：依赖 ZooKeeper 或 ClickHouse Keeper 协调副本数据同步；
- 故障转移：单个节点宕机时，查询可自动切换到其他副本；
- 写入幂等性：支持重复写入重试，避免网络问题导致的数据丢失；
- 完全继承基础引擎能力：副本功能与基础引擎的去重、聚合等能力不冲突。

#### 创建语法示例（ReplicatedMergeTree）

```sql
CREATE TABLE user_log_replicated (
  user_id UInt32,
  event_date Date,
  action String,
  duration UInt32
) ENGINE = ReplicatedMergeTree(
  '/clickhouse/tables/{shard}/user_log_replicated',  -- ZooKeeper路径（按分片区分）
  '{replica}'  -- 副本标识（每个节点唯一）
)
ORDER BY (event_date, user_id)
PARTITION BY toYYYYMM(event_date);
```

#### 适用场景

- 生产环境的核心业务表：需要高可用性，避免单点故障；
- 数据可靠性要求高的场景：如交易数据、核心监控数据；
- 分布式集群部署：配合分片实现大规模数据存储和并行查询。

#### 注意事项

- 依赖 ZooKeeper/ClickHouse Keeper：需提前部署并配置正确；
- 副本数量建议 2-3 个：过多副本会增加写入延迟和存储成本；
- 避免小批量高频写入：会导致副本同步压力增大，建议批量写入（每批 > 1000 行）。

## 三、MergeTree 全家桶选型决策指南

选型的核心是“匹配业务场景”—— 先明确数据处理需求（是否去重、是否聚合、是否需要高可用），再对应选择合适的引擎。以下是分场景的选型建议和对比表格。

### 1. 核心引擎对比表

| 引擎类型                | 核心能力                          | 适用场景                                  | 优点                                      | 缺点                                      |
| ----------------------- | --------------------------------- | ----------------------------------------- | ----------------------------------------- | ----------------------------------------- |
| MergeTree               | 基础读写、分区、排序              | 通用 OLAP 分析、日志存储                  | 性能均衡、适用范围广、配置简单            | 不支持去重、更新；无高可用                |
| ReplacingMergeTree      | 异步去重、保留最新数据            | 数据去重、用户状态更新                    | 自动去重、简化应用层逻辑                  | 去重异步；分区间不生效；需配合函数查询    |
| SummingMergeTree        | 异步求和聚合                      | 固定维度统计（金额、次数）                | 减少存储、提升聚合查询速度                | 仅支持求和；非数值列保留不确定            |
| AggregatingMergeTree    | 自定义复杂聚合（存储中间状态）    | 复杂统计（UV、平均时长）、增量聚合        | 聚合逻辑灵活、适配多种统计需求、减轻查询计算压力 | 需配合物化视图使用；中间状态不可直接查看；原始数据错误需重建视图 |
| VersionedCollapsingMergeTree | 状态变更折叠、支持乱序写入      | 订单状态跟踪、CDC数据消费、状态历史管理    | 自动清理过期状态、支持多线程乱序写入、适配状态变更场景 | 需维护sign和version列；查询需加FINAL影响性能；不支持部分字段更新 |
| CoalescingMergeTree     | 稀疏更新填充、保留列最新非空值    | IoT设备碎片化上报、部分字段补充更新        | 无需全量覆盖更新、适配高吞吐稀疏写入、保留完整实体状态 | 仅支持ClickHouse 25.6+；需配合argMax查询；不支持删除操作 |
| Replicated*MergeTree    | 数据多副本同步、高可用保障        | 生产核心业务表、高可靠性要求场景、分布式集群 | 支持故障转移、数据不丢失、负载均衡、继承基础引擎全部能力 | 依赖ZooKeeper/Keeper；增加写入延迟；多副本提升存储成本 |

### 2. 分场景选型决策路径

结合业务核心需求，按以下路径可快速锁定合适引擎，避免无效选型：

#### （1）基础判断：是否需要高可用？

若是生产环境核心表、数据可靠性要求高，直接选择对应 `Replicated*` 副本引擎（如基础场景选 ReplicatedMergeTree，去重场景选 ReplicatedReplacingMergeTree）；非核心测试表或单机部署场景，选择非副本基础引擎即可。

#### （2）核心需求：数据处理方式

- **无特殊处理（仅存储+分析）**：直接选 MergeTree，适配绝大多数通用 OLAP 场景（日志分析、报表查询等）；
- **存在重复数据，需保留最新**：选 ReplacingMergeTree，注意需通过版本列控制数据新旧，查询配合 argMax 函数；
- **需按固定维度聚合统计（求和为主）**：选 SummingMergeTree，适合订单金额汇总、用户行为次数统计等场景；
- **复杂聚合需求（UV、平均时长等）**：选 AggregatingMergeTree + 物化视图，通过自定义聚合函数实现灵活统计；
- **数据存在状态变更（新增/失效）**：选 VersionedCollapsingMergeTree（推荐），无需严格控制写入顺序，适配 CDC 同步、订单状态变更等场景；
- **稀疏更新（部分字段分批上报）**：若使用 ClickHouse 25.6+，选 CoalescingMergeTree，避免全量更新，适配 IoT 设备状态监控场景。

### 3. 选型避坑指南

实际选型中，需规避以下常见误区，确保引擎适配业务实际需求：

- **不要过度追求“功能全面”**：例如无需去重场景强行使用 ReplacingMergeTree，会增加后台合并压力，降低性能；
- **明确异步机制的局限性**：所有衍生引擎的去重、聚合、折叠均为异步触发，不可依赖其实现实时一致性（如实时订单状态查询需谨慎）；
- **排序键设计是核心**：所有衍生引擎的去重、聚合、折叠均基于排序键，需确保排序键覆盖核心维度（如去重场景包含唯一标识，聚合场景包含统计维度）；
- **副本不是越多越好**：2-3 个副本即可满足高可用需求，过多副本会显著增加写入延迟和存储成本；
- **小批量高频写入需优化**：尤其对于副本引擎，小批量高频写入会导致大量 Part 生成，增加同步压力，建议合并为批量写入（每批 > 1000 行）。

## 四、总结：核心选型原则与实践建议

MergeTree 家族引擎的选型核心是“场景匹配”，而非“功能堆砌”。实践中可遵循以下原则：

1. **从简单到复杂**：优先使用基础 MergeTree，仅在存在明确痛点（重复、聚合、状态变更）时，再选择对应衍生引擎；
2. **明确一致性要求**：若需实时一致性（如实时交易查询），ClickHouse 并非最优选择，需结合业务场景考虑其他数据库，或接受异步一致性并通过查询函数兜底；
3. **结合集群架构**：分布式部署场景，需同步考虑分片（Sharding）与副本（Replicated）设计，引擎选择需适配分片策略（如按用户 ID 分片时，去重需注意分片间重复数据）；
4. **优先测试验证**：不同业务的数据量、写入频率、查询模式差异较大，选型后需通过压测验证性能（写入吞吐、查询延迟），确保满足业务指标。

最终，MergeTree 全家桶的核心价值在于“精准适配”—— 通过不同引擎的特性组合，既能支撑海量数据的高吞吐写入和高效分析，又能通过场景化优化降低应用层复杂度。掌握其核心设计理念和选型逻辑，才能真正发挥 ClickHouse 在 OLAP 场景的性能优势。