---
title: JVM 对象的创建与调用
date: 2022-03-05 21:05:23
permalink: /pages/7be3b9/
categories:
  - 《JVM》笔记
tags:
  - new对象
author: 
  name: Tavio
  link: https://github.com/tavio-zhang
---

在Java世界中，对象是代码逻辑的载体，而对象的创建过程则是连接类加载机制、JVM内存模型与垃圾回收的核心链路。从`new User()`指令的执行到对象在堆中可用，再到通过引用访问对象的细节，每一步都蕴含着JVM的设计智慧。

## 一、对象创建的完整流程

Java对象的创建必须基于**已完成初始化的类**——只有当类加载的“加载-验证-准备-解析-初始化”五阶段全部完成后，JVM才会在堆内存中为该类的实例分配空间。无论是通过`new`关键字、反射（`Class.newInstance()`）、克隆（`clone()`）还是反序列化创建对象，最终都会触发以下核心流程：

### 1.1 类加载检查：确保类已就绪

当JVM接收到创建对象的指令（如`new User()`）时，首先会进行类加载检查：  
- 检查指令中的类名（如`User`）是否已在方法区中存在对应的类元数据。  
- 若未加载，则触发类加载流程（从.class文件加载到方法区，并完成验证、准备、解析、初始化）。  
- 只有当类的初始化阶段完成（即`<clinit>()`方法执行完毕），才能进入后续步骤。  

**核心目的**：确保对象创建的“模板”（类元数据）已完全就绪，避免基于未初始化的类创建实例。

### 1.2 内存分配：从空间计算到并发安全

类加载检查通过后，JVM需要为对象分配内存。这一步的核心是**确定内存大小**并**安全分配空间**。

#### 1.2.1 内存大小计算

对象所需的内存大小在类加载完成后即可确定，计算公式为：  
`对象内存大小 = 对象头大小 + 实例字段大小 + 对齐填充大小`  
- 实例字段大小：由类中声明的实例变量（非静态）决定，基本类型按固定大小（如`int`占4字节），引用类型在开启指针压缩时占4字节（默认开启，`-XX:+UseCompressedOops`），否则占8字节。  
- 对齐填充：JVM要求对象内存大小必须是8字节的整数倍（默认对齐系数为8），不足时用空字节填充，保证内存访问效率。  

#### 1.2.2 分配策略：指针碰撞 vs 空闲列表

JVM根据堆内存的规整程度，选择两种分配策略：  

| 策略         | 适用场景                  | 原理                                                                 | 优缺点                                                                 |
|--------------|---------------------------|----------------------------------------------------------------------|------------------------------------------------------------------------|
| 指针碰撞     | 堆内存无碎片（连续空闲）  | 堆中维护一个“空闲指针”，分配时将指针向空闲区移动“对象大小”的距离       | 优点：速度快（仅移动指针）；缺点：依赖内存规整（需垃圾收集器支持压缩）   |
| 空闲列表     | 堆内存有碎片              | JVM维护一张“空闲内存块列表”，分配时从列表中找到足够大的块分配给对象   | 优点：支持内存碎片化；缺点：需遍历列表查找合适块，速度较慢               |

**策略选择与垃圾收集器的关系**：  
- 采用“标记-整理”或“复制算法”的收集器（如Serial、ParNew、G1）会整理内存碎片，适合指针碰撞；  
- 采用“标记-清除”的收集器（如CMS）会产生碎片，适合空闲列表。  

#### 1.2.3 并发安全保障：TLAB与CAS

多线程同时创建对象时，可能出现“指针碰撞的并发修改”或“空闲列表的竞争”问题。JVM通过两种机制解决：  

- **TLAB（Thread Local Allocation Buffer，线程本地分配缓冲区）**：  
  JVM为每个线程在Eden区预分配一块独立的内存（默认大小为Eden区的1%，可通过`-XX:TLABSize`调整）。线程创建对象时优先在自己的TLAB中分配，无需竞争全局内存；当TLAB用尽时，再通过CAS竞争全局内存。  
  优点：避免多数情况下的锁竞争，提升分配效率。  

- **CAS + 失败重试**：  
  当TLAB不足或未启用时，JVM通过CAS（Compare-And-Swap）原子操作保证内存分配的原子性——若操作失败（如被其他线程修改），则重试直到成功。  

### 1.3 初始化零值：奠定安全基础

内存分配完成后，JVM会将分配的内存空间**全部初始化为零值**（不包括对象头）：  
- 基本类型：`int=0`、`long=0L`、`float=0.0f`、`double=0.0d`、`boolean=false`、`char='\u0000'`；  
- 引用类型：`null`。  

**核心作用**：  
- 保证对象的实例字段无需显式赋值就能拥有默认值（符合Java语言规范）；  
- 避免内存中残留的垃圾数据导致不可预期的错误。  

### 1.4 设置对象头：存储核心元数据

对象头是Java对象的“身份证”，存储对象的生命周期信息和类关联信息。JVM会在此步骤为对象头填充以下内容：

#### 1.4.1 Mark Word：对象的状态标识（8字节）

Mark Word是对象头中最复杂的部分，存储对象的哈希码、锁状态、GC分代年龄等动态信息，其结构会随对象状态变化而改变（以64位JVM为例）：  

| 状态       | 存储内容                                                                 |
|------------|--------------------------------------------------------------------------|
| 无锁状态   | 哈希码（31位） + 分代年龄（4位） + 偏向锁标识（1位） + 锁状态（2位=01）   |
| 偏向锁状态 | 线程ID（54位） + Epoch（2位） + 分代年龄（4位） + 偏向锁标识（1位=1） + 锁状态（2位=01） |
| 轻量级锁   | 指向栈中锁记录的指针（62位） + 锁状态（2位=00）                           |
| 重量级锁   | 指向监视器（monitor）的指针（62位） + 锁状态（2位=10）                     |
| GC标记     | 空（62位） + 锁状态（2位=11）                                             |  

#### 1.4.2 Klass Pointer：与类元数据的桥梁（4字节/8字节）

指向方法区中该对象对应的类元数据（如`User.class`），通过它JVM可确定对象的类型（例如“这个对象是User类的实例”）。  
- 默认开启指针压缩（`-XX:+UseCompressedClassPointers`）时占4字节；  
- 关闭时占8字节（直接存储64位地址）。  

#### 1.4.3 数组长度（可选，4字节）

若对象是数组实例，对象头会额外增加4字节存储数组长度——因为数组的长度无法通过类元数据确定（不同数组实例长度可能不同）。  

### 1.5 执行`<init>()`方法：完成实例化

对象创建的最后一步是执行构造方法（`<init>()`），完成实例的初始化：  
1. 调用父类的`<init>()`方法（递归直到`Object`类）；  
2. 初始化实例字段（执行显式赋值或初始化块）；  
3. 执行构造方法中的业务逻辑。  

**注意**：`<init>()`是实例初始化方法，由编译器根据类的构造函数自动生成；与类初始化方法`<clinit>()`（执行静态变量和静态块）不同，`<init>()`针对实例，每创建一个对象都会执行一次。  

## 二、对象的访问方式：引用与实例的连接

Java中，栈帧的局部变量表存储的是对象的**引用（reference）**，而非对象本身。通过引用访问堆中对象的方式有两种，HotSpot虚拟机默认采用**直接指针访问**。

### 2.1 句柄访问：间接跳转的稳定性

- **原理**：堆内存中划出一块“句柄池”，栈引用存储的是句柄地址；句柄中包含两个指针：一个指向堆中的对象实例，另一个指向方法区的类元数据。  
- **访问流程**：栈引用 → 句柄池 → 堆对象实例 / 方法区类元数据。  

**优点**：对象移动（如GC复制算法中的对象复制）时，只需修改句柄中指向实例的指针，栈中的引用无需变动，稳定性高。  
**缺点**：多一次句柄跳转，访问效率较低。  

### 2.2 直接指针访问：高效的直接映射

- **原理**：栈引用直接存储堆中对象实例的地址；对象实例通过自身的Klass Pointer指向方法区的类元数据。  
- **访问流程**：栈引用 → 堆对象实例 → 方法区类元数据。  

**优点**：少一次内存跳转，访问效率更高（HotSpot默认选择此方式，追求性能优先）。  
**缺点**：对象移动时，需修改所有指向该对象的栈引用（依赖GC的记忆集技术追踪引用）。  

### 2.3 两种方式的对比与选择

| 维度         | 句柄访问                     | 直接指针访问                 |
|--------------|------------------------------|------------------------------|
| 效率         | 较低（多一次跳转）           | 较高（直接定位）             |
| 稳定性       | 高（对象移动不影响引用）     | 中（需同步修改引用）         |
| 内存开销     | 额外句柄池空间               | 无额外开销                   |
| 典型应用     | 部分嵌入式JVM                | HotSpot虚拟机默认方式        |  

## 总结

Java对象的创建是JVM内存管理的核心流程：从类加载检查确保“模板”就绪，到内存分配解决空间与并发问题，再到零值初始化、对象头设置，最终通过`<init>()`完成实例化。而对象的访问方式则平衡了效率与稳定性，直接指针访问凭借高性能成为主流选择。